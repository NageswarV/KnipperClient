/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ServiceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAddressesByUser(userId: string | null | undefined): Observable<Address[]> {
        let url_ = this.baseUrl + "/api/Address/GetAddressesByUser?";
        if (userId !== undefined && userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressesByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressesByUser(<any>response_);
                } catch (e) {
                    return <Observable<Address[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Address[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAddressesByUser(response: HttpResponseBase): Observable<Address[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Address.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Address[]>(<any>null);
    }

    /**
     * @return Success
     */
    getctiveAnnouncements(): Observable<Announcement[]> {
        let url_ = this.baseUrl + "/api/Announcement/GetctiveAnnouncements";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetctiveAnnouncements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetctiveAnnouncements(<any>response_);
                } catch (e) {
                    return <Observable<Announcement[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Announcement[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetctiveAnnouncements(response: HttpResponseBase): Observable<Announcement[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Announcement.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Announcement[]>(<any>null);
    }

    /**
     * @return Success
     */
    getClassificationValues(): Observable<ClassificationValue[]> {
        let url_ = this.baseUrl + "/api/Classification/GetClassificationValues";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassificationValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassificationValues(<any>response_);
                } catch (e) {
                    return <Observable<ClassificationValue[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassificationValue[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassificationValues(response: HttpResponseBase): Observable<ClassificationValue[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassificationValue.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassificationValue[]>(<any>null);
    }

    /**
     * @return Success
     */
    getClassificationTypes(): Observable<ClassificationType[]> {
        let url_ = this.baseUrl + "/api/Classification/GetClassificationTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassificationTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassificationTypes(<any>response_);
                } catch (e) {
                    return <Observable<ClassificationType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassificationType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassificationTypes(response: HttpResponseBase): Observable<ClassificationType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassificationType.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassificationType[]>(<any>null);
    }

    /**
     * @param classificationTypeId (optional) 
     * @return Success
     */
    getClassificationValuesByType(classificationTypeId: string | undefined): Observable<ClassificationValue[]> {
        let url_ = this.baseUrl + "/api/Classification/GetClassificationValuesByType?";
        if (classificationTypeId === null)
            throw new Error("The parameter 'classificationTypeId' cannot be null.");
        else if (classificationTypeId !== undefined)
            url_ += "classificationTypeId=" + encodeURIComponent("" + classificationTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassificationValuesByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassificationValuesByType(<any>response_);
                } catch (e) {
                    return <Observable<ClassificationValue[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassificationValue[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassificationValuesByType(response: HttpResponseBase): Observable<ClassificationValue[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassificationValue.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassificationValue[]>(<any>null);
    }

    /**
     * @param classificationTypeCode (optional) 
     * @return Success
     */
    getClassificationValuesByTypeCode(classificationTypeCode: string | null | undefined): Observable<ClassificationValue[]> {
        let url_ = this.baseUrl + "/api/Classification/GetClassificationValuesByTypeCode?";
        if (classificationTypeCode !== undefined && classificationTypeCode !== null)
            url_ += "classificationTypeCode=" + encodeURIComponent("" + classificationTypeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassificationValuesByTypeCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassificationValuesByTypeCode(<any>response_);
                } catch (e) {
                    return <Observable<ClassificationValue[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassificationValue[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassificationValuesByTypeCode(response: HttpResponseBase): Observable<ClassificationValue[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassificationValue.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassificationValue[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCountries(): Observable<Country[]> {
        let url_ = this.baseUrl + "/api/Country/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<Country[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Country[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<Country[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Country.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Country[]>(<any>null);
    }

    /**
     * @return Success
     */
    getWeeklyOrderVolumeTrends(): Observable<ChartDataResponseDto> {
        let url_ = this.baseUrl + "/api/Dashboard/GetWeeklyOrderVolumeTrends";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeeklyOrderVolumeTrends(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeeklyOrderVolumeTrends(<any>response_);
                } catch (e) {
                    return <Observable<ChartDataResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartDataResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeeklyOrderVolumeTrends(response: HttpResponseBase): Observable<ChartDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChartDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartDataResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    get14DayOrderEventsTrends(): Observable<ChartDataResponseDto[]> {
        let url_ = this.baseUrl + "/api/Dashboard/Get14DayOrderEventsTrends";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet14DayOrderEventsTrends(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet14DayOrderEventsTrends(<any>response_);
                } catch (e) {
                    return <Observable<ChartDataResponseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartDataResponseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet14DayOrderEventsTrends(response: HttpResponseBase): Observable<ChartDataResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartDataResponseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartDataResponseDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getWeeklyCommunicationsVolumeTrends(): Observable<ChartDataResponseDto[]> {
        let url_ = this.baseUrl + "/api/Dashboard/GetWeeklyCommunicationsVolumeTrends";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeeklyCommunicationsVolumeTrends(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeeklyCommunicationsVolumeTrends(<any>response_);
                } catch (e) {
                    return <Observable<ChartDataResponseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartDataResponseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeeklyCommunicationsVolumeTrends(response: HttpResponseBase): Observable<ChartDataResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartDataResponseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartDataResponseDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getMonthlySVLVolumeTrends(): Observable<ChartDataResponseDto[]> {
        let url_ = this.baseUrl + "/api/Dashboard/GetMonthlySVLVolumeTrends";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMonthlySVLVolumeTrends(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMonthlySVLVolumeTrends(<any>response_);
                } catch (e) {
                    return <Observable<ChartDataResponseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartDataResponseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMonthlySVLVolumeTrends(response: HttpResponseBase): Observable<ChartDataResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartDataResponseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartDataResponseDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getWeeklyAODTracking(): Observable<ChartDataResponseDto> {
        let url_ = this.baseUrl + "/api/Dashboard/GetWeeklyAODTracking";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeeklyAODTracking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeeklyAODTracking(<any>response_);
                } catch (e) {
                    return <Observable<ChartDataResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartDataResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeeklyAODTracking(response: HttpResponseBase): Observable<ChartDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChartDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartDataResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    getHandCarryMetrics(): Observable<ChartDataResponseDto[]> {
        let url_ = this.baseUrl + "/api/Dashboard/GetHandCarryMetrics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHandCarryMetrics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHandCarryMetrics(<any>response_);
                } catch (e) {
                    return <Observable<ChartDataResponseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartDataResponseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHandCarryMetrics(response: HttpResponseBase): Observable<ChartDataResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartDataResponseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartDataResponseDto[]>(<any>null);
    }

    /**
     * @param periodType (optional) 
     * @param startDate (optional) 
     * @return Success
     */
    getOrderMetrics(periodType: string | null | undefined, startDate: Date | null | undefined): Observable<OrderMetricsDto> {
        let url_ = this.baseUrl + "/api/DtpOrder/GetOrderMetrics?";
        if (periodType !== undefined && periodType !== null)
            url_ += "PeriodType=" + encodeURIComponent("" + periodType) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderMetrics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderMetrics(<any>response_);
                } catch (e) {
                    return <Observable<OrderMetricsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderMetricsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderMetrics(response: HttpResponseBase): Observable<OrderMetricsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderMetricsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderMetricsDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getDtpOrderDetail(orderId: string | null | undefined): Observable<DtpOrderDto> {
        let url_ = this.baseUrl + "/api/DtpOrder/GetDtpOrderDetail?";
        if (orderId !== undefined && orderId !== null)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDtpOrderDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDtpOrderDetail(<any>response_);
                } catch (e) {
                    return <Observable<DtpOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DtpOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDtpOrderDetail(response: HttpResponseBase): Observable<DtpOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DtpOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DtpOrderDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getDtrOrderDetail(orderId: string | null | undefined): Observable<DtrOrderDto> {
        let url_ = this.baseUrl + "/api/DtrOrder/GetDtrOrderDetail?";
        if (orderId !== undefined && orderId !== null)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDtrOrderDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDtrOrderDetail(<any>response_);
                } catch (e) {
                    return <Observable<DtrOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DtrOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDtrOrderDetail(response: HttpResponseBase): Observable<DtrOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DtrOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DtrOrderDto>(<any>null);
    }

    /**
     * @param periodType (optional) 
     * @param startDate (optional) 
     * @return Success
     */
    getOrderMetrics2(periodType: string | null | undefined, startDate: Date | null | undefined): Observable<OrderMetricsDto> {
        let url_ = this.baseUrl + "/api/HandCarryOrder/GetOrderMetrics?";
        if (periodType !== undefined && periodType !== null)
            url_ += "PeriodType=" + encodeURIComponent("" + periodType) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderMetrics2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderMetrics2(<any>response_);
                } catch (e) {
                    return <Observable<OrderMetricsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderMetricsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderMetrics2(response: HttpResponseBase): Observable<OrderMetricsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderMetricsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderMetricsDto>(<any>null);
    }

    /**
     * @return Success
     */
    getHcpsIncludingDtpOrders(): Observable<Hcp[]> {
        let url_ = this.baseUrl + "/api/Hcp/GetHcpsIncludingDtpOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHcpsIncludingDtpOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHcpsIncludingDtpOrders(<any>response_);
                } catch (e) {
                    return <Observable<Hcp[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Hcp[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHcpsIncludingDtpOrders(response: HttpResponseBase): Observable<Hcp[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Hcp.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Hcp[]>(<any>null);
    }

    /**
     * @param hcpId (optional) 
     * @return Success
     */
    getDtrOrdersByHcpId(hcpId: string | null | undefined): Observable<DtrOrder[]> {
        let url_ = this.baseUrl + "/api/Hcp/GetDtrOrdersByHcpId?";
        if (hcpId !== undefined && hcpId !== null)
            url_ += "HcpId=" + encodeURIComponent("" + hcpId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDtrOrdersByHcpId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDtrOrdersByHcpId(<any>response_);
                } catch (e) {
                    return <Observable<DtrOrder[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DtrOrder[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDtrOrdersByHcpId(response: HttpResponseBase): Observable<DtrOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DtrOrder.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DtrOrder[]>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getCommunicationsyOrderId(orderId: string | null | undefined): Observable<Communication[]> {
        let url_ = this.baseUrl + "/api/Hcp/GetCommunicationsyOrderId?";
        if (orderId !== undefined && orderId !== null)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommunicationsyOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommunicationsyOrderId(<any>response_);
                } catch (e) {
                    return <Observable<Communication[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Communication[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCommunicationsyOrderId(response: HttpResponseBase): Observable<Communication[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Communication.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Communication[]>(<any>null);
    }

    /**
     * @param hcpId (optional) 
     * @return Success
     */
    getHandCarryDisbursementsByHcp(hcpId: string | null | undefined): Observable<HandCarryDisbursement[]> {
        let url_ = this.baseUrl + "/api/Hcp/GetHandCarryDisbursementsByHcp?";
        if (hcpId !== undefined && hcpId !== null)
            url_ += "HcpId=" + encodeURIComponent("" + hcpId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHandCarryDisbursementsByHcp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHandCarryDisbursementsByHcp(<any>response_);
                } catch (e) {
                    return <Observable<HandCarryDisbursement[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandCarryDisbursement[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHandCarryDisbursementsByHcp(response: HttpResponseBase): Observable<HandCarryDisbursement[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HandCarryDisbursement.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandCarryDisbursement[]>(<any>null);
    }

    /**
     * @param hcpId (optional) 
     * @return Success
     */
    getHandCarrySignatureAuditsByHcp(hcpId: string | null | undefined): Observable<HandCarrySignatureAudit[]> {
        let url_ = this.baseUrl + "/api/Hcp/GetHandCarrySignatureAuditsByHcp?";
        if (hcpId !== undefined && hcpId !== null)
            url_ += "HcpId=" + encodeURIComponent("" + hcpId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHandCarrySignatureAuditsByHcp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHandCarrySignatureAuditsByHcp(<any>response_);
                } catch (e) {
                    return <Observable<HandCarrySignatureAudit[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandCarrySignatureAudit[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHandCarrySignatureAuditsByHcp(response: HttpResponseBase): Observable<HandCarrySignatureAudit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HandCarrySignatureAudit.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandCarrySignatureAudit[]>(<any>null);
    }

    /**
     * @param orderID (optional) 
     * @return Success
     */
    getHandCarryTransferInformation(orderID: string | null | undefined): Observable<HandCarryTransferInformation> {
        let url_ = this.baseUrl + "/api/Hcp/GetHandCarryTransferInformation?";
        if (orderID !== undefined && orderID !== null)
            url_ += "orderID=" + encodeURIComponent("" + orderID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHandCarryTransferInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHandCarryTransferInformation(<any>response_);
                } catch (e) {
                    return <Observable<HandCarryTransferInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandCarryTransferInformation>><any>_observableThrow(response_);
        }));
    }

    protected processGetHandCarryTransferInformation(response: HttpResponseBase): Observable<HandCarryTransferInformation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HandCarryTransferInformation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandCarryTransferInformation>(<any>null);
    }

    /**
     * @param disbursementId (optional) 
     * @return Success
     */
    getHandCarryDisbursementDetails(disbursementId: string | null | undefined): Observable<HandCarryDisbursementDetail> {
        let url_ = this.baseUrl + "/api/Hcp/GetHandCarryDisbursementDetails?";
        if (disbursementId !== undefined && disbursementId !== null)
            url_ += "disbursementId=" + encodeURIComponent("" + disbursementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHandCarryDisbursementDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHandCarryDisbursementDetails(<any>response_);
                } catch (e) {
                    return <Observable<HandCarryDisbursementDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandCarryDisbursementDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGetHandCarryDisbursementDetails(response: HttpResponseBase): Observable<HandCarryDisbursementDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HandCarryDisbursementDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandCarryDisbursementDetail>(<any>null);
    }

    /**
     * @return Success
     */
    health(): Observable<HealthDto> {
        let url_ = this.baseUrl + "/api/Health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHealth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHealth(<any>response_);
                } catch (e) {
                    return <Observable<HealthDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HealthDto>><any>_observableThrow(response_);
        }));
    }

    protected processHealth(response: HttpResponseBase): Observable<HealthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthDto>(<any>null);
    }

    /**
     * @return Success
     */
    getProductsByInventory(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/Product/GetProductsByInventory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByInventory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByInventory(<any>response_);
                } catch (e) {
                    return <Observable<Product[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductsByInventory(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Product.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(<any>null);
    }

    /**
     * @return Success
     */
    getProductsIncludingDtpOrders(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/Product/GetProductsIncludingDtpOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsIncludingDtpOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsIncludingDtpOrders(<any>response_);
                } catch (e) {
                    return <Observable<Product[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductsIncludingDtpOrders(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Product.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    getRelatedDtrOrdersByProductId(productId: string | null | undefined): Observable<DtrOrder[]> {
        let url_ = this.baseUrl + "/api/Product/GetRelatedDtrOrdersByProductId?";
        if (productId !== undefined && productId !== null)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedDtrOrdersByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedDtrOrdersByProductId(<any>response_);
                } catch (e) {
                    return <Observable<DtrOrder[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DtrOrder[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRelatedDtrOrdersByProductId(response: HttpResponseBase): Observable<DtrOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DtrOrder.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DtrOrder[]>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    getRelatedHandCarryTransactionsByProductId(productId: string | null | undefined): Observable<HandCarryTransactionSummaryDto[]> {
        let url_ = this.baseUrl + "/api/Product/GetRelatedHandCarryTransactionsByProductId?";
        if (productId !== undefined && productId !== null)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedHandCarryTransactionsByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedHandCarryTransactionsByProductId(<any>response_);
                } catch (e) {
                    return <Observable<HandCarryTransactionSummaryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandCarryTransactionSummaryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRelatedHandCarryTransactionsByProductId(response: HttpResponseBase): Observable<HandCarryTransactionSummaryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HandCarryTransactionSummaryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandCarryTransactionSummaryDto[]>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    getRelatedDtpOrdersByProductId(productId: string | null | undefined): Observable<DtpOrder[]> {
        let url_ = this.baseUrl + "/api/Product/GetRelatedDtpOrdersByProductId?";
        if (productId !== undefined && productId !== null)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedDtpOrdersByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedDtpOrdersByProductId(<any>response_);
                } catch (e) {
                    return <Observable<DtpOrder[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DtpOrder[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRelatedDtpOrdersByProductId(response: HttpResponseBase): Observable<DtpOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DtpOrder.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DtpOrder[]>(<any>null);
    }

    /**
     * @param culture (optional) 
     * @return Success
     */
    getDefaultProgram(culture: string | null | undefined): Observable<TenantInfoDto> {
        let url_ = this.baseUrl + "/api/Program/GetDefaultProgram?";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultProgram(<any>response_);
                } catch (e) {
                    return <Observable<TenantInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultProgram(response: HttpResponseBase): Observable<TenantInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantInfoDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRepsIncludingPushShipments(): Observable<Rep[]> {
        let url_ = this.baseUrl + "/api/Rep/GetRepsIncludingPushShipments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepsIncludingPushShipments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepsIncludingPushShipments(<any>response_);
                } catch (e) {
                    return <Observable<Rep[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Rep[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepsIncludingPushShipments(response: HttpResponseBase): Observable<Rep[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Rep.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Rep[]>(<any>null);
    }

    /**
     * @return Success
     */
    getRepsIncludingDtpOrders(): Observable<Rep[]> {
        let url_ = this.baseUrl + "/api/Rep/GetRepsIncludingDtpOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepsIncludingDtpOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepsIncludingDtpOrders(<any>response_);
                } catch (e) {
                    return <Observable<Rep[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Rep[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepsIncludingDtpOrders(response: HttpResponseBase): Observable<Rep[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Rep.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Rep[]>(<any>null);
    }

    /**
     * @param repId (optional) 
     * @return Success
     */
    getDtrOrdersByRepId(repId: string | null | undefined): Observable<DtrOrder[]> {
        let url_ = this.baseUrl + "/api/Rep/GetDtrOrdersByRepId?";
        if (repId !== undefined && repId !== null)
            url_ += "RepId=" + encodeURIComponent("" + repId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDtrOrdersByRepId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDtrOrdersByRepId(<any>response_);
                } catch (e) {
                    return <Observable<DtrOrder[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DtrOrder[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDtrOrdersByRepId(response: HttpResponseBase): Observable<DtrOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DtrOrder.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DtrOrder[]>(<any>null);
    }

    /**
     * @param repId (optional) 
     * @return Success
     */
    getRepTerritoryHistory(repId: string | null | undefined): Observable<RepTerritory[]> {
        let url_ = this.baseUrl + "/api/Rep/GetRepTerritoryHistory?";
        if (repId !== undefined && repId !== null)
            url_ += "RepId=" + encodeURIComponent("" + repId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepTerritoryHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepTerritoryHistory(<any>response_);
                } catch (e) {
                    return <Observable<RepTerritory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepTerritory[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepTerritoryHistory(response: HttpResponseBase): Observable<RepTerritory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepTerritory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepTerritory[]>(<any>null);
    }

    /**
     * @param repId (optional) 
     * @return Success
     */
    getHandCarryTransactionsByRep(repId: string | null | undefined): Observable<HandCarryTransactionSummaryDto[]> {
        let url_ = this.baseUrl + "/api/Rep/GetHandCarryTransactionsByRep?";
        if (repId !== undefined && repId !== null)
            url_ += "RepId=" + encodeURIComponent("" + repId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHandCarryTransactionsByRep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHandCarryTransactionsByRep(<any>response_);
                } catch (e) {
                    return <Observable<HandCarryTransactionSummaryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandCarryTransactionSummaryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHandCarryTransactionsByRep(response: HttpResponseBase): Observable<HandCarryTransactionSummaryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HandCarryTransactionSummaryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandCarryTransactionSummaryDto[]>(<any>null);
    }

    /**
     * @param repId (optional) 
     * @return Success
     */
    getHandCarryInventoriesByRep(repId: string | null | undefined): Observable<HandCarryInventory[]> {
        let url_ = this.baseUrl + "/api/Rep/GetHandCarryInventoriesByRep?";
        if (repId !== undefined && repId !== null)
            url_ += "RepId=" + encodeURIComponent("" + repId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHandCarryInventoriesByRep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHandCarryInventoriesByRep(<any>response_);
                } catch (e) {
                    return <Observable<HandCarryInventory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandCarryInventory[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHandCarryInventoriesByRep(response: HttpResponseBase): Observable<HandCarryInventory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HandCarryInventory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandCarryInventory[]>(<any>null);
    }

    /**
     * @param repId (optional) 
     * @return Success
     */
    getHandCarrySignatureAuditsByRep(repId: string | null | undefined): Observable<HandCarrySignatureAudit[]> {
        let url_ = this.baseUrl + "/api/Rep/GetHandCarrySignatureAuditsByRep?";
        if (repId !== undefined && repId !== null)
            url_ += "RepId=" + encodeURIComponent("" + repId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHandCarrySignatureAuditsByRep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHandCarrySignatureAuditsByRep(<any>response_);
                } catch (e) {
                    return <Observable<HandCarrySignatureAudit[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandCarrySignatureAudit[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHandCarrySignatureAuditsByRep(response: HttpResponseBase): Observable<HandCarrySignatureAudit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HandCarrySignatureAudit.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandCarrySignatureAudit[]>(<any>null);
    }

    /**
     * @param repId (optional) 
     * @return Success
     */
    getHandCarryReconciliationsByRep(repId: string | null | undefined): Observable<HandCarryReconciliation[]> {
        let url_ = this.baseUrl + "/api/Rep/GetHandCarryReconciliationsByRep?";
        if (repId !== undefined && repId !== null)
            url_ += "RepId=" + encodeURIComponent("" + repId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHandCarryReconciliationsByRep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHandCarryReconciliationsByRep(<any>response_);
                } catch (e) {
                    return <Observable<HandCarryReconciliation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandCarryReconciliation[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHandCarryReconciliationsByRep(response: HttpResponseBase): Observable<HandCarryReconciliation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HandCarryReconciliation.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandCarryReconciliation[]>(<any>null);
    }

    /**
     * @return Success
     */
    getRepSignatureAudits(): Observable<RepSignatureAudit[]> {
        let url_ = this.baseUrl + "/api/Rep/GetRepSignatureAudits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepSignatureAudits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepSignatureAudits(<any>response_);
                } catch (e) {
                    return <Observable<RepSignatureAudit[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepSignatureAudit[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepSignatureAudits(response: HttpResponseBase): Observable<RepSignatureAudit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepSignatureAudit.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepSignatureAudit[]>(<any>null);
    }

    /**
     * @return Success
     */
    getReconciliations(): Observable<Reconciliation[]> {
        let url_ = this.baseUrl + "/api/Rep/GetReconciliations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReconciliations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReconciliations(<any>response_);
                } catch (e) {
                    return <Observable<Reconciliation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Reconciliation[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReconciliations(response: HttpResponseBase): Observable<Reconciliation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Reconciliation.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Reconciliation[]>(<any>null);
    }

    /**
     * @return Success
     */
    getReportDefinitions(): Observable<ReportDefinition[]> {
        let url_ = this.baseUrl + "/api/Report/GetReportDefinitions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportDefinitions(<any>response_);
                } catch (e) {
                    return <Observable<ReportDefinition[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportDefinition[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportDefinitions(response: HttpResponseBase): Observable<ReportDefinition[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReportDefinition.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportDefinition[]>(<any>null);
    }

    /**
     * @return Success
     */
    getGeneratedReports(): Observable<Report[]> {
        let url_ = this.baseUrl + "/api/Report/GetGeneratedReports";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneratedReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneratedReports(<any>response_);
                } catch (e) {
                    return <Observable<Report[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Report[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneratedReports(response: HttpResponseBase): Observable<Report[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Report.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Report[]>(<any>null);
    }

    /**
     * @return Success
     */
    getInventoryShippedByItemReportData(): Observable<InventoryShippedByItemReportDto[]> {
        let url_ = this.baseUrl + "/api/Report/GetInventoryShippedByItemReportData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInventoryShippedByItemReportData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInventoryShippedByItemReportData(<any>response_);
                } catch (e) {
                    return <Observable<InventoryShippedByItemReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InventoryShippedByItemReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInventoryShippedByItemReportData(response: HttpResponseBase): Observable<InventoryShippedByItemReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InventoryShippedByItemReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryShippedByItemReportDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPendingAocs(): Observable<AocReportDto[]> {
        let url_ = this.baseUrl + "/api/Report/GetPendingAocs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingAocs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingAocs(<any>response_);
                } catch (e) {
                    return <Observable<AocReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AocReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPendingAocs(response: HttpResponseBase): Observable<AocReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AocReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AocReportDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStates(): Observable<State[]> {
        let url_ = this.baseUrl + "/api/State/GetStates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStates(<any>response_);
                } catch (e) {
                    return <Observable<State[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<State[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStates(response: HttpResponseBase): Observable<State[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(State.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<State[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getTasks(userId: string | null | undefined): Observable<Task[]> {
        let url_ = this.baseUrl + "/api/Task/GetTasks?";
        if (userId !== undefined && userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTasks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTasks(<any>response_);
                } catch (e) {
                    return <Observable<Task[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Task[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTasks(response: HttpResponseBase): Observable<Task[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Task.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Task[]>(<any>null);
    }

    /**
     * @param taskId (optional) 
     * @return Success
     */
    getTask(taskId: string | null | undefined): Observable<Task> {
        let url_ = this.baseUrl + "/api/Task/GetTask?";
        if (taskId !== undefined && taskId !== null)
            url_ += "TaskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTask(<any>response_);
                } catch (e) {
                    return <Observable<Task>><any>_observableThrow(e);
                }
            } else
                return <Observable<Task>><any>_observableThrow(response_);
        }));
    }

    protected processGetTask(response: HttpResponseBase): Observable<Task> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Task>(<any>null);
    }

    /**
     * @param email (optional) 
     * @param passsword (optional) 
     * @return Success
     */
    signIn(email: string | null | undefined, passsword: string | null | undefined): Observable<User> {
        let url_ = this.baseUrl + "/api/User/SignIn?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (passsword !== undefined && passsword !== null)
            url_ += "passsword=" + encodeURIComponent("" + passsword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignIn(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processSignIn(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * @return Success
     */
    getUsers(): Observable<User[]> {
        let url_ = this.baseUrl + "/api/User/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<User[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<User[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(<any>null);
    }
}

export class Address implements IAddress {
    id?: string | undefined;
    tenantId?: number;
    userId?: string | undefined;
    status?: string | undefined;
    institutionAddress?: boolean;
    badAddressFlag?: boolean;
    addressType?: string | undefined;
    statAddressSourceus?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zipCode?: string | undefined;
    dtpFlag?: boolean;
    dtrFlag?: boolean;
    handCarryFlag?: boolean;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.status = _data["status"];
            this.institutionAddress = _data["institutionAddress"];
            this.badAddressFlag = _data["badAddressFlag"];
            this.addressType = _data["addressType"];
            this.statAddressSourceus = _data["statAddressSourceus"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.zipCode = _data["zipCode"];
            this.dtpFlag = _data["dtpFlag"];
            this.dtrFlag = _data["dtrFlag"];
            this.handCarryFlag = _data["handCarryFlag"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["status"] = this.status;
        data["institutionAddress"] = this.institutionAddress;
        data["badAddressFlag"] = this.badAddressFlag;
        data["addressType"] = this.addressType;
        data["statAddressSourceus"] = this.statAddressSourceus;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zipCode"] = this.zipCode;
        data["dtpFlag"] = this.dtpFlag;
        data["dtrFlag"] = this.dtrFlag;
        data["handCarryFlag"] = this.handCarryFlag;
        return data; 
    }

    clone(): Address {
        const json = this.toJSON();
        let result = new Address();
        result.init(json);
        return result;
    }
}

export interface IAddress {
    id?: string | undefined;
    tenantId?: number;
    userId?: string | undefined;
    status?: string | undefined;
    institutionAddress?: boolean;
    badAddressFlag?: boolean;
    addressType?: string | undefined;
    statAddressSourceus?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zipCode?: string | undefined;
    dtpFlag?: boolean;
    dtrFlag?: boolean;
    handCarryFlag?: boolean;
}

export class Announcement implements IAnnouncement {
    id?: number;
    tenantId?: number;
    title?: string | undefined;
    description?: string | undefined;
    attachmentLink?: string | undefined;
    publishedOn?: Date;
    isActive?: boolean;

    constructor(data?: IAnnouncement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.attachmentLink = _data["attachmentLink"];
            this.publishedOn = _data["publishedOn"] ? new Date(_data["publishedOn"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): Announcement {
        data = typeof data === 'object' ? data : {};
        let result = new Announcement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["attachmentLink"] = this.attachmentLink;
        data["publishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): Announcement {
        const json = this.toJSON();
        let result = new Announcement();
        result.init(json);
        return result;
    }
}

export interface IAnnouncement {
    id?: number;
    tenantId?: number;
    title?: string | undefined;
    description?: string | undefined;
    attachmentLink?: string | undefined;
    publishedOn?: Date;
    isActive?: boolean;
}

export class ClassificationValue implements IClassificationValue {
    id?: string;
    classificationTypeId?: string;
    classificationTypeCode?: string | undefined;
    classificationValueCode?: string | undefined;
    classificationValueName?: string | undefined;
    readOnlyFlag?: boolean;
    commentsText?: string | undefined;
    priorityNbr?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IClassificationValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.classificationTypeId = _data["classificationTypeId"];
            this.classificationTypeCode = _data["classificationTypeCode"];
            this.classificationValueCode = _data["classificationValueCode"];
            this.classificationValueName = _data["classificationValueName"];
            this.readOnlyFlag = _data["readOnlyFlag"];
            this.commentsText = _data["commentsText"];
            this.priorityNbr = _data["priorityNbr"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ClassificationValue {
        data = typeof data === 'object' ? data : {};
        let result = new ClassificationValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["classificationTypeId"] = this.classificationTypeId;
        data["classificationTypeCode"] = this.classificationTypeCode;
        data["classificationValueCode"] = this.classificationValueCode;
        data["classificationValueName"] = this.classificationValueName;
        data["readOnlyFlag"] = this.readOnlyFlag;
        data["commentsText"] = this.commentsText;
        data["priorityNbr"] = this.priorityNbr;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ClassificationValue {
        const json = this.toJSON();
        let result = new ClassificationValue();
        result.init(json);
        return result;
    }
}

export interface IClassificationValue {
    id?: string;
    classificationTypeId?: string;
    classificationTypeCode?: string | undefined;
    classificationValueCode?: string | undefined;
    classificationValueName?: string | undefined;
    readOnlyFlag?: boolean;
    commentsText?: string | undefined;
    priorityNbr?: string | undefined;
    isActive?: boolean | undefined;
}

export class ClassificationType implements IClassificationType {
    id?: string;
    classificationTypeCode?: string | undefined;
    classificationTypeName?: string | undefined;

    constructor(data?: IClassificationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.classificationTypeCode = _data["classificationTypeCode"];
            this.classificationTypeName = _data["classificationTypeName"];
        }
    }

    static fromJS(data: any): ClassificationType {
        data = typeof data === 'object' ? data : {};
        let result = new ClassificationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["classificationTypeCode"] = this.classificationTypeCode;
        data["classificationTypeName"] = this.classificationTypeName;
        return data; 
    }

    clone(): ClassificationType {
        const json = this.toJSON();
        let result = new ClassificationType();
        result.init(json);
        return result;
    }
}

export interface IClassificationType {
    id?: string;
    classificationTypeCode?: string | undefined;
    classificationTypeName?: string | undefined;
}

export class Country implements ICountry {
    id?: string | undefined;
    countryName?: string | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryName"] = this.countryName;
        return data; 
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    id?: string | undefined;
    countryName?: string | undefined;
}

export class Dataset implements IDataset {
    data?: number[] | undefined;
    label?: string | undefined;

    constructor(data?: IDataset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): Dataset {
        data = typeof data === 'object' ? data : {};
        let result = new Dataset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["label"] = this.label;
        return data; 
    }

    clone(): Dataset {
        const json = this.toJSON();
        let result = new Dataset();
        result.init(json);
        return result;
    }
}

export interface IDataset {
    data?: number[] | undefined;
    label?: string | undefined;
}

export class ChartDataDto implements IChartDataDto {
    labels?: string[] | undefined;
    datasets?: Dataset[] | undefined;

    constructor(data?: IChartDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (Array.isArray(_data["datasets"])) {
                this.datasets = [] as any;
                for (let item of _data["datasets"])
                    this.datasets!.push(Dataset.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChartDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.datasets)) {
            data["datasets"] = [];
            for (let item of this.datasets)
                data["datasets"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ChartDataDto {
        const json = this.toJSON();
        let result = new ChartDataDto();
        result.init(json);
        return result;
    }
}

export interface IChartDataDto {
    labels?: string[] | undefined;
    datasets?: Dataset[] | undefined;
}

export class ChartDataResponseDto implements IChartDataResponseDto {
    data?: ChartDataDto;

    constructor(data?: IChartDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ChartDataDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChartDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ChartDataResponseDto {
        const json = this.toJSON();
        let result = new ChartDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IChartDataResponseDto {
    data?: ChartDataDto;
}

export class OrderMetricPeriod implements IOrderMetricPeriod {
    quantity?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;

    constructor(data?: IOrderMetricPeriod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderMetricPeriod {
        data = typeof data === 'object' ? data : {};
        let result = new OrderMetricPeriod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): OrderMetricPeriod {
        const json = this.toJSON();
        let result = new OrderMetricPeriod();
        result.init(json);
        return result;
    }
}

export interface IOrderMetricPeriod {
    quantity?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
}

export class OrderMetric implements IOrderMetric {
    orderStatus?: string | undefined;
    currentPeriod?: OrderMetricPeriod;
    previousPeriod?: OrderMetricPeriod;

    constructor(data?: IOrderMetric) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderStatus = _data["orderStatus"];
            this.currentPeriod = _data["currentPeriod"] ? OrderMetricPeriod.fromJS(_data["currentPeriod"]) : <any>undefined;
            this.previousPeriod = _data["previousPeriod"] ? OrderMetricPeriod.fromJS(_data["previousPeriod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderMetric {
        data = typeof data === 'object' ? data : {};
        let result = new OrderMetric();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderStatus"] = this.orderStatus;
        data["currentPeriod"] = this.currentPeriod ? this.currentPeriod.toJSON() : <any>undefined;
        data["previousPeriod"] = this.previousPeriod ? this.previousPeriod.toJSON() : <any>undefined;
        return data; 
    }

    clone(): OrderMetric {
        const json = this.toJSON();
        let result = new OrderMetric();
        result.init(json);
        return result;
    }
}

export interface IOrderMetric {
    orderStatus?: string | undefined;
    currentPeriod?: OrderMetricPeriod;
    previousPeriod?: OrderMetricPeriod;
}

export class OrderMetricsDto implements IOrderMetricsDto {
    periodType?: string | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    metrics?: OrderMetric[] | undefined;

    constructor(data?: IOrderMetricsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.periodType = _data["periodType"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["metrics"])) {
                this.metrics = [] as any;
                for (let item of _data["metrics"])
                    this.metrics!.push(OrderMetric.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderMetricsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderMetricsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["periodType"] = this.periodType;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.metrics)) {
            data["metrics"] = [];
            for (let item of this.metrics)
                data["metrics"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OrderMetricsDto {
        const json = this.toJSON();
        let result = new OrderMetricsDto();
        result.init(json);
        return result;
    }
}

export interface IOrderMetricsDto {
    periodType?: string | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    metrics?: OrderMetric[] | undefined;
}

export class OrderLineItemDto implements IOrderLineItemDto {
    orderId?: string | undefined;
    productId?: string | undefined;
    status?: string | undefined;
    orderQty?: number;
    adjustedOrderQty?: number | undefined;
    shippedQty?: number | undefined;
    deliveredQty?: number | undefined;
    adjustedDeliveredQty?: number | undefined;
    returnedQty?: number | undefined;
    productName?: string | undefined;
    productCode?: string | undefined;
    productDescription?: string | undefined;
    productUom?: string | undefined;
    productImagePath?: string | undefined;
    orderReceivedDate?: Date;

    constructor(data?: IOrderLineItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.productId = _data["productId"];
            this.status = _data["status"];
            this.orderQty = _data["orderQty"];
            this.adjustedOrderQty = _data["adjustedOrderQty"];
            this.shippedQty = _data["shippedQty"];
            this.deliveredQty = _data["deliveredQty"];
            this.adjustedDeliveredQty = _data["adjustedDeliveredQty"];
            this.returnedQty = _data["returnedQty"];
            this.productName = _data["productName"];
            this.productCode = _data["productCode"];
            this.productDescription = _data["productDescription"];
            this.productUom = _data["productUom"];
            this.productImagePath = _data["productImagePath"];
            this.orderReceivedDate = _data["orderReceivedDate"] ? new Date(_data["orderReceivedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderLineItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderLineItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["productId"] = this.productId;
        data["status"] = this.status;
        data["orderQty"] = this.orderQty;
        data["adjustedOrderQty"] = this.adjustedOrderQty;
        data["shippedQty"] = this.shippedQty;
        data["deliveredQty"] = this.deliveredQty;
        data["adjustedDeliveredQty"] = this.adjustedDeliveredQty;
        data["returnedQty"] = this.returnedQty;
        data["productName"] = this.productName;
        data["productCode"] = this.productCode;
        data["productDescription"] = this.productDescription;
        data["productUom"] = this.productUom;
        data["productImagePath"] = this.productImagePath;
        data["orderReceivedDate"] = this.orderReceivedDate ? this.orderReceivedDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): OrderLineItemDto {
        const json = this.toJSON();
        let result = new OrderLineItemDto();
        result.init(json);
        return result;
    }
}

export interface IOrderLineItemDto {
    orderId?: string | undefined;
    productId?: string | undefined;
    status?: string | undefined;
    orderQty?: number;
    adjustedOrderQty?: number | undefined;
    shippedQty?: number | undefined;
    deliveredQty?: number | undefined;
    adjustedDeliveredQty?: number | undefined;
    returnedQty?: number | undefined;
    productName?: string | undefined;
    productCode?: string | undefined;
    productDescription?: string | undefined;
    productUom?: string | undefined;
    productImagePath?: string | undefined;
    orderReceivedDate?: Date;
}

export class DtpOrderDto implements IDtpOrderDto {
    id?: string | undefined;
    orderNumber?: string | undefined;
    status?: string | undefined;
    orderDate?: string | undefined;
    orderReceivedDate?: string | undefined;
    orderType?: string | undefined;
    orderSource?: string | undefined;
    orderedByFirstName?: string | undefined;
    orderedByLastName?: string | undefined;
    orderedByAddressLine1?: string | undefined;
    orderedByAddressLine2?: string | undefined;
    orderedByCity?: string | undefined;
    orderedByState?: string | undefined;
    orderedByZipCode?: string | undefined;
    orderedByCountry?: string | undefined;
    orderedByPhoneNumber?: string | undefined;
    shipToFirstName?: string | undefined;
    shipToLastName?: string | undefined;
    shipToAddressLine1?: string | undefined;
    shipToAddressLine2?: string | undefined;
    shipToCity?: string | undefined;
    shipToState?: string | undefined;
    shipToZipCode?: string | undefined;
    shipToCountry?: string | undefined;
    shipToPhoneNumber?: string | undefined;
    repId?: string | undefined;
    hcpId?: string | undefined;
    externalOrderNumber?: string | undefined;
    parentOrder?: string | undefined;
    jobId?: string | undefined;
    programName?: string | undefined;
    relatedOfferId?: string | undefined;
    formId?: string | undefined;
    batchNumber?: string | undefined;
    batchDate?: string | undefined;
    orderLifeCycleStage?: string | undefined;
    modifiedByUsername?: string | undefined;
    modifiedByTime?: string | undefined;
    lifeCycleStatus?: number;
    orderLineItems?: OrderLineItemDto[] | undefined;

    constructor(data?: IDtpOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.status = _data["status"];
            this.orderDate = _data["orderDate"];
            this.orderReceivedDate = _data["orderReceivedDate"];
            this.orderType = _data["orderType"];
            this.orderSource = _data["orderSource"];
            this.orderedByFirstName = _data["orderedByFirstName"];
            this.orderedByLastName = _data["orderedByLastName"];
            this.orderedByAddressLine1 = _data["orderedByAddressLine1"];
            this.orderedByAddressLine2 = _data["orderedByAddressLine2"];
            this.orderedByCity = _data["orderedByCity"];
            this.orderedByState = _data["orderedByState"];
            this.orderedByZipCode = _data["orderedByZipCode"];
            this.orderedByCountry = _data["orderedByCountry"];
            this.orderedByPhoneNumber = _data["orderedByPhoneNumber"];
            this.shipToFirstName = _data["shipToFirstName"];
            this.shipToLastName = _data["shipToLastName"];
            this.shipToAddressLine1 = _data["shipToAddressLine1"];
            this.shipToAddressLine2 = _data["shipToAddressLine2"];
            this.shipToCity = _data["shipToCity"];
            this.shipToState = _data["shipToState"];
            this.shipToZipCode = _data["shipToZipCode"];
            this.shipToCountry = _data["shipToCountry"];
            this.shipToPhoneNumber = _data["shipToPhoneNumber"];
            this.repId = _data["repId"];
            this.hcpId = _data["hcpId"];
            this.externalOrderNumber = _data["externalOrderNumber"];
            this.parentOrder = _data["parentOrder"];
            this.jobId = _data["jobId"];
            this.programName = _data["programName"];
            this.relatedOfferId = _data["relatedOfferId"];
            this.formId = _data["formId"];
            this.batchNumber = _data["batchNumber"];
            this.batchDate = _data["batchDate"];
            this.orderLifeCycleStage = _data["orderLifeCycleStage"];
            this.modifiedByUsername = _data["modifiedByUsername"];
            this.modifiedByTime = _data["modifiedByTime"];
            this.lifeCycleStatus = _data["lifeCycleStatus"];
            if (Array.isArray(_data["orderLineItems"])) {
                this.orderLineItems = [] as any;
                for (let item of _data["orderLineItems"])
                    this.orderLineItems!.push(OrderLineItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DtpOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new DtpOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["status"] = this.status;
        data["orderDate"] = this.orderDate;
        data["orderReceivedDate"] = this.orderReceivedDate;
        data["orderType"] = this.orderType;
        data["orderSource"] = this.orderSource;
        data["orderedByFirstName"] = this.orderedByFirstName;
        data["orderedByLastName"] = this.orderedByLastName;
        data["orderedByAddressLine1"] = this.orderedByAddressLine1;
        data["orderedByAddressLine2"] = this.orderedByAddressLine2;
        data["orderedByCity"] = this.orderedByCity;
        data["orderedByState"] = this.orderedByState;
        data["orderedByZipCode"] = this.orderedByZipCode;
        data["orderedByCountry"] = this.orderedByCountry;
        data["orderedByPhoneNumber"] = this.orderedByPhoneNumber;
        data["shipToFirstName"] = this.shipToFirstName;
        data["shipToLastName"] = this.shipToLastName;
        data["shipToAddressLine1"] = this.shipToAddressLine1;
        data["shipToAddressLine2"] = this.shipToAddressLine2;
        data["shipToCity"] = this.shipToCity;
        data["shipToState"] = this.shipToState;
        data["shipToZipCode"] = this.shipToZipCode;
        data["shipToCountry"] = this.shipToCountry;
        data["shipToPhoneNumber"] = this.shipToPhoneNumber;
        data["repId"] = this.repId;
        data["hcpId"] = this.hcpId;
        data["externalOrderNumber"] = this.externalOrderNumber;
        data["parentOrder"] = this.parentOrder;
        data["jobId"] = this.jobId;
        data["programName"] = this.programName;
        data["relatedOfferId"] = this.relatedOfferId;
        data["formId"] = this.formId;
        data["batchNumber"] = this.batchNumber;
        data["batchDate"] = this.batchDate;
        data["orderLifeCycleStage"] = this.orderLifeCycleStage;
        data["modifiedByUsername"] = this.modifiedByUsername;
        data["modifiedByTime"] = this.modifiedByTime;
        data["lifeCycleStatus"] = this.lifeCycleStatus;
        if (Array.isArray(this.orderLineItems)) {
            data["orderLineItems"] = [];
            for (let item of this.orderLineItems)
                data["orderLineItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DtpOrderDto {
        const json = this.toJSON();
        let result = new DtpOrderDto();
        result.init(json);
        return result;
    }
}

export interface IDtpOrderDto {
    id?: string | undefined;
    orderNumber?: string | undefined;
    status?: string | undefined;
    orderDate?: string | undefined;
    orderReceivedDate?: string | undefined;
    orderType?: string | undefined;
    orderSource?: string | undefined;
    orderedByFirstName?: string | undefined;
    orderedByLastName?: string | undefined;
    orderedByAddressLine1?: string | undefined;
    orderedByAddressLine2?: string | undefined;
    orderedByCity?: string | undefined;
    orderedByState?: string | undefined;
    orderedByZipCode?: string | undefined;
    orderedByCountry?: string | undefined;
    orderedByPhoneNumber?: string | undefined;
    shipToFirstName?: string | undefined;
    shipToLastName?: string | undefined;
    shipToAddressLine1?: string | undefined;
    shipToAddressLine2?: string | undefined;
    shipToCity?: string | undefined;
    shipToState?: string | undefined;
    shipToZipCode?: string | undefined;
    shipToCountry?: string | undefined;
    shipToPhoneNumber?: string | undefined;
    repId?: string | undefined;
    hcpId?: string | undefined;
    externalOrderNumber?: string | undefined;
    parentOrder?: string | undefined;
    jobId?: string | undefined;
    programName?: string | undefined;
    relatedOfferId?: string | undefined;
    formId?: string | undefined;
    batchNumber?: string | undefined;
    batchDate?: string | undefined;
    orderLifeCycleStage?: string | undefined;
    modifiedByUsername?: string | undefined;
    modifiedByTime?: string | undefined;
    lifeCycleStatus?: number;
    orderLineItems?: OrderLineItemDto[] | undefined;
}

export class DtrOrderDto implements IDtrOrderDto {
    id?: string | undefined;
    orderNumber?: string | undefined;
    status?: string | undefined;
    orderDate?: string | undefined;
    orderReceivedDate?: string | undefined;
    orderType?: string | undefined;
    orderSource?: string | undefined;
    orderedByFirstName?: string | undefined;
    orderedByLastName?: string | undefined;
    orderedByAddressLine1?: string | undefined;
    orderedByAddressLine2?: string | undefined;
    orderedByCity?: string | undefined;
    orderedByState?: string | undefined;
    orderedByZipCode?: string | undefined;
    orderedByCountry?: string | undefined;
    orderedByPhoneNumber?: string | undefined;
    shipToFirstName?: string | undefined;
    shipToLastName?: string | undefined;
    shipToAddressLine1?: string | undefined;
    shipToAddressLine2?: string | undefined;
    shipToCity?: string | undefined;
    shipToState?: string | undefined;
    shipToZipCode?: string | undefined;
    shipToCountry?: string | undefined;
    shipToPhoneNumber?: string | undefined;
    repId?: string | undefined;
    hcpId?: string | undefined;
    rushFlag?: boolean;
    shipmentCarrier?: string | undefined;
    shipmentCarrierService?: string | undefined;
    externalOrderNumber?: string | undefined;
    parentOrder?: string | undefined;
    jobId?: string | undefined;
    programName?: string | undefined;
    relatedOfferId?: string | undefined;
    formId?: string | undefined;
    batchNumber?: string | undefined;
    batchDate?: string | undefined;
    orderLineItems?: OrderLineItemDto[] | undefined;

    constructor(data?: IDtrOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.status = _data["status"];
            this.orderDate = _data["orderDate"];
            this.orderReceivedDate = _data["orderReceivedDate"];
            this.orderType = _data["orderType"];
            this.orderSource = _data["orderSource"];
            this.orderedByFirstName = _data["orderedByFirstName"];
            this.orderedByLastName = _data["orderedByLastName"];
            this.orderedByAddressLine1 = _data["orderedByAddressLine1"];
            this.orderedByAddressLine2 = _data["orderedByAddressLine2"];
            this.orderedByCity = _data["orderedByCity"];
            this.orderedByState = _data["orderedByState"];
            this.orderedByZipCode = _data["orderedByZipCode"];
            this.orderedByCountry = _data["orderedByCountry"];
            this.orderedByPhoneNumber = _data["orderedByPhoneNumber"];
            this.shipToFirstName = _data["shipToFirstName"];
            this.shipToLastName = _data["shipToLastName"];
            this.shipToAddressLine1 = _data["shipToAddressLine1"];
            this.shipToAddressLine2 = _data["shipToAddressLine2"];
            this.shipToCity = _data["shipToCity"];
            this.shipToState = _data["shipToState"];
            this.shipToZipCode = _data["shipToZipCode"];
            this.shipToCountry = _data["shipToCountry"];
            this.shipToPhoneNumber = _data["shipToPhoneNumber"];
            this.repId = _data["repId"];
            this.hcpId = _data["hcpId"];
            this.rushFlag = _data["rushFlag"];
            this.shipmentCarrier = _data["shipmentCarrier"];
            this.shipmentCarrierService = _data["shipmentCarrierService"];
            this.externalOrderNumber = _data["externalOrderNumber"];
            this.parentOrder = _data["parentOrder"];
            this.jobId = _data["jobId"];
            this.programName = _data["programName"];
            this.relatedOfferId = _data["relatedOfferId"];
            this.formId = _data["formId"];
            this.batchNumber = _data["batchNumber"];
            this.batchDate = _data["batchDate"];
            if (Array.isArray(_data["orderLineItems"])) {
                this.orderLineItems = [] as any;
                for (let item of _data["orderLineItems"])
                    this.orderLineItems!.push(OrderLineItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DtrOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new DtrOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["status"] = this.status;
        data["orderDate"] = this.orderDate;
        data["orderReceivedDate"] = this.orderReceivedDate;
        data["orderType"] = this.orderType;
        data["orderSource"] = this.orderSource;
        data["orderedByFirstName"] = this.orderedByFirstName;
        data["orderedByLastName"] = this.orderedByLastName;
        data["orderedByAddressLine1"] = this.orderedByAddressLine1;
        data["orderedByAddressLine2"] = this.orderedByAddressLine2;
        data["orderedByCity"] = this.orderedByCity;
        data["orderedByState"] = this.orderedByState;
        data["orderedByZipCode"] = this.orderedByZipCode;
        data["orderedByCountry"] = this.orderedByCountry;
        data["orderedByPhoneNumber"] = this.orderedByPhoneNumber;
        data["shipToFirstName"] = this.shipToFirstName;
        data["shipToLastName"] = this.shipToLastName;
        data["shipToAddressLine1"] = this.shipToAddressLine1;
        data["shipToAddressLine2"] = this.shipToAddressLine2;
        data["shipToCity"] = this.shipToCity;
        data["shipToState"] = this.shipToState;
        data["shipToZipCode"] = this.shipToZipCode;
        data["shipToCountry"] = this.shipToCountry;
        data["shipToPhoneNumber"] = this.shipToPhoneNumber;
        data["repId"] = this.repId;
        data["hcpId"] = this.hcpId;
        data["rushFlag"] = this.rushFlag;
        data["shipmentCarrier"] = this.shipmentCarrier;
        data["shipmentCarrierService"] = this.shipmentCarrierService;
        data["externalOrderNumber"] = this.externalOrderNumber;
        data["parentOrder"] = this.parentOrder;
        data["jobId"] = this.jobId;
        data["programName"] = this.programName;
        data["relatedOfferId"] = this.relatedOfferId;
        data["formId"] = this.formId;
        data["batchNumber"] = this.batchNumber;
        data["batchDate"] = this.batchDate;
        if (Array.isArray(this.orderLineItems)) {
            data["orderLineItems"] = [];
            for (let item of this.orderLineItems)
                data["orderLineItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DtrOrderDto {
        const json = this.toJSON();
        let result = new DtrOrderDto();
        result.init(json);
        return result;
    }
}

export interface IDtrOrderDto {
    id?: string | undefined;
    orderNumber?: string | undefined;
    status?: string | undefined;
    orderDate?: string | undefined;
    orderReceivedDate?: string | undefined;
    orderType?: string | undefined;
    orderSource?: string | undefined;
    orderedByFirstName?: string | undefined;
    orderedByLastName?: string | undefined;
    orderedByAddressLine1?: string | undefined;
    orderedByAddressLine2?: string | undefined;
    orderedByCity?: string | undefined;
    orderedByState?: string | undefined;
    orderedByZipCode?: string | undefined;
    orderedByCountry?: string | undefined;
    orderedByPhoneNumber?: string | undefined;
    shipToFirstName?: string | undefined;
    shipToLastName?: string | undefined;
    shipToAddressLine1?: string | undefined;
    shipToAddressLine2?: string | undefined;
    shipToCity?: string | undefined;
    shipToState?: string | undefined;
    shipToZipCode?: string | undefined;
    shipToCountry?: string | undefined;
    shipToPhoneNumber?: string | undefined;
    repId?: string | undefined;
    hcpId?: string | undefined;
    rushFlag?: boolean;
    shipmentCarrier?: string | undefined;
    shipmentCarrierService?: string | undefined;
    externalOrderNumber?: string | undefined;
    parentOrder?: string | undefined;
    jobId?: string | undefined;
    programName?: string | undefined;
    relatedOfferId?: string | undefined;
    formId?: string | undefined;
    batchNumber?: string | undefined;
    batchDate?: string | undefined;
    orderLineItems?: OrderLineItemDto[] | undefined;
}

export class Lot implements ILot {
    id?: number;
    tenantId?: number;
    lotNumber?: string | undefined;
    productCode?: string | undefined;
    expirationDate?: Date | undefined;
    lastUseDate?: Date | undefined;
    status?: string | undefined;
    signalStatus?: string | undefined;
    availableQty?: number | undefined;
    markedQty?: number | undefined;
    unavailableQty?: number | undefined;

    constructor(data?: ILot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.lotNumber = _data["lotNumber"];
            this.productCode = _data["productCode"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.lastUseDate = _data["lastUseDate"] ? new Date(_data["lastUseDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.signalStatus = _data["signalStatus"];
            this.availableQty = _data["availableQty"];
            this.markedQty = _data["markedQty"];
            this.unavailableQty = _data["unavailableQty"];
        }
    }

    static fromJS(data: any): Lot {
        data = typeof data === 'object' ? data : {};
        let result = new Lot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["lotNumber"] = this.lotNumber;
        data["productCode"] = this.productCode;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["lastUseDate"] = this.lastUseDate ? this.lastUseDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["signalStatus"] = this.signalStatus;
        data["availableQty"] = this.availableQty;
        data["markedQty"] = this.markedQty;
        data["unavailableQty"] = this.unavailableQty;
        return data; 
    }

    clone(): Lot {
        const json = this.toJSON();
        let result = new Lot();
        result.init(json);
        return result;
    }
}

export interface ILot {
    id?: number;
    tenantId?: number;
    lotNumber?: string | undefined;
    productCode?: string | undefined;
    expirationDate?: Date | undefined;
    lastUseDate?: Date | undefined;
    status?: string | undefined;
    signalStatus?: string | undefined;
    availableQty?: number | undefined;
    markedQty?: number | undefined;
    unavailableQty?: number | undefined;
}

export class DtpOrder implements IDtpOrder {
    id?: string | undefined;
    orderNumber?: string | undefined;
    modifiedByUsername?: string | undefined;
    modifiedByTime?: string | undefined;
    status?: string | undefined;
    orderDate?: string | undefined;
    orderReceivedDate?: string | undefined;
    orderType?: string | undefined;
    orderedByFirstName?: string | undefined;
    orderedByLastName?: string | undefined;
    orderedByAddressLine1?: string | undefined;
    orderedByAddressLine2?: string | undefined;
    orderedByCity?: string | undefined;
    orderedByState?: string | undefined;
    orderedByZipCode?: string | undefined;
    orderedByCountry?: string | undefined;
    shipToFirstName?: string | undefined;
    shipToLastName?: string | undefined;
    shipToAddressLine1?: string | undefined;
    shipToAddressLine2?: string | undefined;
    shipToCity?: string | undefined;
    shipToState?: string | undefined;
    shipToZipCode?: string | undefined;
    shipToCountry?: string | undefined;
    shipmentCarrier?: string | undefined;
    shipmentCarrierService?: string | undefined;
    orderLines?: OrderLine[] | undefined;
    repId?: string | undefined;
    hcpId?: string | undefined;
    orderSource?: string | undefined;
    programId?: string | undefined;
    communicationLabel?: string | undefined;
    externalOrderNumber?: string | undefined;
    parentOrder?: string | undefined;
    jobId?: string | undefined;
    programName?: string | undefined;
    relatedOfferId?: string | undefined;
    formId?: string | undefined;
    batchNumber?: string | undefined;
    batchDate?: string | undefined;
    orderLifeCycleStage?: string | undefined;
    lifeCycleStatus?: number;
    repFirstName?: string | undefined;
    repLastName?: string | undefined;
    repTerritory?: string | undefined;

    constructor(data?: IDtpOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.modifiedByUsername = _data["modifiedByUsername"];
            this.modifiedByTime = _data["modifiedByTime"];
            this.status = _data["status"];
            this.orderDate = _data["orderDate"];
            this.orderReceivedDate = _data["orderReceivedDate"];
            this.orderType = _data["orderType"];
            this.orderedByFirstName = _data["orderedByFirstName"];
            this.orderedByLastName = _data["orderedByLastName"];
            this.orderedByAddressLine1 = _data["orderedByAddressLine1"];
            this.orderedByAddressLine2 = _data["orderedByAddressLine2"];
            this.orderedByCity = _data["orderedByCity"];
            this.orderedByState = _data["orderedByState"];
            this.orderedByZipCode = _data["orderedByZipCode"];
            this.orderedByCountry = _data["orderedByCountry"];
            this.shipToFirstName = _data["shipToFirstName"];
            this.shipToLastName = _data["shipToLastName"];
            this.shipToAddressLine1 = _data["shipToAddressLine1"];
            this.shipToAddressLine2 = _data["shipToAddressLine2"];
            this.shipToCity = _data["shipToCity"];
            this.shipToState = _data["shipToState"];
            this.shipToZipCode = _data["shipToZipCode"];
            this.shipToCountry = _data["shipToCountry"];
            this.shipmentCarrier = _data["shipmentCarrier"];
            this.shipmentCarrierService = _data["shipmentCarrierService"];
            if (Array.isArray(_data["orderLines"])) {
                this.orderLines = [] as any;
                for (let item of _data["orderLines"])
                    this.orderLines!.push(OrderLine.fromJS(item));
            }
            this.repId = _data["repId"];
            this.hcpId = _data["hcpId"];
            this.orderSource = _data["orderSource"];
            this.programId = _data["programId"];
            this.communicationLabel = _data["communicationLabel"];
            this.externalOrderNumber = _data["externalOrderNumber"];
            this.parentOrder = _data["parentOrder"];
            this.jobId = _data["jobId"];
            this.programName = _data["programName"];
            this.relatedOfferId = _data["relatedOfferId"];
            this.formId = _data["formId"];
            this.batchNumber = _data["batchNumber"];
            this.batchDate = _data["batchDate"];
            this.orderLifeCycleStage = _data["orderLifeCycleStage"];
            this.lifeCycleStatus = _data["lifeCycleStatus"];
            this.repFirstName = _data["repFirstName"];
            this.repLastName = _data["repLastName"];
            this.repTerritory = _data["repTerritory"];
        }
    }

    static fromJS(data: any): DtpOrder {
        data = typeof data === 'object' ? data : {};
        let result = new DtpOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["modifiedByUsername"] = this.modifiedByUsername;
        data["modifiedByTime"] = this.modifiedByTime;
        data["status"] = this.status;
        data["orderDate"] = this.orderDate;
        data["orderReceivedDate"] = this.orderReceivedDate;
        data["orderType"] = this.orderType;
        data["orderedByFirstName"] = this.orderedByFirstName;
        data["orderedByLastName"] = this.orderedByLastName;
        data["orderedByAddressLine1"] = this.orderedByAddressLine1;
        data["orderedByAddressLine2"] = this.orderedByAddressLine2;
        data["orderedByCity"] = this.orderedByCity;
        data["orderedByState"] = this.orderedByState;
        data["orderedByZipCode"] = this.orderedByZipCode;
        data["orderedByCountry"] = this.orderedByCountry;
        data["shipToFirstName"] = this.shipToFirstName;
        data["shipToLastName"] = this.shipToLastName;
        data["shipToAddressLine1"] = this.shipToAddressLine1;
        data["shipToAddressLine2"] = this.shipToAddressLine2;
        data["shipToCity"] = this.shipToCity;
        data["shipToState"] = this.shipToState;
        data["shipToZipCode"] = this.shipToZipCode;
        data["shipToCountry"] = this.shipToCountry;
        data["shipmentCarrier"] = this.shipmentCarrier;
        data["shipmentCarrierService"] = this.shipmentCarrierService;
        if (Array.isArray(this.orderLines)) {
            data["orderLines"] = [];
            for (let item of this.orderLines)
                data["orderLines"].push(item.toJSON());
        }
        data["repId"] = this.repId;
        data["hcpId"] = this.hcpId;
        data["orderSource"] = this.orderSource;
        data["programId"] = this.programId;
        data["communicationLabel"] = this.communicationLabel;
        data["externalOrderNumber"] = this.externalOrderNumber;
        data["parentOrder"] = this.parentOrder;
        data["jobId"] = this.jobId;
        data["programName"] = this.programName;
        data["relatedOfferId"] = this.relatedOfferId;
        data["formId"] = this.formId;
        data["batchNumber"] = this.batchNumber;
        data["batchDate"] = this.batchDate;
        data["orderLifeCycleStage"] = this.orderLifeCycleStage;
        data["lifeCycleStatus"] = this.lifeCycleStatus;
        data["repFirstName"] = this.repFirstName;
        data["repLastName"] = this.repLastName;
        data["repTerritory"] = this.repTerritory;
        return data; 
    }

    clone(): DtpOrder {
        const json = this.toJSON();
        let result = new DtpOrder();
        result.init(json);
        return result;
    }
}

export interface IDtpOrder {
    id?: string | undefined;
    orderNumber?: string | undefined;
    modifiedByUsername?: string | undefined;
    modifiedByTime?: string | undefined;
    status?: string | undefined;
    orderDate?: string | undefined;
    orderReceivedDate?: string | undefined;
    orderType?: string | undefined;
    orderedByFirstName?: string | undefined;
    orderedByLastName?: string | undefined;
    orderedByAddressLine1?: string | undefined;
    orderedByAddressLine2?: string | undefined;
    orderedByCity?: string | undefined;
    orderedByState?: string | undefined;
    orderedByZipCode?: string | undefined;
    orderedByCountry?: string | undefined;
    shipToFirstName?: string | undefined;
    shipToLastName?: string | undefined;
    shipToAddressLine1?: string | undefined;
    shipToAddressLine2?: string | undefined;
    shipToCity?: string | undefined;
    shipToState?: string | undefined;
    shipToZipCode?: string | undefined;
    shipToCountry?: string | undefined;
    shipmentCarrier?: string | undefined;
    shipmentCarrierService?: string | undefined;
    orderLines?: OrderLine[] | undefined;
    repId?: string | undefined;
    hcpId?: string | undefined;
    orderSource?: string | undefined;
    programId?: string | undefined;
    communicationLabel?: string | undefined;
    externalOrderNumber?: string | undefined;
    parentOrder?: string | undefined;
    jobId?: string | undefined;
    programName?: string | undefined;
    relatedOfferId?: string | undefined;
    formId?: string | undefined;
    batchNumber?: string | undefined;
    batchDate?: string | undefined;
    orderLifeCycleStage?: string | undefined;
    lifeCycleStatus?: number;
    repFirstName?: string | undefined;
    repLastName?: string | undefined;
    repTerritory?: string | undefined;
}

export class Product implements IProduct {
    id?: string | undefined;
    tenantId?: number;
    code?: string | undefined;
    name?: string | undefined;
    fulfillmentSource?: string | undefined;
    inventoryStatus?: string | undefined;
    availableInventory?: number;
    productType?: string | undefined;
    drugSchedule?: string | undefined;
    shortDay?: string | undefined;
    storageCondition?: string | undefined;
    description?: string | undefined;
    uom?: string | undefined;
    imagePath?: string | undefined;
    territoryId?: string | undefined;
    activeLots?: Lot[] | undefined;
    inactiveLots?: Lot[] | undefined;
    dtpOrders?: DtpOrder[] | undefined;
    dtrOrders?: DtrOrder[] | undefined;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.fulfillmentSource = _data["fulfillmentSource"];
            this.inventoryStatus = _data["inventoryStatus"];
            this.availableInventory = _data["availableInventory"];
            this.productType = _data["productType"];
            this.drugSchedule = _data["drugSchedule"];
            this.shortDay = _data["shortDay"];
            this.storageCondition = _data["storageCondition"];
            this.description = _data["description"];
            this.uom = _data["uom"];
            this.imagePath = _data["imagePath"];
            this.territoryId = _data["territoryId"];
            if (Array.isArray(_data["activeLots"])) {
                this.activeLots = [] as any;
                for (let item of _data["activeLots"])
                    this.activeLots!.push(Lot.fromJS(item));
            }
            if (Array.isArray(_data["inactiveLots"])) {
                this.inactiveLots = [] as any;
                for (let item of _data["inactiveLots"])
                    this.inactiveLots!.push(Lot.fromJS(item));
            }
            if (Array.isArray(_data["dtpOrders"])) {
                this.dtpOrders = [] as any;
                for (let item of _data["dtpOrders"])
                    this.dtpOrders!.push(DtpOrder.fromJS(item));
            }
            if (Array.isArray(_data["dtrOrders"])) {
                this.dtrOrders = [] as any;
                for (let item of _data["dtrOrders"])
                    this.dtrOrders!.push(DtrOrder.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["fulfillmentSource"] = this.fulfillmentSource;
        data["inventoryStatus"] = this.inventoryStatus;
        data["availableInventory"] = this.availableInventory;
        data["productType"] = this.productType;
        data["drugSchedule"] = this.drugSchedule;
        data["shortDay"] = this.shortDay;
        data["storageCondition"] = this.storageCondition;
        data["description"] = this.description;
        data["uom"] = this.uom;
        data["imagePath"] = this.imagePath;
        data["territoryId"] = this.territoryId;
        if (Array.isArray(this.activeLots)) {
            data["activeLots"] = [];
            for (let item of this.activeLots)
                data["activeLots"].push(item.toJSON());
        }
        if (Array.isArray(this.inactiveLots)) {
            data["inactiveLots"] = [];
            for (let item of this.inactiveLots)
                data["inactiveLots"].push(item.toJSON());
        }
        if (Array.isArray(this.dtpOrders)) {
            data["dtpOrders"] = [];
            for (let item of this.dtpOrders)
                data["dtpOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.dtrOrders)) {
            data["dtrOrders"] = [];
            for (let item of this.dtrOrders)
                data["dtrOrders"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Product {
        const json = this.toJSON();
        let result = new Product();
        result.init(json);
        return result;
    }
}

export interface IProduct {
    id?: string | undefined;
    tenantId?: number;
    code?: string | undefined;
    name?: string | undefined;
    fulfillmentSource?: string | undefined;
    inventoryStatus?: string | undefined;
    availableInventory?: number;
    productType?: string | undefined;
    drugSchedule?: string | undefined;
    shortDay?: string | undefined;
    storageCondition?: string | undefined;
    description?: string | undefined;
    uom?: string | undefined;
    imagePath?: string | undefined;
    territoryId?: string | undefined;
    activeLots?: Lot[] | undefined;
    inactiveLots?: Lot[] | undefined;
    dtpOrders?: DtpOrder[] | undefined;
    dtrOrders?: DtrOrder[] | undefined;
}

export class OrderLine implements IOrderLine {
    id?: string | undefined;
    tenantId?: number;
    orderId?: string | undefined;
    productId?: string | undefined;
    status?: string | undefined;
    orderQty?: number;
    adjustedOrderQty?: number | undefined;
    shippedQty?: number | undefined;
    adjustedQuantity?: number | undefined;
    deliveredQty?: number;
    adjustedDeliveryQty?: number | undefined;
    returnedQty?: number | undefined;
    orderReceivedDate?: Date;
    product?: Product;

    constructor(data?: IOrderLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.orderId = _data["orderId"];
            this.productId = _data["productId"];
            this.status = _data["status"];
            this.orderQty = _data["orderQty"];
            this.adjustedOrderQty = _data["adjustedOrderQty"];
            this.shippedQty = _data["shippedQty"];
            this.adjustedQuantity = _data["adjustedQuantity"];
            this.deliveredQty = _data["deliveredQty"];
            this.adjustedDeliveryQty = _data["adjustedDeliveryQty"];
            this.returnedQty = _data["returnedQty"];
            this.orderReceivedDate = _data["orderReceivedDate"] ? new Date(_data["orderReceivedDate"].toString()) : <any>undefined;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderLine {
        data = typeof data === 'object' ? data : {};
        let result = new OrderLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["orderId"] = this.orderId;
        data["productId"] = this.productId;
        data["status"] = this.status;
        data["orderQty"] = this.orderQty;
        data["adjustedOrderQty"] = this.adjustedOrderQty;
        data["shippedQty"] = this.shippedQty;
        data["adjustedQuantity"] = this.adjustedQuantity;
        data["deliveredQty"] = this.deliveredQty;
        data["adjustedDeliveryQty"] = this.adjustedDeliveryQty;
        data["returnedQty"] = this.returnedQty;
        data["orderReceivedDate"] = this.orderReceivedDate ? this.orderReceivedDate.toISOString() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data; 
    }

    clone(): OrderLine {
        const json = this.toJSON();
        let result = new OrderLine();
        result.init(json);
        return result;
    }
}

export interface IOrderLine {
    id?: string | undefined;
    tenantId?: number;
    orderId?: string | undefined;
    productId?: string | undefined;
    status?: string | undefined;
    orderQty?: number;
    adjustedOrderQty?: number | undefined;
    shippedQty?: number | undefined;
    adjustedQuantity?: number | undefined;
    deliveredQty?: number;
    adjustedDeliveryQty?: number | undefined;
    returnedQty?: number | undefined;
    orderReceivedDate?: Date;
    product?: Product;
}

export class DtrOrder implements IDtrOrder {
    id?: string | undefined;
    orderNumber?: string | undefined;
    modifiedByUsername?: string | undefined;
    modifiedByTime?: string | undefined;
    status?: string | undefined;
    orderDate?: string | undefined;
    orderReceivedDate?: string | undefined;
    orderType?: string | undefined;
    orderedByFirstName?: string | undefined;
    orderedByLastName?: string | undefined;
    orderedByAddressLine1?: string | undefined;
    orderedByAddressLine2?: string | undefined;
    orderedByCity?: string | undefined;
    orderedByState?: string | undefined;
    orderedByZipCode?: string | undefined;
    orderedByCountry?: string | undefined;
    shipToFirstName?: string | undefined;
    shipToLastName?: string | undefined;
    shipToAddressLine1?: string | undefined;
    shipToAddressLine2?: string | undefined;
    shipToCity?: string | undefined;
    shipToState?: string | undefined;
    shipToZipCode?: string | undefined;
    shipToCountry?: string | undefined;
    shipmentCarrier?: string | undefined;
    shipmentCarrierService?: string | undefined;
    orderLines?: OrderLine[] | undefined;
    repId?: string | undefined;
    hcpId?: string | undefined;
    rushFlag?: boolean;
    orderedByPhoneNumber?: string | undefined;
    shipToPhoneNumber?: string | undefined;

    constructor(data?: IDtrOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.modifiedByUsername = _data["modifiedByUsername"];
            this.modifiedByTime = _data["modifiedByTime"];
            this.status = _data["status"];
            this.orderDate = _data["orderDate"];
            this.orderReceivedDate = _data["orderReceivedDate"];
            this.orderType = _data["orderType"];
            this.orderedByFirstName = _data["orderedByFirstName"];
            this.orderedByLastName = _data["orderedByLastName"];
            this.orderedByAddressLine1 = _data["orderedByAddressLine1"];
            this.orderedByAddressLine2 = _data["orderedByAddressLine2"];
            this.orderedByCity = _data["orderedByCity"];
            this.orderedByState = _data["orderedByState"];
            this.orderedByZipCode = _data["orderedByZipCode"];
            this.orderedByCountry = _data["orderedByCountry"];
            this.shipToFirstName = _data["shipToFirstName"];
            this.shipToLastName = _data["shipToLastName"];
            this.shipToAddressLine1 = _data["shipToAddressLine1"];
            this.shipToAddressLine2 = _data["shipToAddressLine2"];
            this.shipToCity = _data["shipToCity"];
            this.shipToState = _data["shipToState"];
            this.shipToZipCode = _data["shipToZipCode"];
            this.shipToCountry = _data["shipToCountry"];
            this.shipmentCarrier = _data["shipmentCarrier"];
            this.shipmentCarrierService = _data["shipmentCarrierService"];
            if (Array.isArray(_data["orderLines"])) {
                this.orderLines = [] as any;
                for (let item of _data["orderLines"])
                    this.orderLines!.push(OrderLine.fromJS(item));
            }
            this.repId = _data["repId"];
            this.hcpId = _data["hcpId"];
            this.rushFlag = _data["rushFlag"];
            this.orderedByPhoneNumber = _data["orderedByPhoneNumber"];
            this.shipToPhoneNumber = _data["shipToPhoneNumber"];
        }
    }

    static fromJS(data: any): DtrOrder {
        data = typeof data === 'object' ? data : {};
        let result = new DtrOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["modifiedByUsername"] = this.modifiedByUsername;
        data["modifiedByTime"] = this.modifiedByTime;
        data["status"] = this.status;
        data["orderDate"] = this.orderDate;
        data["orderReceivedDate"] = this.orderReceivedDate;
        data["orderType"] = this.orderType;
        data["orderedByFirstName"] = this.orderedByFirstName;
        data["orderedByLastName"] = this.orderedByLastName;
        data["orderedByAddressLine1"] = this.orderedByAddressLine1;
        data["orderedByAddressLine2"] = this.orderedByAddressLine2;
        data["orderedByCity"] = this.orderedByCity;
        data["orderedByState"] = this.orderedByState;
        data["orderedByZipCode"] = this.orderedByZipCode;
        data["orderedByCountry"] = this.orderedByCountry;
        data["shipToFirstName"] = this.shipToFirstName;
        data["shipToLastName"] = this.shipToLastName;
        data["shipToAddressLine1"] = this.shipToAddressLine1;
        data["shipToAddressLine2"] = this.shipToAddressLine2;
        data["shipToCity"] = this.shipToCity;
        data["shipToState"] = this.shipToState;
        data["shipToZipCode"] = this.shipToZipCode;
        data["shipToCountry"] = this.shipToCountry;
        data["shipmentCarrier"] = this.shipmentCarrier;
        data["shipmentCarrierService"] = this.shipmentCarrierService;
        if (Array.isArray(this.orderLines)) {
            data["orderLines"] = [];
            for (let item of this.orderLines)
                data["orderLines"].push(item.toJSON());
        }
        data["repId"] = this.repId;
        data["hcpId"] = this.hcpId;
        data["rushFlag"] = this.rushFlag;
        data["orderedByPhoneNumber"] = this.orderedByPhoneNumber;
        data["shipToPhoneNumber"] = this.shipToPhoneNumber;
        return data; 
    }

    clone(): DtrOrder {
        const json = this.toJSON();
        let result = new DtrOrder();
        result.init(json);
        return result;
    }
}

export interface IDtrOrder {
    id?: string | undefined;
    orderNumber?: string | undefined;
    modifiedByUsername?: string | undefined;
    modifiedByTime?: string | undefined;
    status?: string | undefined;
    orderDate?: string | undefined;
    orderReceivedDate?: string | undefined;
    orderType?: string | undefined;
    orderedByFirstName?: string | undefined;
    orderedByLastName?: string | undefined;
    orderedByAddressLine1?: string | undefined;
    orderedByAddressLine2?: string | undefined;
    orderedByCity?: string | undefined;
    orderedByState?: string | undefined;
    orderedByZipCode?: string | undefined;
    orderedByCountry?: string | undefined;
    shipToFirstName?: string | undefined;
    shipToLastName?: string | undefined;
    shipToAddressLine1?: string | undefined;
    shipToAddressLine2?: string | undefined;
    shipToCity?: string | undefined;
    shipToState?: string | undefined;
    shipToZipCode?: string | undefined;
    shipToCountry?: string | undefined;
    shipmentCarrier?: string | undefined;
    shipmentCarrierService?: string | undefined;
    orderLines?: OrderLine[] | undefined;
    repId?: string | undefined;
    hcpId?: string | undefined;
    rushFlag?: boolean;
    orderedByPhoneNumber?: string | undefined;
    shipToPhoneNumber?: string | undefined;
}

export class Hcp implements IHcp {
    id?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    address1Text?: string | undefined;
    address2Text?: string | undefined;
    address3Text?: string | undefined;
    address4Text?: string | undefined;
    cityName?: string | undefined;
    zipCode?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    phoneNumber?: string | undefined;
    title?: string | undefined;
    phoneExtensionNumber?: string | undefined;
    faxNumber?: string | undefined;
    mobilePhoneNumber?: string | undefined;
    countryCode?: string | undefined;
    stateCode?: string | undefined;
    internalFlag?: boolean;
    lastLoginTime?: Date;
    readonly fullName?: string | undefined;
    knipperId?: string | undefined;
    clientId?: string | undefined;
    npiNbr?: string | undefined;
    suffix?: string | undefined;
    primarySpeciality?: string | undefined;
    secondarySpeciality?: string | undefined;
    sanExemptionFlag?: boolean;
    professionalDesignation?: string | undefined;
    status?: string | undefined;
    facilityName?: string | undefined;
    profession?: string | undefined;
    patientsInMonth?: string | undefined;
    accountRegistrationStatus?: string | undefined;
    secondaryAuthorizationNumber?: string | undefined;
    tddExemptionFlag?: boolean;
    certifiedHcpConsent?: boolean | undefined;
    termsAgreementFlag?: boolean | undefined;
    totalReceivedOrders?: number;
    totalPendingAocs?: number;
    dtrOrders?: DtrOrder[] | undefined;
    dtpOrders?: DtpOrder[] | undefined;

    constructor(data?: IHcp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.address1Text = _data["address1Text"];
            this.address2Text = _data["address2Text"];
            this.address3Text = _data["address3Text"];
            this.address4Text = _data["address4Text"];
            this.cityName = _data["cityName"];
            this.zipCode = _data["zipCode"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.title = _data["title"];
            this.phoneExtensionNumber = _data["phoneExtensionNumber"];
            this.faxNumber = _data["faxNumber"];
            this.mobilePhoneNumber = _data["mobilePhoneNumber"];
            this.countryCode = _data["countryCode"];
            this.stateCode = _data["stateCode"];
            this.internalFlag = _data["internalFlag"];
            this.lastLoginTime = _data["lastLoginTime"] ? new Date(_data["lastLoginTime"].toString()) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            this.knipperId = _data["knipperId"];
            this.clientId = _data["clientId"];
            this.npiNbr = _data["npiNbr"];
            this.suffix = _data["suffix"];
            this.primarySpeciality = _data["primarySpeciality"];
            this.secondarySpeciality = _data["secondarySpeciality"];
            this.sanExemptionFlag = _data["sanExemptionFlag"];
            this.professionalDesignation = _data["professionalDesignation"];
            this.status = _data["status"];
            this.facilityName = _data["facilityName"];
            this.profession = _data["profession"];
            this.patientsInMonth = _data["patientsInMonth"];
            this.accountRegistrationStatus = _data["accountRegistrationStatus"];
            this.secondaryAuthorizationNumber = _data["secondaryAuthorizationNumber"];
            this.tddExemptionFlag = _data["tddExemptionFlag"];
            this.certifiedHcpConsent = _data["certifiedHcpConsent"];
            this.termsAgreementFlag = _data["termsAgreementFlag"];
            this.totalReceivedOrders = _data["totalReceivedOrders"];
            this.totalPendingAocs = _data["totalPendingAocs"];
            if (Array.isArray(_data["dtrOrders"])) {
                this.dtrOrders = [] as any;
                for (let item of _data["dtrOrders"])
                    this.dtrOrders!.push(DtrOrder.fromJS(item));
            }
            if (Array.isArray(_data["dtpOrders"])) {
                this.dtpOrders = [] as any;
                for (let item of _data["dtpOrders"])
                    this.dtpOrders!.push(DtpOrder.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Hcp {
        data = typeof data === 'object' ? data : {};
        let result = new Hcp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["address1Text"] = this.address1Text;
        data["address2Text"] = this.address2Text;
        data["address3Text"] = this.address3Text;
        data["address4Text"] = this.address4Text;
        data["cityName"] = this.cityName;
        data["zipCode"] = this.zipCode;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["title"] = this.title;
        data["phoneExtensionNumber"] = this.phoneExtensionNumber;
        data["faxNumber"] = this.faxNumber;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["countryCode"] = this.countryCode;
        data["stateCode"] = this.stateCode;
        data["internalFlag"] = this.internalFlag;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["fullName"] = this.fullName;
        data["knipperId"] = this.knipperId;
        data["clientId"] = this.clientId;
        data["npiNbr"] = this.npiNbr;
        data["suffix"] = this.suffix;
        data["primarySpeciality"] = this.primarySpeciality;
        data["secondarySpeciality"] = this.secondarySpeciality;
        data["sanExemptionFlag"] = this.sanExemptionFlag;
        data["professionalDesignation"] = this.professionalDesignation;
        data["status"] = this.status;
        data["facilityName"] = this.facilityName;
        data["profession"] = this.profession;
        data["patientsInMonth"] = this.patientsInMonth;
        data["accountRegistrationStatus"] = this.accountRegistrationStatus;
        data["secondaryAuthorizationNumber"] = this.secondaryAuthorizationNumber;
        data["tddExemptionFlag"] = this.tddExemptionFlag;
        data["certifiedHcpConsent"] = this.certifiedHcpConsent;
        data["termsAgreementFlag"] = this.termsAgreementFlag;
        data["totalReceivedOrders"] = this.totalReceivedOrders;
        data["totalPendingAocs"] = this.totalPendingAocs;
        if (Array.isArray(this.dtrOrders)) {
            data["dtrOrders"] = [];
            for (let item of this.dtrOrders)
                data["dtrOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.dtpOrders)) {
            data["dtpOrders"] = [];
            for (let item of this.dtpOrders)
                data["dtpOrders"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Hcp {
        const json = this.toJSON();
        let result = new Hcp();
        result.init(json);
        return result;
    }
}

export interface IHcp {
    id?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    address1Text?: string | undefined;
    address2Text?: string | undefined;
    address3Text?: string | undefined;
    address4Text?: string | undefined;
    cityName?: string | undefined;
    zipCode?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    phoneNumber?: string | undefined;
    title?: string | undefined;
    phoneExtensionNumber?: string | undefined;
    faxNumber?: string | undefined;
    mobilePhoneNumber?: string | undefined;
    countryCode?: string | undefined;
    stateCode?: string | undefined;
    internalFlag?: boolean;
    lastLoginTime?: Date;
    fullName?: string | undefined;
    knipperId?: string | undefined;
    clientId?: string | undefined;
    npiNbr?: string | undefined;
    suffix?: string | undefined;
    primarySpeciality?: string | undefined;
    secondarySpeciality?: string | undefined;
    sanExemptionFlag?: boolean;
    professionalDesignation?: string | undefined;
    status?: string | undefined;
    facilityName?: string | undefined;
    profession?: string | undefined;
    patientsInMonth?: string | undefined;
    accountRegistrationStatus?: string | undefined;
    secondaryAuthorizationNumber?: string | undefined;
    tddExemptionFlag?: boolean;
    certifiedHcpConsent?: boolean | undefined;
    termsAgreementFlag?: boolean | undefined;
    totalReceivedOrders?: number;
    totalPendingAocs?: number;
    dtrOrders?: DtrOrder[] | undefined;
    dtpOrders?: DtpOrder[] | undefined;
}

export class Mail implements IMail {
    addresseeName?: string | undefined;
    toCompanyName?: string | undefined;
    toAddress1Text?: string | undefined;
    toAddress2Text?: string | undefined;
    toAddress3Text?: string | undefined;
    toAddress4Text?: string | undefined;
    toCityName?: string | undefined;
    toZipCode?: string | undefined;
    stateCode?: string | undefined;
    countryCode?: string | undefined;

    constructor(data?: IMail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addresseeName = _data["addresseeName"];
            this.toCompanyName = _data["toCompanyName"];
            this.toAddress1Text = _data["toAddress1Text"];
            this.toAddress2Text = _data["toAddress2Text"];
            this.toAddress3Text = _data["toAddress3Text"];
            this.toAddress4Text = _data["toAddress4Text"];
            this.toCityName = _data["toCityName"];
            this.toZipCode = _data["toZipCode"];
            this.stateCode = _data["stateCode"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): Mail {
        data = typeof data === 'object' ? data : {};
        let result = new Mail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addresseeName"] = this.addresseeName;
        data["toCompanyName"] = this.toCompanyName;
        data["toAddress1Text"] = this.toAddress1Text;
        data["toAddress2Text"] = this.toAddress2Text;
        data["toAddress3Text"] = this.toAddress3Text;
        data["toAddress4Text"] = this.toAddress4Text;
        data["toCityName"] = this.toCityName;
        data["toZipCode"] = this.toZipCode;
        data["stateCode"] = this.stateCode;
        data["countryCode"] = this.countryCode;
        return data; 
    }

    clone(): Mail {
        const json = this.toJSON();
        let result = new Mail();
        result.init(json);
        return result;
    }
}

export interface IMail {
    addresseeName?: string | undefined;
    toCompanyName?: string | undefined;
    toAddress1Text?: string | undefined;
    toAddress2Text?: string | undefined;
    toAddress3Text?: string | undefined;
    toAddress4Text?: string | undefined;
    toCityName?: string | undefined;
    toZipCode?: string | undefined;
    stateCode?: string | undefined;
    countryCode?: string | undefined;
}

export class Communication implements ICommunication {
    id?: string | undefined;
    tenantId?: number;
    direction?: string | undefined;
    communicationType?: string | undefined;
    communicationDate?: Date;
    communicationSource?: string | undefined;
    attachmentType?: string | undefined;
    attachmentName?: string | undefined;
    emailRecipient?: string | undefined;
    faxNumber?: string | undefined;
    mail?: Mail;
    orderId?: string | undefined;
    orderReceivedDate?: Date;

    constructor(data?: ICommunication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.direction = _data["direction"];
            this.communicationType = _data["communicationType"];
            this.communicationDate = _data["communicationDate"] ? new Date(_data["communicationDate"].toString()) : <any>undefined;
            this.communicationSource = _data["communicationSource"];
            this.attachmentType = _data["attachmentType"];
            this.attachmentName = _data["attachmentName"];
            this.emailRecipient = _data["emailRecipient"];
            this.faxNumber = _data["faxNumber"];
            this.mail = _data["mail"] ? Mail.fromJS(_data["mail"]) : <any>undefined;
            this.orderId = _data["orderId"];
            this.orderReceivedDate = _data["orderReceivedDate"] ? new Date(_data["orderReceivedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Communication {
        data = typeof data === 'object' ? data : {};
        let result = new Communication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["direction"] = this.direction;
        data["communicationType"] = this.communicationType;
        data["communicationDate"] = this.communicationDate ? this.communicationDate.toISOString() : <any>undefined;
        data["communicationSource"] = this.communicationSource;
        data["attachmentType"] = this.attachmentType;
        data["attachmentName"] = this.attachmentName;
        data["emailRecipient"] = this.emailRecipient;
        data["faxNumber"] = this.faxNumber;
        data["mail"] = this.mail ? this.mail.toJSON() : <any>undefined;
        data["orderId"] = this.orderId;
        data["orderReceivedDate"] = this.orderReceivedDate ? this.orderReceivedDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): Communication {
        const json = this.toJSON();
        let result = new Communication();
        result.init(json);
        return result;
    }
}

export interface ICommunication {
    id?: string | undefined;
    tenantId?: number;
    direction?: string | undefined;
    communicationType?: string | undefined;
    communicationDate?: Date;
    communicationSource?: string | undefined;
    attachmentType?: string | undefined;
    attachmentName?: string | undefined;
    emailRecipient?: string | undefined;
    faxNumber?: string | undefined;
    mail?: Mail;
    orderId?: string | undefined;
    orderReceivedDate?: Date;
}

export class Territory implements ITerritory {
    id?: string | undefined;
    tenantId?: number;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: ITerritory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Territory {
        data = typeof data === 'object' ? data : {};
        let result = new Territory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): Territory {
        const json = this.toJSON();
        let result = new Territory();
        result.init(json);
        return result;
    }
}

export interface ITerritory {
    id?: string | undefined;
    tenantId?: number;
    code?: string | undefined;
    name?: string | undefined;
}

export class PushShipment implements IPushShipment {
    id?: string | undefined;
    orderNumber?: string | undefined;
    modifiedByUsername?: string | undefined;
    modifiedByTime?: string | undefined;
    status?: string | undefined;
    orderDate?: string | undefined;
    orderReceivedDate?: string | undefined;
    orderType?: string | undefined;
    orderedByFirstName?: string | undefined;
    orderedByLastName?: string | undefined;
    orderedByAddressLine1?: string | undefined;
    orderedByAddressLine2?: string | undefined;
    orderedByCity?: string | undefined;
    orderedByState?: string | undefined;
    orderedByZipCode?: string | undefined;
    orderedByCountry?: string | undefined;
    shipToFirstName?: string | undefined;
    shipToLastName?: string | undefined;
    shipToAddressLine1?: string | undefined;
    shipToAddressLine2?: string | undefined;
    shipToCity?: string | undefined;
    shipToState?: string | undefined;
    shipToZipCode?: string | undefined;
    shipToCountry?: string | undefined;
    shipmentCarrier?: string | undefined;
    shipmentCarrierService?: string | undefined;
    orderLines?: OrderLine[] | undefined;
    repId?: string | undefined;
    hcpId?: string | undefined;
    rushFlag?: boolean;
    orderedByPhoneNumber?: string | undefined;
    shipToPhoneNumber?: string | undefined;

    constructor(data?: IPushShipment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.modifiedByUsername = _data["modifiedByUsername"];
            this.modifiedByTime = _data["modifiedByTime"];
            this.status = _data["status"];
            this.orderDate = _data["orderDate"];
            this.orderReceivedDate = _data["orderReceivedDate"];
            this.orderType = _data["orderType"];
            this.orderedByFirstName = _data["orderedByFirstName"];
            this.orderedByLastName = _data["orderedByLastName"];
            this.orderedByAddressLine1 = _data["orderedByAddressLine1"];
            this.orderedByAddressLine2 = _data["orderedByAddressLine2"];
            this.orderedByCity = _data["orderedByCity"];
            this.orderedByState = _data["orderedByState"];
            this.orderedByZipCode = _data["orderedByZipCode"];
            this.orderedByCountry = _data["orderedByCountry"];
            this.shipToFirstName = _data["shipToFirstName"];
            this.shipToLastName = _data["shipToLastName"];
            this.shipToAddressLine1 = _data["shipToAddressLine1"];
            this.shipToAddressLine2 = _data["shipToAddressLine2"];
            this.shipToCity = _data["shipToCity"];
            this.shipToState = _data["shipToState"];
            this.shipToZipCode = _data["shipToZipCode"];
            this.shipToCountry = _data["shipToCountry"];
            this.shipmentCarrier = _data["shipmentCarrier"];
            this.shipmentCarrierService = _data["shipmentCarrierService"];
            if (Array.isArray(_data["orderLines"])) {
                this.orderLines = [] as any;
                for (let item of _data["orderLines"])
                    this.orderLines!.push(OrderLine.fromJS(item));
            }
            this.repId = _data["repId"];
            this.hcpId = _data["hcpId"];
            this.rushFlag = _data["rushFlag"];
            this.orderedByPhoneNumber = _data["orderedByPhoneNumber"];
            this.shipToPhoneNumber = _data["shipToPhoneNumber"];
        }
    }

    static fromJS(data: any): PushShipment {
        data = typeof data === 'object' ? data : {};
        let result = new PushShipment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["modifiedByUsername"] = this.modifiedByUsername;
        data["modifiedByTime"] = this.modifiedByTime;
        data["status"] = this.status;
        data["orderDate"] = this.orderDate;
        data["orderReceivedDate"] = this.orderReceivedDate;
        data["orderType"] = this.orderType;
        data["orderedByFirstName"] = this.orderedByFirstName;
        data["orderedByLastName"] = this.orderedByLastName;
        data["orderedByAddressLine1"] = this.orderedByAddressLine1;
        data["orderedByAddressLine2"] = this.orderedByAddressLine2;
        data["orderedByCity"] = this.orderedByCity;
        data["orderedByState"] = this.orderedByState;
        data["orderedByZipCode"] = this.orderedByZipCode;
        data["orderedByCountry"] = this.orderedByCountry;
        data["shipToFirstName"] = this.shipToFirstName;
        data["shipToLastName"] = this.shipToLastName;
        data["shipToAddressLine1"] = this.shipToAddressLine1;
        data["shipToAddressLine2"] = this.shipToAddressLine2;
        data["shipToCity"] = this.shipToCity;
        data["shipToState"] = this.shipToState;
        data["shipToZipCode"] = this.shipToZipCode;
        data["shipToCountry"] = this.shipToCountry;
        data["shipmentCarrier"] = this.shipmentCarrier;
        data["shipmentCarrierService"] = this.shipmentCarrierService;
        if (Array.isArray(this.orderLines)) {
            data["orderLines"] = [];
            for (let item of this.orderLines)
                data["orderLines"].push(item.toJSON());
        }
        data["repId"] = this.repId;
        data["hcpId"] = this.hcpId;
        data["rushFlag"] = this.rushFlag;
        data["orderedByPhoneNumber"] = this.orderedByPhoneNumber;
        data["shipToPhoneNumber"] = this.shipToPhoneNumber;
        return data; 
    }

    clone(): PushShipment {
        const json = this.toJSON();
        let result = new PushShipment();
        result.init(json);
        return result;
    }
}

export interface IPushShipment {
    id?: string | undefined;
    orderNumber?: string | undefined;
    modifiedByUsername?: string | undefined;
    modifiedByTime?: string | undefined;
    status?: string | undefined;
    orderDate?: string | undefined;
    orderReceivedDate?: string | undefined;
    orderType?: string | undefined;
    orderedByFirstName?: string | undefined;
    orderedByLastName?: string | undefined;
    orderedByAddressLine1?: string | undefined;
    orderedByAddressLine2?: string | undefined;
    orderedByCity?: string | undefined;
    orderedByState?: string | undefined;
    orderedByZipCode?: string | undefined;
    orderedByCountry?: string | undefined;
    shipToFirstName?: string | undefined;
    shipToLastName?: string | undefined;
    shipToAddressLine1?: string | undefined;
    shipToAddressLine2?: string | undefined;
    shipToCity?: string | undefined;
    shipToState?: string | undefined;
    shipToZipCode?: string | undefined;
    shipToCountry?: string | undefined;
    shipmentCarrier?: string | undefined;
    shipmentCarrierService?: string | undefined;
    orderLines?: OrderLine[] | undefined;
    repId?: string | undefined;
    hcpId?: string | undefined;
    rushFlag?: boolean;
    orderedByPhoneNumber?: string | undefined;
    shipToPhoneNumber?: string | undefined;
}

export class RepTerritory implements IRepTerritory {
    id?: string | undefined;
    tenantId?: number;
    repId?: string | undefined;
    territoryId?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    territory?: Territory;

    constructor(data?: IRepTerritory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.repId = _data["repId"];
            this.territoryId = _data["territoryId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.territory = _data["territory"] ? Territory.fromJS(_data["territory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RepTerritory {
        data = typeof data === 'object' ? data : {};
        let result = new RepTerritory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["repId"] = this.repId;
        data["territoryId"] = this.territoryId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["territory"] = this.territory ? this.territory.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RepTerritory {
        const json = this.toJSON();
        let result = new RepTerritory();
        result.init(json);
        return result;
    }
}

export interface IRepTerritory {
    id?: string | undefined;
    tenantId?: number;
    repId?: string | undefined;
    territoryId?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    territory?: Territory;
}

export class Rep implements IRep {
    id?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    address1Text?: string | undefined;
    address2Text?: string | undefined;
    address3Text?: string | undefined;
    address4Text?: string | undefined;
    cityName?: string | undefined;
    zipCode?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    phoneNumber?: string | undefined;
    title?: string | undefined;
    phoneExtensionNumber?: string | undefined;
    faxNumber?: string | undefined;
    mobilePhoneNumber?: string | undefined;
    countryCode?: string | undefined;
    stateCode?: string | undefined;
    internalFlag?: boolean;
    lastLoginTime?: Date;
    readonly fullName?: string | undefined;
    clientRepNbrCode?: string | undefined;
    totalOrdersReceived?: number;
    therapeuticClass?: string | undefined;
    currentTerritory?: Territory;
    oldTerritoriesCount?: number;
    repPushShipments?: PushShipment[] | undefined;
    dtrOrders?: DtrOrder[] | undefined;
    dtpOrders?: DtpOrder[] | undefined;
    repTerritories?: RepTerritory[] | undefined;

    constructor(data?: IRep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.address1Text = _data["address1Text"];
            this.address2Text = _data["address2Text"];
            this.address3Text = _data["address3Text"];
            this.address4Text = _data["address4Text"];
            this.cityName = _data["cityName"];
            this.zipCode = _data["zipCode"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.title = _data["title"];
            this.phoneExtensionNumber = _data["phoneExtensionNumber"];
            this.faxNumber = _data["faxNumber"];
            this.mobilePhoneNumber = _data["mobilePhoneNumber"];
            this.countryCode = _data["countryCode"];
            this.stateCode = _data["stateCode"];
            this.internalFlag = _data["internalFlag"];
            this.lastLoginTime = _data["lastLoginTime"] ? new Date(_data["lastLoginTime"].toString()) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            this.clientRepNbrCode = _data["clientRepNbrCode"];
            this.totalOrdersReceived = _data["totalOrdersReceived"];
            this.therapeuticClass = _data["therapeuticClass"];
            this.currentTerritory = _data["currentTerritory"] ? Territory.fromJS(_data["currentTerritory"]) : <any>undefined;
            this.oldTerritoriesCount = _data["oldTerritoriesCount"];
            if (Array.isArray(_data["repPushShipments"])) {
                this.repPushShipments = [] as any;
                for (let item of _data["repPushShipments"])
                    this.repPushShipments!.push(PushShipment.fromJS(item));
            }
            if (Array.isArray(_data["dtrOrders"])) {
                this.dtrOrders = [] as any;
                for (let item of _data["dtrOrders"])
                    this.dtrOrders!.push(DtrOrder.fromJS(item));
            }
            if (Array.isArray(_data["dtpOrders"])) {
                this.dtpOrders = [] as any;
                for (let item of _data["dtpOrders"])
                    this.dtpOrders!.push(DtpOrder.fromJS(item));
            }
            if (Array.isArray(_data["repTerritories"])) {
                this.repTerritories = [] as any;
                for (let item of _data["repTerritories"])
                    this.repTerritories!.push(RepTerritory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Rep {
        data = typeof data === 'object' ? data : {};
        let result = new Rep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["address1Text"] = this.address1Text;
        data["address2Text"] = this.address2Text;
        data["address3Text"] = this.address3Text;
        data["address4Text"] = this.address4Text;
        data["cityName"] = this.cityName;
        data["zipCode"] = this.zipCode;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["title"] = this.title;
        data["phoneExtensionNumber"] = this.phoneExtensionNumber;
        data["faxNumber"] = this.faxNumber;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["countryCode"] = this.countryCode;
        data["stateCode"] = this.stateCode;
        data["internalFlag"] = this.internalFlag;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["fullName"] = this.fullName;
        data["clientRepNbrCode"] = this.clientRepNbrCode;
        data["totalOrdersReceived"] = this.totalOrdersReceived;
        data["therapeuticClass"] = this.therapeuticClass;
        data["currentTerritory"] = this.currentTerritory ? this.currentTerritory.toJSON() : <any>undefined;
        data["oldTerritoriesCount"] = this.oldTerritoriesCount;
        if (Array.isArray(this.repPushShipments)) {
            data["repPushShipments"] = [];
            for (let item of this.repPushShipments)
                data["repPushShipments"].push(item.toJSON());
        }
        if (Array.isArray(this.dtrOrders)) {
            data["dtrOrders"] = [];
            for (let item of this.dtrOrders)
                data["dtrOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.dtpOrders)) {
            data["dtpOrders"] = [];
            for (let item of this.dtpOrders)
                data["dtpOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.repTerritories)) {
            data["repTerritories"] = [];
            for (let item of this.repTerritories)
                data["repTerritories"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Rep {
        const json = this.toJSON();
        let result = new Rep();
        result.init(json);
        return result;
    }
}

export interface IRep {
    id?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    address1Text?: string | undefined;
    address2Text?: string | undefined;
    address3Text?: string | undefined;
    address4Text?: string | undefined;
    cityName?: string | undefined;
    zipCode?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    phoneNumber?: string | undefined;
    title?: string | undefined;
    phoneExtensionNumber?: string | undefined;
    faxNumber?: string | undefined;
    mobilePhoneNumber?: string | undefined;
    countryCode?: string | undefined;
    stateCode?: string | undefined;
    internalFlag?: boolean;
    lastLoginTime?: Date;
    fullName?: string | undefined;
    clientRepNbrCode?: string | undefined;
    totalOrdersReceived?: number;
    therapeuticClass?: string | undefined;
    currentTerritory?: Territory;
    oldTerritoriesCount?: number;
    repPushShipments?: PushShipment[] | undefined;
    dtrOrders?: DtrOrder[] | undefined;
    dtpOrders?: DtpOrder[] | undefined;
    repTerritories?: RepTerritory[] | undefined;
}

export class HandCarryDisbursement implements IHandCarryDisbursement {
    id?: string | undefined;
    tenantId?: number;
    disbursementNumber?: string | undefined;
    image?: string | undefined;
    referenceNumber?: string | undefined;
    disbursementDate?: Date;
    hcpId?: string | undefined;
    repId?: string | undefined;
    territoryId?: string | undefined;
    status?: string | undefined;
    validForRecon?: boolean;
    paperReferenceNumber?: string | undefined;
    hcp?: Hcp;
    rep?: Rep;
    territory?: Territory;

    constructor(data?: IHandCarryDisbursement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.disbursementNumber = _data["disbursementNumber"];
            this.image = _data["image"];
            this.referenceNumber = _data["referenceNumber"];
            this.disbursementDate = _data["disbursementDate"] ? new Date(_data["disbursementDate"].toString()) : <any>undefined;
            this.hcpId = _data["hcpId"];
            this.repId = _data["repId"];
            this.territoryId = _data["territoryId"];
            this.status = _data["status"];
            this.validForRecon = _data["validForRecon"];
            this.paperReferenceNumber = _data["paperReferenceNumber"];
            this.hcp = _data["hcp"] ? Hcp.fromJS(_data["hcp"]) : <any>undefined;
            this.rep = _data["rep"] ? Rep.fromJS(_data["rep"]) : <any>undefined;
            this.territory = _data["territory"] ? Territory.fromJS(_data["territory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HandCarryDisbursement {
        data = typeof data === 'object' ? data : {};
        let result = new HandCarryDisbursement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["disbursementNumber"] = this.disbursementNumber;
        data["image"] = this.image;
        data["referenceNumber"] = this.referenceNumber;
        data["disbursementDate"] = this.disbursementDate ? this.disbursementDate.toISOString() : <any>undefined;
        data["hcpId"] = this.hcpId;
        data["repId"] = this.repId;
        data["territoryId"] = this.territoryId;
        data["status"] = this.status;
        data["validForRecon"] = this.validForRecon;
        data["paperReferenceNumber"] = this.paperReferenceNumber;
        data["hcp"] = this.hcp ? this.hcp.toJSON() : <any>undefined;
        data["rep"] = this.rep ? this.rep.toJSON() : <any>undefined;
        data["territory"] = this.territory ? this.territory.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HandCarryDisbursement {
        const json = this.toJSON();
        let result = new HandCarryDisbursement();
        result.init(json);
        return result;
    }
}

export interface IHandCarryDisbursement {
    id?: string | undefined;
    tenantId?: number;
    disbursementNumber?: string | undefined;
    image?: string | undefined;
    referenceNumber?: string | undefined;
    disbursementDate?: Date;
    hcpId?: string | undefined;
    repId?: string | undefined;
    territoryId?: string | undefined;
    status?: string | undefined;
    validForRecon?: boolean;
    paperReferenceNumber?: string | undefined;
    hcp?: Hcp;
    rep?: Rep;
    territory?: Territory;
}

export class HandCarrySignatureAudit implements IHandCarrySignatureAudit {
    id?: string | undefined;
    tenantId?: number;
    year?: string | undefined;
    quarter?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    category?: string | undefined;
    hcpId?: string | undefined;
    repId?: string | undefined;
    auditType?: string | undefined;
    auditReason?: string | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    totalTransactions?: number | undefined;
    selectedTransactions?: number | undefined;
    undeliverable?: number | undefined;
    pending?: number | undefined;
    positiveResponses?: number | undefined;
    neagtiveResponses?: number | undefined;
    hcp?: Hcp;
    rep?: Rep;

    constructor(data?: IHandCarrySignatureAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.year = _data["year"];
            this.quarter = _data["quarter"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.category = _data["category"];
            this.hcpId = _data["hcpId"];
            this.repId = _data["repId"];
            this.auditType = _data["auditType"];
            this.auditReason = _data["auditReason"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.totalTransactions = _data["totalTransactions"];
            this.selectedTransactions = _data["selectedTransactions"];
            this.undeliverable = _data["undeliverable"];
            this.pending = _data["pending"];
            this.positiveResponses = _data["positiveResponses"];
            this.neagtiveResponses = _data["neagtiveResponses"];
            this.hcp = _data["hcp"] ? Hcp.fromJS(_data["hcp"]) : <any>undefined;
            this.rep = _data["rep"] ? Rep.fromJS(_data["rep"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HandCarrySignatureAudit {
        data = typeof data === 'object' ? data : {};
        let result = new HandCarrySignatureAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["year"] = this.year;
        data["quarter"] = this.quarter;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["category"] = this.category;
        data["hcpId"] = this.hcpId;
        data["repId"] = this.repId;
        data["auditType"] = this.auditType;
        data["auditReason"] = this.auditReason;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["totalTransactions"] = this.totalTransactions;
        data["selectedTransactions"] = this.selectedTransactions;
        data["undeliverable"] = this.undeliverable;
        data["pending"] = this.pending;
        data["positiveResponses"] = this.positiveResponses;
        data["neagtiveResponses"] = this.neagtiveResponses;
        data["hcp"] = this.hcp ? this.hcp.toJSON() : <any>undefined;
        data["rep"] = this.rep ? this.rep.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HandCarrySignatureAudit {
        const json = this.toJSON();
        let result = new HandCarrySignatureAudit();
        result.init(json);
        return result;
    }
}

export interface IHandCarrySignatureAudit {
    id?: string | undefined;
    tenantId?: number;
    year?: string | undefined;
    quarter?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    category?: string | undefined;
    hcpId?: string | undefined;
    repId?: string | undefined;
    auditType?: string | undefined;
    auditReason?: string | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    totalTransactions?: number | undefined;
    selectedTransactions?: number | undefined;
    undeliverable?: number | undefined;
    pending?: number | undefined;
    positiveResponses?: number | undefined;
    neagtiveResponses?: number | undefined;
    hcp?: Hcp;
    rep?: Rep;
}

export class TransferOutInformation implements ITransferOutInformation {
    transactionId?: string | undefined;
    transferType?: string | undefined;
    transferOutEmployeeLastName?: string | undefined;
    transferOutEmployyeFirstName?: string | undefined;
    transferOutEmployeeId?: string | undefined;
    transferOUtTettitoryCode?: string | undefined;
    transferOutDate?: Date;
    transferOutRef?: string | undefined;
    isValidReconciallation?: boolean;

    constructor(data?: ITransferOutInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.transferType = _data["transferType"];
            this.transferOutEmployeeLastName = _data["transferOutEmployeeLastName"];
            this.transferOutEmployyeFirstName = _data["transferOutEmployyeFirstName"];
            this.transferOutEmployeeId = _data["transferOutEmployeeId"];
            this.transferOUtTettitoryCode = _data["transferOUtTettitoryCode"];
            this.transferOutDate = _data["transferOutDate"] ? new Date(_data["transferOutDate"].toString()) : <any>undefined;
            this.transferOutRef = _data["transferOutRef"];
            this.isValidReconciallation = _data["isValidReconciallation"];
        }
    }

    static fromJS(data: any): TransferOutInformation {
        data = typeof data === 'object' ? data : {};
        let result = new TransferOutInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["transferType"] = this.transferType;
        data["transferOutEmployeeLastName"] = this.transferOutEmployeeLastName;
        data["transferOutEmployyeFirstName"] = this.transferOutEmployyeFirstName;
        data["transferOutEmployeeId"] = this.transferOutEmployeeId;
        data["transferOUtTettitoryCode"] = this.transferOUtTettitoryCode;
        data["transferOutDate"] = this.transferOutDate ? this.transferOutDate.toISOString() : <any>undefined;
        data["transferOutRef"] = this.transferOutRef;
        data["isValidReconciallation"] = this.isValidReconciallation;
        return data; 
    }

    clone(): TransferOutInformation {
        const json = this.toJSON();
        let result = new TransferOutInformation();
        result.init(json);
        return result;
    }
}

export interface ITransferOutInformation {
    transactionId?: string | undefined;
    transferType?: string | undefined;
    transferOutEmployeeLastName?: string | undefined;
    transferOutEmployyeFirstName?: string | undefined;
    transferOutEmployeeId?: string | undefined;
    transferOUtTettitoryCode?: string | undefined;
    transferOutDate?: Date;
    transferOutRef?: string | undefined;
    isValidReconciallation?: boolean;
}

export class TransferInInformation implements ITransferInInformation {
    transactionId?: string | undefined;
    transactionType?: string | undefined;
    transferInEmployeeLastName?: string | undefined;
    transferInEmployeeFirstName?: string | undefined;
    transferInEmployeeID?: string | undefined;
    transferInTerritoryCode?: string | undefined;
    transferReceived?: boolean;
    transferInReceivedDate?: Date;
    transferInRef?: string | undefined;
    transferInValidForReconcillation?: boolean;

    constructor(data?: ITransferInInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.transactionType = _data["transactionType"];
            this.transferInEmployeeLastName = _data["transferInEmployeeLastName"];
            this.transferInEmployeeFirstName = _data["transferInEmployeeFirstName"];
            this.transferInEmployeeID = _data["transferInEmployeeID"];
            this.transferInTerritoryCode = _data["transferInTerritoryCode"];
            this.transferReceived = _data["transferReceived"];
            this.transferInReceivedDate = _data["transferInReceivedDate"] ? new Date(_data["transferInReceivedDate"].toString()) : <any>undefined;
            this.transferInRef = _data["transferInRef"];
            this.transferInValidForReconcillation = _data["transferInValidForReconcillation"];
        }
    }

    static fromJS(data: any): TransferInInformation {
        data = typeof data === 'object' ? data : {};
        let result = new TransferInInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["transactionType"] = this.transactionType;
        data["transferInEmployeeLastName"] = this.transferInEmployeeLastName;
        data["transferInEmployeeFirstName"] = this.transferInEmployeeFirstName;
        data["transferInEmployeeID"] = this.transferInEmployeeID;
        data["transferInTerritoryCode"] = this.transferInTerritoryCode;
        data["transferReceived"] = this.transferReceived;
        data["transferInReceivedDate"] = this.transferInReceivedDate ? this.transferInReceivedDate.toISOString() : <any>undefined;
        data["transferInRef"] = this.transferInRef;
        data["transferInValidForReconcillation"] = this.transferInValidForReconcillation;
        return data; 
    }

    clone(): TransferInInformation {
        const json = this.toJSON();
        let result = new TransferInInformation();
        result.init(json);
        return result;
    }
}

export interface ITransferInInformation {
    transactionId?: string | undefined;
    transactionType?: string | undefined;
    transferInEmployeeLastName?: string | undefined;
    transferInEmployeeFirstName?: string | undefined;
    transferInEmployeeID?: string | undefined;
    transferInTerritoryCode?: string | undefined;
    transferReceived?: boolean;
    transferInReceivedDate?: Date;
    transferInRef?: string | undefined;
    transferInValidForReconcillation?: boolean;
}

export class TransferOutProducts implements ITransferOutProducts {
    transferOutProduct?: string | undefined;
    transferOutLotNumber?: string | undefined;
    transferOutQty?: string | undefined;
    transferOutCorrectionType?: string | undefined;
    linkStatus?: string | undefined;

    constructor(data?: ITransferOutProducts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferOutProduct = _data["transferOutProduct"];
            this.transferOutLotNumber = _data["transferOutLotNumber"];
            this.transferOutQty = _data["transferOutQty"];
            this.transferOutCorrectionType = _data["transferOutCorrectionType"];
            this.linkStatus = _data["linkStatus"];
        }
    }

    static fromJS(data: any): TransferOutProducts {
        data = typeof data === 'object' ? data : {};
        let result = new TransferOutProducts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferOutProduct"] = this.transferOutProduct;
        data["transferOutLotNumber"] = this.transferOutLotNumber;
        data["transferOutQty"] = this.transferOutQty;
        data["transferOutCorrectionType"] = this.transferOutCorrectionType;
        data["linkStatus"] = this.linkStatus;
        return data; 
    }

    clone(): TransferOutProducts {
        const json = this.toJSON();
        let result = new TransferOutProducts();
        result.init(json);
        return result;
    }
}

export interface ITransferOutProducts {
    transferOutProduct?: string | undefined;
    transferOutLotNumber?: string | undefined;
    transferOutQty?: string | undefined;
    transferOutCorrectionType?: string | undefined;
    linkStatus?: string | undefined;
}

export class TransferInProducts implements ITransferInProducts {
    transferInProduct?: string | undefined;
    transferInLotNumber?: string | undefined;
    transferInQty?: string | undefined;
    transferInCorrectionType?: string | undefined;

    constructor(data?: ITransferInProducts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferInProduct = _data["transferInProduct"];
            this.transferInLotNumber = _data["transferInLotNumber"];
            this.transferInQty = _data["transferInQty"];
            this.transferInCorrectionType = _data["transferInCorrectionType"];
        }
    }

    static fromJS(data: any): TransferInProducts {
        data = typeof data === 'object' ? data : {};
        let result = new TransferInProducts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferInProduct"] = this.transferInProduct;
        data["transferInLotNumber"] = this.transferInLotNumber;
        data["transferInQty"] = this.transferInQty;
        data["transferInCorrectionType"] = this.transferInCorrectionType;
        return data; 
    }

    clone(): TransferInProducts {
        const json = this.toJSON();
        let result = new TransferInProducts();
        result.init(json);
        return result;
    }
}

export interface ITransferInProducts {
    transferInProduct?: string | undefined;
    transferInLotNumber?: string | undefined;
    transferInQty?: string | undefined;
    transferInCorrectionType?: string | undefined;
}

export class Comments implements IComments {
    comment?: string | undefined;
    commentType?: string | undefined;
    commentSource?: string | undefined;
    commentVisibility?: string | undefined;
    commentIncludedOnReconReport?: boolean;
    commentAuthor?: string | undefined;
    commentDate?: Date;
    commentFile?: string | undefined;

    constructor(data?: IComments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"];
            this.commentType = _data["commentType"];
            this.commentSource = _data["commentSource"];
            this.commentVisibility = _data["commentVisibility"];
            this.commentIncludedOnReconReport = _data["commentIncludedOnReconReport"];
            this.commentAuthor = _data["commentAuthor"];
            this.commentDate = _data["commentDate"] ? new Date(_data["commentDate"].toString()) : <any>undefined;
            this.commentFile = _data["commentFile"];
        }
    }

    static fromJS(data: any): Comments {
        data = typeof data === 'object' ? data : {};
        let result = new Comments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["commentType"] = this.commentType;
        data["commentSource"] = this.commentSource;
        data["commentVisibility"] = this.commentVisibility;
        data["commentIncludedOnReconReport"] = this.commentIncludedOnReconReport;
        data["commentAuthor"] = this.commentAuthor;
        data["commentDate"] = this.commentDate ? this.commentDate.toISOString() : <any>undefined;
        data["commentFile"] = this.commentFile;
        return data; 
    }

    clone(): Comments {
        const json = this.toJSON();
        let result = new Comments();
        result.init(json);
        return result;
    }
}

export interface IComments {
    comment?: string | undefined;
    commentType?: string | undefined;
    commentSource?: string | undefined;
    commentVisibility?: string | undefined;
    commentIncludedOnReconReport?: boolean;
    commentAuthor?: string | undefined;
    commentDate?: Date;
    commentFile?: string | undefined;
}

export class TransferOutFooterInformation implements ITransferOutFooterInformation {
    scanDate?: Date;
    verifierID?: string | undefined;
    verifiedDate?: Date;
    status?: string | undefined;
    source?: string | undefined;
    deviceTimeStamp?: Date;
    createDate?: Date;
    creatorID?: string | undefined;
    lastUpdateDate?: Date;
    lastUpdater?: string | undefined;

    constructor(data?: ITransferOutFooterInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scanDate = _data["scanDate"] ? new Date(_data["scanDate"].toString()) : <any>undefined;
            this.verifierID = _data["verifierID"];
            this.verifiedDate = _data["verifiedDate"] ? new Date(_data["verifiedDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.source = _data["source"];
            this.deviceTimeStamp = _data["deviceTimeStamp"] ? new Date(_data["deviceTimeStamp"].toString()) : <any>undefined;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.creatorID = _data["creatorID"];
            this.lastUpdateDate = _data["lastUpdateDate"] ? new Date(_data["lastUpdateDate"].toString()) : <any>undefined;
            this.lastUpdater = _data["lastUpdater"];
        }
    }

    static fromJS(data: any): TransferOutFooterInformation {
        data = typeof data === 'object' ? data : {};
        let result = new TransferOutFooterInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scanDate"] = this.scanDate ? this.scanDate.toISOString() : <any>undefined;
        data["verifierID"] = this.verifierID;
        data["verifiedDate"] = this.verifiedDate ? this.verifiedDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["source"] = this.source;
        data["deviceTimeStamp"] = this.deviceTimeStamp ? this.deviceTimeStamp.toISOString() : <any>undefined;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["creatorID"] = this.creatorID;
        data["lastUpdateDate"] = this.lastUpdateDate ? this.lastUpdateDate.toISOString() : <any>undefined;
        data["lastUpdater"] = this.lastUpdater;
        return data; 
    }

    clone(): TransferOutFooterInformation {
        const json = this.toJSON();
        let result = new TransferOutFooterInformation();
        result.init(json);
        return result;
    }
}

export interface ITransferOutFooterInformation {
    scanDate?: Date;
    verifierID?: string | undefined;
    verifiedDate?: Date;
    status?: string | undefined;
    source?: string | undefined;
    deviceTimeStamp?: Date;
    createDate?: Date;
    creatorID?: string | undefined;
    lastUpdateDate?: Date;
    lastUpdater?: string | undefined;
}

export class TransferInFooterInformation implements ITransferInFooterInformation {
    scanDate?: Date;
    verifierID?: string | undefined;
    verifiedDate?: Date;
    status?: string | undefined;
    batchNumber?: string | undefined;
    versionNumber?: string | undefined;
    source?: string | undefined;
    deviceTimeStamp?: Date;
    createDate?: Date;
    creatorID?: string | undefined;
    lastUpdateDate?: Date;
    lastUpdater?: string | undefined;

    constructor(data?: ITransferInFooterInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scanDate = _data["scanDate"] ? new Date(_data["scanDate"].toString()) : <any>undefined;
            this.verifierID = _data["verifierID"];
            this.verifiedDate = _data["verifiedDate"] ? new Date(_data["verifiedDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.batchNumber = _data["batchNumber"];
            this.versionNumber = _data["versionNumber"];
            this.source = _data["source"];
            this.deviceTimeStamp = _data["deviceTimeStamp"] ? new Date(_data["deviceTimeStamp"].toString()) : <any>undefined;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.creatorID = _data["creatorID"];
            this.lastUpdateDate = _data["lastUpdateDate"] ? new Date(_data["lastUpdateDate"].toString()) : <any>undefined;
            this.lastUpdater = _data["lastUpdater"];
        }
    }

    static fromJS(data: any): TransferInFooterInformation {
        data = typeof data === 'object' ? data : {};
        let result = new TransferInFooterInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scanDate"] = this.scanDate ? this.scanDate.toISOString() : <any>undefined;
        data["verifierID"] = this.verifierID;
        data["verifiedDate"] = this.verifiedDate ? this.verifiedDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["batchNumber"] = this.batchNumber;
        data["versionNumber"] = this.versionNumber;
        data["source"] = this.source;
        data["deviceTimeStamp"] = this.deviceTimeStamp ? this.deviceTimeStamp.toISOString() : <any>undefined;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["creatorID"] = this.creatorID;
        data["lastUpdateDate"] = this.lastUpdateDate ? this.lastUpdateDate.toISOString() : <any>undefined;
        data["lastUpdater"] = this.lastUpdater;
        return data; 
    }

    clone(): TransferInFooterInformation {
        const json = this.toJSON();
        let result = new TransferInFooterInformation();
        result.init(json);
        return result;
    }
}

export interface ITransferInFooterInformation {
    scanDate?: Date;
    verifierID?: string | undefined;
    verifiedDate?: Date;
    status?: string | undefined;
    batchNumber?: string | undefined;
    versionNumber?: string | undefined;
    source?: string | undefined;
    deviceTimeStamp?: Date;
    createDate?: Date;
    creatorID?: string | undefined;
    lastUpdateDate?: Date;
    lastUpdater?: string | undefined;
}

export class HandCarryTransferInformation implements IHandCarryTransferInformation {
    trasactionType?: string | undefined;
    transferStatus?: string | undefined;
    transferLinkStatus?: string | undefined;
    confirmationNumber?: string | undefined;
    transferOutInformation?: TransferOutInformation;
    transferInInformation?: TransferInInformation;
    transferOutProducts?: TransferOutProducts;
    transferInProducts?: TransferInProducts;
    comments?: Comments;
    transferOutFooterInformation?: TransferOutFooterInformation;
    transferInFooterInformation?: TransferInFooterInformation;

    constructor(data?: IHandCarryTransferInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trasactionType = _data["trasactionType"];
            this.transferStatus = _data["transferStatus"];
            this.transferLinkStatus = _data["transferLinkStatus"];
            this.confirmationNumber = _data["confirmationNumber"];
            this.transferOutInformation = _data["transferOutInformation"] ? TransferOutInformation.fromJS(_data["transferOutInformation"]) : <any>undefined;
            this.transferInInformation = _data["transferInInformation"] ? TransferInInformation.fromJS(_data["transferInInformation"]) : <any>undefined;
            this.transferOutProducts = _data["transferOutProducts"] ? TransferOutProducts.fromJS(_data["transferOutProducts"]) : <any>undefined;
            this.transferInProducts = _data["transferInProducts"] ? TransferInProducts.fromJS(_data["transferInProducts"]) : <any>undefined;
            this.comments = _data["comments"] ? Comments.fromJS(_data["comments"]) : <any>undefined;
            this.transferOutFooterInformation = _data["transferOutFooterInformation"] ? TransferOutFooterInformation.fromJS(_data["transferOutFooterInformation"]) : <any>undefined;
            this.transferInFooterInformation = _data["transferInFooterInformation"] ? TransferInFooterInformation.fromJS(_data["transferInFooterInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HandCarryTransferInformation {
        data = typeof data === 'object' ? data : {};
        let result = new HandCarryTransferInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trasactionType"] = this.trasactionType;
        data["transferStatus"] = this.transferStatus;
        data["transferLinkStatus"] = this.transferLinkStatus;
        data["confirmationNumber"] = this.confirmationNumber;
        data["transferOutInformation"] = this.transferOutInformation ? this.transferOutInformation.toJSON() : <any>undefined;
        data["transferInInformation"] = this.transferInInformation ? this.transferInInformation.toJSON() : <any>undefined;
        data["transferOutProducts"] = this.transferOutProducts ? this.transferOutProducts.toJSON() : <any>undefined;
        data["transferInProducts"] = this.transferInProducts ? this.transferInProducts.toJSON() : <any>undefined;
        data["comments"] = this.comments ? this.comments.toJSON() : <any>undefined;
        data["transferOutFooterInformation"] = this.transferOutFooterInformation ? this.transferOutFooterInformation.toJSON() : <any>undefined;
        data["transferInFooterInformation"] = this.transferInFooterInformation ? this.transferInFooterInformation.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HandCarryTransferInformation {
        const json = this.toJSON();
        let result = new HandCarryTransferInformation();
        result.init(json);
        return result;
    }
}

export interface IHandCarryTransferInformation {
    trasactionType?: string | undefined;
    transferStatus?: string | undefined;
    transferLinkStatus?: string | undefined;
    confirmationNumber?: string | undefined;
    transferOutInformation?: TransferOutInformation;
    transferInInformation?: TransferInInformation;
    transferOutProducts?: TransferOutProducts;
    transferInProducts?: TransferInProducts;
    comments?: Comments;
    transferOutFooterInformation?: TransferOutFooterInformation;
    transferInFooterInformation?: TransferInFooterInformation;
}

export class TransactionInfo implements ITransactionInfo {
    formStatus?: string | undefined;
    generatedForm?: string | undefined;
    formType?: string | undefined;
    dateCalledOrChangeAwareness?: string | undefined;
    correctionTypes?: string | undefined;
    dateFormGenerated?: string | undefined;
    dateFormEmailedToEmployee?: string | undefined;
    daysBetweenTransactionsAndAwareness?: string | undefined;
    escalationNeeded?: boolean;
    responseDueDate?: string | undefined;
    extendedResponseDueDate?: string | undefined;

    constructor(data?: ITransactionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStatus = _data["formStatus"];
            this.generatedForm = _data["generatedForm"];
            this.formType = _data["formType"];
            this.dateCalledOrChangeAwareness = _data["dateCalledOrChangeAwareness"];
            this.correctionTypes = _data["correctionTypes"];
            this.dateFormGenerated = _data["dateFormGenerated"];
            this.dateFormEmailedToEmployee = _data["dateFormEmailedToEmployee"];
            this.daysBetweenTransactionsAndAwareness = _data["daysBetweenTransactionsAndAwareness"];
            this.escalationNeeded = _data["escalationNeeded"];
            this.responseDueDate = _data["responseDueDate"];
            this.extendedResponseDueDate = _data["extendedResponseDueDate"];
        }
    }

    static fromJS(data: any): TransactionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStatus"] = this.formStatus;
        data["generatedForm"] = this.generatedForm;
        data["formType"] = this.formType;
        data["dateCalledOrChangeAwareness"] = this.dateCalledOrChangeAwareness;
        data["correctionTypes"] = this.correctionTypes;
        data["dateFormGenerated"] = this.dateFormGenerated;
        data["dateFormEmailedToEmployee"] = this.dateFormEmailedToEmployee;
        data["daysBetweenTransactionsAndAwareness"] = this.daysBetweenTransactionsAndAwareness;
        data["escalationNeeded"] = this.escalationNeeded;
        data["responseDueDate"] = this.responseDueDate;
        data["extendedResponseDueDate"] = this.extendedResponseDueDate;
        return data; 
    }

    clone(): TransactionInfo {
        const json = this.toJSON();
        let result = new TransactionInfo();
        result.init(json);
        return result;
    }
}

export interface ITransactionInfo {
    formStatus?: string | undefined;
    generatedForm?: string | undefined;
    formType?: string | undefined;
    dateCalledOrChangeAwareness?: string | undefined;
    correctionTypes?: string | undefined;
    dateFormGenerated?: string | undefined;
    dateFormEmailedToEmployee?: string | undefined;
    daysBetweenTransactionsAndAwareness?: string | undefined;
    escalationNeeded?: boolean;
    responseDueDate?: string | undefined;
    extendedResponseDueDate?: string | undefined;
}

export class ResponseForm implements IResponseForm {
    responseform?: string | undefined;
    formReceivedDate?: Date;
    formStatus?: string | undefined;
    extendedResponseDueDate?: Date;

    constructor(data?: IResponseForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseform = _data["responseform"];
            this.formReceivedDate = _data["formReceivedDate"] ? new Date(_data["formReceivedDate"].toString()) : <any>undefined;
            this.formStatus = _data["formStatus"];
            this.extendedResponseDueDate = _data["extendedResponseDueDate"] ? new Date(_data["extendedResponseDueDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseForm {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseform"] = this.responseform;
        data["formReceivedDate"] = this.formReceivedDate ? this.formReceivedDate.toISOString() : <any>undefined;
        data["formStatus"] = this.formStatus;
        data["extendedResponseDueDate"] = this.extendedResponseDueDate ? this.extendedResponseDueDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ResponseForm {
        const json = this.toJSON();
        let result = new ResponseForm();
        result.init(json);
        return result;
    }
}

export interface IResponseForm {
    responseform?: string | undefined;
    formReceivedDate?: Date;
    formStatus?: string | undefined;
    extendedResponseDueDate?: Date;
}

export class EmployeeInformation implements IEmployeeInformation {
    name?: string | undefined;
    repId?: string | undefined;
    territoryCode?: string | undefined;

    constructor(data?: IEmployeeInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.repId = _data["repId"];
            this.territoryCode = _data["territoryCode"];
        }
    }

    static fromJS(data: any): EmployeeInformation {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["repId"] = this.repId;
        data["territoryCode"] = this.territoryCode;
        return data; 
    }

    clone(): EmployeeInformation {
        const json = this.toJSON();
        let result = new EmployeeInformation();
        result.init(json);
        return result;
    }
}

export interface IEmployeeInformation {
    name?: string | undefined;
    repId?: string | undefined;
    territoryCode?: string | undefined;
}

export class ProductDto implements IProductDto {
    productName?: string | undefined;
    lotNumber?: string | undefined;
    disbursedQty?: string | undefined;
    correctionType?: string | undefined;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productName = _data["productName"];
            this.lotNumber = _data["lotNumber"];
            this.disbursedQty = _data["disbursedQty"];
            this.correctionType = _data["correctionType"];
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productName"] = this.productName;
        data["lotNumber"] = this.lotNumber;
        data["disbursedQty"] = this.disbursedQty;
        data["correctionType"] = this.correctionType;
        return data; 
    }

    clone(): ProductDto {
        const json = this.toJSON();
        let result = new ProductDto();
        result.init(json);
        return result;
    }
}

export interface IProductDto {
    productName?: string | undefined;
    lotNumber?: string | undefined;
    disbursedQty?: string | undefined;
    correctionType?: string | undefined;
}

export class PractitionerInformation implements IPractitionerInformation {
    name?: string | undefined;
    sampleable?: boolean;
    addressId?: string | undefined;
    accountId?: string | undefined;
    meNumber?: string | undefined;
    npiNumber?: string | undefined;
    imsNumber?: string | undefined;
    stateLicenseNumber?: string | undefined;
    stateLicenseExpiryDate?: string | undefined;
    deaNumber?: string | undefined;
    deaExpiryDate?: string | undefined;
    primaryDesignation?: string | undefined;
    secondaryDesignation?: string | undefined;
    floridaRegistration?: boolean;
    alternativePractitionerId?: string | undefined;
    primarySpeciality?: string | undefined;
    secondarySpeciality?: string | undefined;

    constructor(data?: IPractitionerInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.sampleable = _data["sampleable"];
            this.addressId = _data["addressId"];
            this.accountId = _data["accountId"];
            this.meNumber = _data["meNumber"];
            this.npiNumber = _data["npiNumber"];
            this.imsNumber = _data["imsNumber"];
            this.stateLicenseNumber = _data["stateLicenseNumber"];
            this.stateLicenseExpiryDate = _data["stateLicenseExpiryDate"];
            this.deaNumber = _data["deaNumber"];
            this.deaExpiryDate = _data["deaExpiryDate"];
            this.primaryDesignation = _data["primaryDesignation"];
            this.secondaryDesignation = _data["secondaryDesignation"];
            this.floridaRegistration = _data["floridaRegistration"];
            this.alternativePractitionerId = _data["alternativePractitionerId"];
            this.primarySpeciality = _data["primarySpeciality"];
            this.secondarySpeciality = _data["secondarySpeciality"];
        }
    }

    static fromJS(data: any): PractitionerInformation {
        data = typeof data === 'object' ? data : {};
        let result = new PractitionerInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sampleable"] = this.sampleable;
        data["addressId"] = this.addressId;
        data["accountId"] = this.accountId;
        data["meNumber"] = this.meNumber;
        data["npiNumber"] = this.npiNumber;
        data["imsNumber"] = this.imsNumber;
        data["stateLicenseNumber"] = this.stateLicenseNumber;
        data["stateLicenseExpiryDate"] = this.stateLicenseExpiryDate;
        data["deaNumber"] = this.deaNumber;
        data["deaExpiryDate"] = this.deaExpiryDate;
        data["primaryDesignation"] = this.primaryDesignation;
        data["secondaryDesignation"] = this.secondaryDesignation;
        data["floridaRegistration"] = this.floridaRegistration;
        data["alternativePractitionerId"] = this.alternativePractitionerId;
        data["primarySpeciality"] = this.primarySpeciality;
        data["secondarySpeciality"] = this.secondarySpeciality;
        return data; 
    }

    clone(): PractitionerInformation {
        const json = this.toJSON();
        let result = new PractitionerInformation();
        result.init(json);
        return result;
    }
}

export interface IPractitionerInformation {
    name?: string | undefined;
    sampleable?: boolean;
    addressId?: string | undefined;
    accountId?: string | undefined;
    meNumber?: string | undefined;
    npiNumber?: string | undefined;
    imsNumber?: string | undefined;
    stateLicenseNumber?: string | undefined;
    stateLicenseExpiryDate?: string | undefined;
    deaNumber?: string | undefined;
    deaExpiryDate?: string | undefined;
    primaryDesignation?: string | undefined;
    secondaryDesignation?: string | undefined;
    floridaRegistration?: boolean;
    alternativePractitionerId?: string | undefined;
    primarySpeciality?: string | undefined;
    secondarySpeciality?: string | undefined;
}

export class HandCarryDisbursementDetail implements IHandCarryDisbursementDetail {
    transactionType?: string | undefined;
    transactionId?: string | undefined;
    docNumber?: string | undefined;
    paperRefNumber?: string | undefined;
    callDate?: Date;
    validForReconcilation?: boolean;
    practitionerSigned?: boolean;
    practitionerSignatureErrType?: string | undefined;
    crossoutOnForm?: boolean;
    lostCall?: boolean;
    transactionInformation?: TransactionInfo;
    responseForms?: ResponseForm[] | undefined;
    employeeInformation?: EmployeeInformation;
    product?: ProductDto[] | undefined;
    comments?: Comments;
    practitionerInformation?: PractitionerInformation;

    constructor(data?: IHandCarryDisbursementDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionType = _data["transactionType"];
            this.transactionId = _data["transactionId"];
            this.docNumber = _data["docNumber"];
            this.paperRefNumber = _data["paperRefNumber"];
            this.callDate = _data["callDate"] ? new Date(_data["callDate"].toString()) : <any>undefined;
            this.validForReconcilation = _data["validForReconcilation"];
            this.practitionerSigned = _data["practitionerSigned"];
            this.practitionerSignatureErrType = _data["practitionerSignatureErrType"];
            this.crossoutOnForm = _data["crossoutOnForm"];
            this.lostCall = _data["lostCall"];
            this.transactionInformation = _data["transactionInformation"] ? TransactionInfo.fromJS(_data["transactionInformation"]) : <any>undefined;
            if (Array.isArray(_data["responseForms"])) {
                this.responseForms = [] as any;
                for (let item of _data["responseForms"])
                    this.responseForms!.push(ResponseForm.fromJS(item));
            }
            this.employeeInformation = _data["employeeInformation"] ? EmployeeInformation.fromJS(_data["employeeInformation"]) : <any>undefined;
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product!.push(ProductDto.fromJS(item));
            }
            this.comments = _data["comments"] ? Comments.fromJS(_data["comments"]) : <any>undefined;
            this.practitionerInformation = _data["practitionerInformation"] ? PractitionerInformation.fromJS(_data["practitionerInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HandCarryDisbursementDetail {
        data = typeof data === 'object' ? data : {};
        let result = new HandCarryDisbursementDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionType"] = this.transactionType;
        data["transactionId"] = this.transactionId;
        data["docNumber"] = this.docNumber;
        data["paperRefNumber"] = this.paperRefNumber;
        data["callDate"] = this.callDate ? this.callDate.toISOString() : <any>undefined;
        data["validForReconcilation"] = this.validForReconcilation;
        data["practitionerSigned"] = this.practitionerSigned;
        data["practitionerSignatureErrType"] = this.practitionerSignatureErrType;
        data["crossoutOnForm"] = this.crossoutOnForm;
        data["lostCall"] = this.lostCall;
        data["transactionInformation"] = this.transactionInformation ? this.transactionInformation.toJSON() : <any>undefined;
        if (Array.isArray(this.responseForms)) {
            data["responseForms"] = [];
            for (let item of this.responseForms)
                data["responseForms"].push(item.toJSON());
        }
        data["employeeInformation"] = this.employeeInformation ? this.employeeInformation.toJSON() : <any>undefined;
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        data["comments"] = this.comments ? this.comments.toJSON() : <any>undefined;
        data["practitionerInformation"] = this.practitionerInformation ? this.practitionerInformation.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HandCarryDisbursementDetail {
        const json = this.toJSON();
        let result = new HandCarryDisbursementDetail();
        result.init(json);
        return result;
    }
}

export interface IHandCarryDisbursementDetail {
    transactionType?: string | undefined;
    transactionId?: string | undefined;
    docNumber?: string | undefined;
    paperRefNumber?: string | undefined;
    callDate?: Date;
    validForReconcilation?: boolean;
    practitionerSigned?: boolean;
    practitionerSignatureErrType?: string | undefined;
    crossoutOnForm?: boolean;
    lostCall?: boolean;
    transactionInformation?: TransactionInfo;
    responseForms?: ResponseForm[] | undefined;
    employeeInformation?: EmployeeInformation;
    product?: ProductDto[] | undefined;
    comments?: Comments;
    practitionerInformation?: PractitionerInformation;
}

export class HealthDto implements IHealthDto {
    isRunning?: boolean;
    timeStamp?: Date;
    description?: string | undefined;

    constructor(data?: IHealthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isRunning = _data["isRunning"];
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): HealthDto {
        data = typeof data === 'object' ? data : {};
        let result = new HealthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isRunning"] = this.isRunning;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data; 
    }

    clone(): HealthDto {
        const json = this.toJSON();
        let result = new HealthDto();
        result.init(json);
        return result;
    }
}

export interface IHealthDto {
    isRunning?: boolean;
    timeStamp?: Date;
    description?: string | undefined;
}

export class HandCarryTransactionSummaryDto implements IHandCarryTransactionSummaryDto {
    id?: string | undefined;
    transactionNumber?: string | undefined;
    image?: string | undefined;
    transactionType?: string | undefined;
    referenceNumber?: string | undefined;
    transactionDate?: Date;
    repId?: string | undefined;
    status?: string | undefined;
    validForRecon?: boolean;
    paperReferenceNumber?: string | undefined;

    constructor(data?: IHandCarryTransactionSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.transactionNumber = _data["transactionNumber"];
            this.image = _data["image"];
            this.transactionType = _data["transactionType"];
            this.referenceNumber = _data["referenceNumber"];
            this.transactionDate = _data["transactionDate"] ? new Date(_data["transactionDate"].toString()) : <any>undefined;
            this.repId = _data["repId"];
            this.status = _data["status"];
            this.validForRecon = _data["validForRecon"];
            this.paperReferenceNumber = _data["paperReferenceNumber"];
        }
    }

    static fromJS(data: any): HandCarryTransactionSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new HandCarryTransactionSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["transactionNumber"] = this.transactionNumber;
        data["image"] = this.image;
        data["transactionType"] = this.transactionType;
        data["referenceNumber"] = this.referenceNumber;
        data["transactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
        data["repId"] = this.repId;
        data["status"] = this.status;
        data["validForRecon"] = this.validForRecon;
        data["paperReferenceNumber"] = this.paperReferenceNumber;
        return data; 
    }

    clone(): HandCarryTransactionSummaryDto {
        const json = this.toJSON();
        let result = new HandCarryTransactionSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IHandCarryTransactionSummaryDto {
    id?: string | undefined;
    transactionNumber?: string | undefined;
    image?: string | undefined;
    transactionType?: string | undefined;
    referenceNumber?: string | undefined;
    transactionDate?: Date;
    repId?: string | undefined;
    status?: string | undefined;
    validForRecon?: boolean;
    paperReferenceNumber?: string | undefined;
}

export class ProgramDto implements IProgramDto {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    jobNumber?: string | undefined;
    clientName?: string | undefined;
    tenantId?: number;
    programTypeClassificationId?: string;
    isMimic?: boolean;
    programStatus?: string;
    programStatusName?: string | undefined;
    siteLiveDate?: string | undefined;
    activatedDate?: string | undefined;
    numberOfSitePromotions?: number;
    url?: string | undefined;
    canonicalName?: string | undefined;

    constructor(data?: IProgramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.jobNumber = _data["jobNumber"];
            this.clientName = _data["clientName"];
            this.tenantId = _data["tenantId"];
            this.programTypeClassificationId = _data["programTypeClassificationId"];
            this.isMimic = _data["isMimic"];
            this.programStatus = _data["programStatus"];
            this.programStatusName = _data["programStatusName"];
            this.siteLiveDate = _data["siteLiveDate"];
            this.activatedDate = _data["activatedDate"];
            this.numberOfSitePromotions = _data["numberOfSitePromotions"];
            this.url = _data["url"];
            this.canonicalName = _data["canonicalName"];
        }
    }

    static fromJS(data: any): ProgramDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["jobNumber"] = this.jobNumber;
        data["clientName"] = this.clientName;
        data["tenantId"] = this.tenantId;
        data["programTypeClassificationId"] = this.programTypeClassificationId;
        data["isMimic"] = this.isMimic;
        data["programStatus"] = this.programStatus;
        data["programStatusName"] = this.programStatusName;
        data["siteLiveDate"] = this.siteLiveDate;
        data["activatedDate"] = this.activatedDate;
        data["numberOfSitePromotions"] = this.numberOfSitePromotions;
        data["url"] = this.url;
        data["canonicalName"] = this.canonicalName;
        return data; 
    }

    clone(): ProgramDto {
        const json = this.toJSON();
        let result = new ProgramDto();
        result.init(json);
        return result;
    }
}

export interface IProgramDto {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    jobNumber?: string | undefined;
    clientName?: string | undefined;
    tenantId?: number;
    programTypeClassificationId?: string;
    isMimic?: boolean;
    programStatus?: string;
    programStatusName?: string | undefined;
    siteLiveDate?: string | undefined;
    activatedDate?: string | undefined;
    numberOfSitePromotions?: number;
    url?: string | undefined;
    canonicalName?: string | undefined;
}

export class TenantInfoDto implements ITenantInfoDto {
    id?: number;
    name?: string | undefined;
    tenancyName?: string | undefined;
    themeUrl?: string | undefined;
    blobStorageContainerName?: string | undefined;
    inMaintenance?: boolean | undefined;
    programs?: ProgramDto[] | undefined;
    daxId?: string | undefined;
    tenantCulture?: string | undefined;
    bannerCarouselImageUrls?: string[] | undefined;

    constructor(data?: ITenantInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.tenancyName = _data["tenancyName"];
            this.themeUrl = _data["themeUrl"];
            this.blobStorageContainerName = _data["blobStorageContainerName"];
            this.inMaintenance = _data["inMaintenance"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramDto.fromJS(item));
            }
            this.daxId = _data["daxId"];
            this.tenantCulture = _data["tenantCulture"];
            if (Array.isArray(_data["bannerCarouselImageUrls"])) {
                this.bannerCarouselImageUrls = [] as any;
                for (let item of _data["bannerCarouselImageUrls"])
                    this.bannerCarouselImageUrls!.push(item);
            }
        }
    }

    static fromJS(data: any): TenantInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["tenancyName"] = this.tenancyName;
        data["themeUrl"] = this.themeUrl;
        data["blobStorageContainerName"] = this.blobStorageContainerName;
        data["inMaintenance"] = this.inMaintenance;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        data["daxId"] = this.daxId;
        data["tenantCulture"] = this.tenantCulture;
        if (Array.isArray(this.bannerCarouselImageUrls)) {
            data["bannerCarouselImageUrls"] = [];
            for (let item of this.bannerCarouselImageUrls)
                data["bannerCarouselImageUrls"].push(item);
        }
        return data; 
    }

    clone(): TenantInfoDto {
        const json = this.toJSON();
        let result = new TenantInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantInfoDto {
    id?: number;
    name?: string | undefined;
    tenancyName?: string | undefined;
    themeUrl?: string | undefined;
    blobStorageContainerName?: string | undefined;
    inMaintenance?: boolean | undefined;
    programs?: ProgramDto[] | undefined;
    daxId?: string | undefined;
    tenantCulture?: string | undefined;
    bannerCarouselImageUrls?: string[] | undefined;
}

export class HandCarryInventory implements IHandCarryInventory {
    id?: string | undefined;
    tenantId?: number;
    reportedDate?: Date;
    productId?: string | undefined;
    lotNumber?: string | undefined;
    lotExpiryDate?: Date;
    repId?: string | undefined;
    territoryId?: string | undefined;
    totalInventory?: number | undefined;
    disbursements?: number | undefined;
    shipments?: number | undefined;
    shipmentAcknowledgements?: number | undefined;
    transferOut?: number | undefined;
    transferIn?: number | undefined;
    returns?: number | undefined;
    returnAcknowledgements?: number | undefined;
    thefts?: number | undefined;
    losses?: number | undefined;
    adjustments?: number | undefined;
    quantityOnHand?: number | undefined;
    rep?: Rep;
    territory?: Territory;
    product?: Product;

    constructor(data?: IHandCarryInventory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.reportedDate = _data["reportedDate"] ? new Date(_data["reportedDate"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.lotNumber = _data["lotNumber"];
            this.lotExpiryDate = _data["lotExpiryDate"] ? new Date(_data["lotExpiryDate"].toString()) : <any>undefined;
            this.repId = _data["repId"];
            this.territoryId = _data["territoryId"];
            this.totalInventory = _data["totalInventory"];
            this.disbursements = _data["disbursements"];
            this.shipments = _data["shipments"];
            this.shipmentAcknowledgements = _data["shipmentAcknowledgements"];
            this.transferOut = _data["transferOut"];
            this.transferIn = _data["transferIn"];
            this.returns = _data["returns"];
            this.returnAcknowledgements = _data["returnAcknowledgements"];
            this.thefts = _data["thefts"];
            this.losses = _data["losses"];
            this.adjustments = _data["adjustments"];
            this.quantityOnHand = _data["quantityOnHand"];
            this.rep = _data["rep"] ? Rep.fromJS(_data["rep"]) : <any>undefined;
            this.territory = _data["territory"] ? Territory.fromJS(_data["territory"]) : <any>undefined;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HandCarryInventory {
        data = typeof data === 'object' ? data : {};
        let result = new HandCarryInventory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["reportedDate"] = this.reportedDate ? this.reportedDate.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["lotNumber"] = this.lotNumber;
        data["lotExpiryDate"] = this.lotExpiryDate ? this.lotExpiryDate.toISOString() : <any>undefined;
        data["repId"] = this.repId;
        data["territoryId"] = this.territoryId;
        data["totalInventory"] = this.totalInventory;
        data["disbursements"] = this.disbursements;
        data["shipments"] = this.shipments;
        data["shipmentAcknowledgements"] = this.shipmentAcknowledgements;
        data["transferOut"] = this.transferOut;
        data["transferIn"] = this.transferIn;
        data["returns"] = this.returns;
        data["returnAcknowledgements"] = this.returnAcknowledgements;
        data["thefts"] = this.thefts;
        data["losses"] = this.losses;
        data["adjustments"] = this.adjustments;
        data["quantityOnHand"] = this.quantityOnHand;
        data["rep"] = this.rep ? this.rep.toJSON() : <any>undefined;
        data["territory"] = this.territory ? this.territory.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HandCarryInventory {
        const json = this.toJSON();
        let result = new HandCarryInventory();
        result.init(json);
        return result;
    }
}

export interface IHandCarryInventory {
    id?: string | undefined;
    tenantId?: number;
    reportedDate?: Date;
    productId?: string | undefined;
    lotNumber?: string | undefined;
    lotExpiryDate?: Date;
    repId?: string | undefined;
    territoryId?: string | undefined;
    totalInventory?: number | undefined;
    disbursements?: number | undefined;
    shipments?: number | undefined;
    shipmentAcknowledgements?: number | undefined;
    transferOut?: number | undefined;
    transferIn?: number | undefined;
    returns?: number | undefined;
    returnAcknowledgements?: number | undefined;
    thefts?: number | undefined;
    losses?: number | undefined;
    adjustments?: number | undefined;
    quantityOnHand?: number | undefined;
    rep?: Rep;
    territory?: Territory;
    product?: Product;
}

export class HandCarryReconciliation implements IHandCarryReconciliation {
    id?: string | undefined;
    tenantId?: number;
    inventoryStartDate?: Date;
    inventoryEndDate?: Date;
    initialReconciliation?: number;
    finalReconciliation?: number;
    category?: string | undefined;
    repId?: string | undefined;
    rep?: Rep;

    constructor(data?: IHandCarryReconciliation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.inventoryStartDate = _data["inventoryStartDate"] ? new Date(_data["inventoryStartDate"].toString()) : <any>undefined;
            this.inventoryEndDate = _data["inventoryEndDate"] ? new Date(_data["inventoryEndDate"].toString()) : <any>undefined;
            this.initialReconciliation = _data["initialReconciliation"];
            this.finalReconciliation = _data["finalReconciliation"];
            this.category = _data["category"];
            this.repId = _data["repId"];
            this.rep = _data["rep"] ? Rep.fromJS(_data["rep"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HandCarryReconciliation {
        data = typeof data === 'object' ? data : {};
        let result = new HandCarryReconciliation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["inventoryStartDate"] = this.inventoryStartDate ? this.inventoryStartDate.toISOString() : <any>undefined;
        data["inventoryEndDate"] = this.inventoryEndDate ? this.inventoryEndDate.toISOString() : <any>undefined;
        data["initialReconciliation"] = this.initialReconciliation;
        data["finalReconciliation"] = this.finalReconciliation;
        data["category"] = this.category;
        data["repId"] = this.repId;
        data["rep"] = this.rep ? this.rep.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HandCarryReconciliation {
        const json = this.toJSON();
        let result = new HandCarryReconciliation();
        result.init(json);
        return result;
    }
}

export interface IHandCarryReconciliation {
    id?: string | undefined;
    tenantId?: number;
    inventoryStartDate?: Date;
    inventoryEndDate?: Date;
    initialReconciliation?: number;
    finalReconciliation?: number;
    category?: string | undefined;
    repId?: string | undefined;
    rep?: Rep;
}

export class RepSignatureAudit implements IRepSignatureAudit {
    signatureAuditListName?: string | undefined;
    auditStartDate?: Date;
    auditEndDate?: Date;
    signatureAuditType?: string | undefined;
    auditReason?: string | undefined;
    outboundSVLDocument?: string | undefined;
    inboundSvlDocument?: string | undefined;
    selectedTransactionCount?: number;
    selectedHcpCount?: number;
    totalTransactionCOunt?: number;
    undeliverable?: number;
    pending?: number;
    positiveResponses?: number;
    negativeResponses?: number;

    constructor(data?: IRepSignatureAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signatureAuditListName = _data["signatureAuditListName"];
            this.auditStartDate = _data["auditStartDate"] ? new Date(_data["auditStartDate"].toString()) : <any>undefined;
            this.auditEndDate = _data["auditEndDate"] ? new Date(_data["auditEndDate"].toString()) : <any>undefined;
            this.signatureAuditType = _data["signatureAuditType"];
            this.auditReason = _data["auditReason"];
            this.outboundSVLDocument = _data["outboundSVLDocument"];
            this.inboundSvlDocument = _data["inboundSvlDocument"];
            this.selectedTransactionCount = _data["selectedTransactionCount"];
            this.selectedHcpCount = _data["selectedHcpCount"];
            this.totalTransactionCOunt = _data["totalTransactionCOunt"];
            this.undeliverable = _data["undeliverable"];
            this.pending = _data["pending"];
            this.positiveResponses = _data["positiveResponses"];
            this.negativeResponses = _data["negativeResponses"];
        }
    }

    static fromJS(data: any): RepSignatureAudit {
        data = typeof data === 'object' ? data : {};
        let result = new RepSignatureAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signatureAuditListName"] = this.signatureAuditListName;
        data["auditStartDate"] = this.auditStartDate ? this.auditStartDate.toISOString() : <any>undefined;
        data["auditEndDate"] = this.auditEndDate ? this.auditEndDate.toISOString() : <any>undefined;
        data["signatureAuditType"] = this.signatureAuditType;
        data["auditReason"] = this.auditReason;
        data["outboundSVLDocument"] = this.outboundSVLDocument;
        data["inboundSvlDocument"] = this.inboundSvlDocument;
        data["selectedTransactionCount"] = this.selectedTransactionCount;
        data["selectedHcpCount"] = this.selectedHcpCount;
        data["totalTransactionCOunt"] = this.totalTransactionCOunt;
        data["undeliverable"] = this.undeliverable;
        data["pending"] = this.pending;
        data["positiveResponses"] = this.positiveResponses;
        data["negativeResponses"] = this.negativeResponses;
        return data; 
    }

    clone(): RepSignatureAudit {
        const json = this.toJSON();
        let result = new RepSignatureAudit();
        result.init(json);
        return result;
    }
}

export interface IRepSignatureAudit {
    signatureAuditListName?: string | undefined;
    auditStartDate?: Date;
    auditEndDate?: Date;
    signatureAuditType?: string | undefined;
    auditReason?: string | undefined;
    outboundSVLDocument?: string | undefined;
    inboundSvlDocument?: string | undefined;
    selectedTransactionCount?: number;
    selectedHcpCount?: number;
    totalTransactionCOunt?: number;
    undeliverable?: number;
    pending?: number;
    positiveResponses?: number;
    negativeResponses?: number;
}

export class Reconciliation implements IReconciliation {
    inventoryStartDate?: Date;
    inventoryEndDate?: Date;
    initialReconciliation?: string | undefined;
    finalReConciliation?: string | undefined;
    analystNotes?: string | undefined;

    constructor(data?: IReconciliation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryStartDate = _data["inventoryStartDate"] ? new Date(_data["inventoryStartDate"].toString()) : <any>undefined;
            this.inventoryEndDate = _data["inventoryEndDate"] ? new Date(_data["inventoryEndDate"].toString()) : <any>undefined;
            this.initialReconciliation = _data["initialReconciliation"];
            this.finalReConciliation = _data["finalReConciliation"];
            this.analystNotes = _data["analystNotes"];
        }
    }

    static fromJS(data: any): Reconciliation {
        data = typeof data === 'object' ? data : {};
        let result = new Reconciliation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryStartDate"] = this.inventoryStartDate ? this.inventoryStartDate.toISOString() : <any>undefined;
        data["inventoryEndDate"] = this.inventoryEndDate ? this.inventoryEndDate.toISOString() : <any>undefined;
        data["initialReconciliation"] = this.initialReconciliation;
        data["finalReConciliation"] = this.finalReConciliation;
        data["analystNotes"] = this.analystNotes;
        return data; 
    }

    clone(): Reconciliation {
        const json = this.toJSON();
        let result = new Reconciliation();
        result.init(json);
        return result;
    }
}

export interface IReconciliation {
    inventoryStartDate?: Date;
    inventoryEndDate?: Date;
    initialReconciliation?: string | undefined;
    finalReConciliation?: string | undefined;
    analystNotes?: string | undefined;
}

export class ReportDefinitionModule implements IReportDefinitionModule {
    id?: string | undefined;
    reportDefinitionId?: string | undefined;
    module?: string | undefined;

    constructor(data?: IReportDefinitionModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reportDefinitionId = _data["reportDefinitionId"];
            this.module = _data["module"];
        }
    }

    static fromJS(data: any): ReportDefinitionModule {
        data = typeof data === 'object' ? data : {};
        let result = new ReportDefinitionModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reportDefinitionId"] = this.reportDefinitionId;
        data["module"] = this.module;
        return data; 
    }

    clone(): ReportDefinitionModule {
        const json = this.toJSON();
        let result = new ReportDefinitionModule();
        result.init(json);
        return result;
    }
}

export interface IReportDefinitionModule {
    id?: string | undefined;
    reportDefinitionId?: string | undefined;
    module?: string | undefined;
}

export class ReportDefinition implements IReportDefinition {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    modules?: ReportDefinitionModule[] | undefined;

    constructor(data?: IReportDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(ReportDefinitionModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ReportDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ReportDefinition {
        const json = this.toJSON();
        let result = new ReportDefinition();
        result.init(json);
        return result;
    }
}

export interface IReportDefinition {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    modules?: ReportDefinitionModule[] | undefined;
}

export class User implements IUser {
    id?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    address1Text?: string | undefined;
    address2Text?: string | undefined;
    address3Text?: string | undefined;
    address4Text?: string | undefined;
    cityName?: string | undefined;
    zipCode?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    phoneNumber?: string | undefined;
    title?: string | undefined;
    phoneExtensionNumber?: string | undefined;
    faxNumber?: string | undefined;
    mobilePhoneNumber?: string | undefined;
    countryCode?: string | undefined;
    stateCode?: string | undefined;
    internalFlag?: boolean;
    lastLoginTime?: Date;
    readonly fullName?: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.address1Text = _data["address1Text"];
            this.address2Text = _data["address2Text"];
            this.address3Text = _data["address3Text"];
            this.address4Text = _data["address4Text"];
            this.cityName = _data["cityName"];
            this.zipCode = _data["zipCode"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.title = _data["title"];
            this.phoneExtensionNumber = _data["phoneExtensionNumber"];
            this.faxNumber = _data["faxNumber"];
            this.mobilePhoneNumber = _data["mobilePhoneNumber"];
            this.countryCode = _data["countryCode"];
            this.stateCode = _data["stateCode"];
            this.internalFlag = _data["internalFlag"];
            this.lastLoginTime = _data["lastLoginTime"] ? new Date(_data["lastLoginTime"].toString()) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["address1Text"] = this.address1Text;
        data["address2Text"] = this.address2Text;
        data["address3Text"] = this.address3Text;
        data["address4Text"] = this.address4Text;
        data["cityName"] = this.cityName;
        data["zipCode"] = this.zipCode;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["title"] = this.title;
        data["phoneExtensionNumber"] = this.phoneExtensionNumber;
        data["faxNumber"] = this.faxNumber;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["countryCode"] = this.countryCode;
        data["stateCode"] = this.stateCode;
        data["internalFlag"] = this.internalFlag;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["fullName"] = this.fullName;
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    id?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    address1Text?: string | undefined;
    address2Text?: string | undefined;
    address3Text?: string | undefined;
    address4Text?: string | undefined;
    cityName?: string | undefined;
    zipCode?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    phoneNumber?: string | undefined;
    title?: string | undefined;
    phoneExtensionNumber?: string | undefined;
    faxNumber?: string | undefined;
    mobilePhoneNumber?: string | undefined;
    countryCode?: string | undefined;
    stateCode?: string | undefined;
    internalFlag?: boolean;
    lastLoginTime?: Date;
    fullName?: string | undefined;
}

export class Report implements IReport {
    id?: string | undefined;
    reportDefinitionId?: string | undefined;
    reportName?: string | undefined;
    attachment?: string | undefined;
    uploadedOn?: Date;
    uploadedByUserId?: string | undefined;
    uploadedByUser?: User;
    reportDefinition?: ReportDefinition;

    constructor(data?: IReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reportDefinitionId = _data["reportDefinitionId"];
            this.reportName = _data["reportName"];
            this.attachment = _data["attachment"];
            this.uploadedOn = _data["uploadedOn"] ? new Date(_data["uploadedOn"].toString()) : <any>undefined;
            this.uploadedByUserId = _data["uploadedByUserId"];
            this.uploadedByUser = _data["uploadedByUser"] ? User.fromJS(_data["uploadedByUser"]) : <any>undefined;
            this.reportDefinition = _data["reportDefinition"] ? ReportDefinition.fromJS(_data["reportDefinition"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Report {
        data = typeof data === 'object' ? data : {};
        let result = new Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reportDefinitionId"] = this.reportDefinitionId;
        data["reportName"] = this.reportName;
        data["attachment"] = this.attachment;
        data["uploadedOn"] = this.uploadedOn ? this.uploadedOn.toISOString() : <any>undefined;
        data["uploadedByUserId"] = this.uploadedByUserId;
        data["uploadedByUser"] = this.uploadedByUser ? this.uploadedByUser.toJSON() : <any>undefined;
        data["reportDefinition"] = this.reportDefinition ? this.reportDefinition.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Report {
        const json = this.toJSON();
        let result = new Report();
        result.init(json);
        return result;
    }
}

export interface IReport {
    id?: string | undefined;
    reportDefinitionId?: string | undefined;
    reportName?: string | undefined;
    attachment?: string | undefined;
    uploadedOn?: Date;
    uploadedByUserId?: string | undefined;
    uploadedByUser?: User;
    reportDefinition?: ReportDefinition;
}

export class InventoryShippedByItemReportDto implements IInventoryShippedByItemReportDto {
    jobId?: string | undefined;
    productCode?: string | undefined;
    productName?: string | undefined;
    lot?: string | undefined;
    lotExpirationDate?: Date | undefined;
    uom?: string | undefined;
    quantityShipped?: number | undefined;

    constructor(data?: IInventoryShippedByItemReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.lot = _data["lot"];
            this.lotExpirationDate = _data["lotExpirationDate"] ? new Date(_data["lotExpirationDate"].toString()) : <any>undefined;
            this.uom = _data["uom"];
            this.quantityShipped = _data["quantityShipped"];
        }
    }

    static fromJS(data: any): InventoryShippedByItemReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryShippedByItemReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["lot"] = this.lot;
        data["lotExpirationDate"] = this.lotExpirationDate ? this.lotExpirationDate.toISOString() : <any>undefined;
        data["uom"] = this.uom;
        data["quantityShipped"] = this.quantityShipped;
        return data; 
    }

    clone(): InventoryShippedByItemReportDto {
        const json = this.toJSON();
        let result = new InventoryShippedByItemReportDto();
        result.init(json);
        return result;
    }
}

export interface IInventoryShippedByItemReportDto {
    jobId?: string | undefined;
    productCode?: string | undefined;
    productName?: string | undefined;
    lot?: string | undefined;
    lotExpirationDate?: Date | undefined;
    uom?: string | undefined;
    quantityShipped?: number | undefined;
}

export class AocReportDto implements IAocReportDto {
    repId?: string | undefined;
    repFirstName?: string | undefined;
    repLastName?: string | undefined;
    territoryCode?: string | undefined;
    requestorFirstName?: string | undefined;
    requestorLastName?: string | undefined;
    requestorSuffix?: string | undefined;
    professionalDesignation?: string | undefined;
    requestorAddressLine1?: string | undefined;
    requestorAddressLine2?: string | undefined;
    requestorCity?: string | undefined;
    requestorState?: string | undefined;
    requestorZipCode?: string | undefined;
    requestorPhoneNumber?: string | undefined;
    recipientFirstName?: string | undefined;
    recipientLastName?: string | undefined;
    recipientSuffix?: string | undefined;
    recipientAddressLine1?: string | undefined;
    recipientAddressLine2?: string | undefined;
    recipientCity?: string | undefined;
    recipientState?: string | undefined;
    recipientZipCode?: string | undefined;
    orderNumber?: string | undefined;
    orderShipDate?: string | undefined;
    aocFollowUpLetter1?: Date | undefined;
    aocFollowUpLetter2?: Date | undefined;
    aocFollowUpLetter3?: Date | undefined;

    constructor(data?: IAocReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repId = _data["repId"];
            this.repFirstName = _data["repFirstName"];
            this.repLastName = _data["repLastName"];
            this.territoryCode = _data["territoryCode"];
            this.requestorFirstName = _data["requestorFirstName"];
            this.requestorLastName = _data["requestorLastName"];
            this.requestorSuffix = _data["requestorSuffix"];
            this.professionalDesignation = _data["professionalDesignation"];
            this.requestorAddressLine1 = _data["requestorAddressLine1"];
            this.requestorAddressLine2 = _data["requestorAddressLine2"];
            this.requestorCity = _data["requestorCity"];
            this.requestorState = _data["requestorState"];
            this.requestorZipCode = _data["requestorZipCode"];
            this.requestorPhoneNumber = _data["requestorPhoneNumber"];
            this.recipientFirstName = _data["recipientFirstName"];
            this.recipientLastName = _data["recipientLastName"];
            this.recipientSuffix = _data["recipientSuffix"];
            this.recipientAddressLine1 = _data["recipientAddressLine1"];
            this.recipientAddressLine2 = _data["recipientAddressLine2"];
            this.recipientCity = _data["recipientCity"];
            this.recipientState = _data["recipientState"];
            this.recipientZipCode = _data["recipientZipCode"];
            this.orderNumber = _data["orderNumber"];
            this.orderShipDate = _data["orderShipDate"];
            this.aocFollowUpLetter1 = _data["aocFollowUpLetter1"] ? new Date(_data["aocFollowUpLetter1"].toString()) : <any>undefined;
            this.aocFollowUpLetter2 = _data["aocFollowUpLetter2"] ? new Date(_data["aocFollowUpLetter2"].toString()) : <any>undefined;
            this.aocFollowUpLetter3 = _data["aocFollowUpLetter3"] ? new Date(_data["aocFollowUpLetter3"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AocReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new AocReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repId"] = this.repId;
        data["repFirstName"] = this.repFirstName;
        data["repLastName"] = this.repLastName;
        data["territoryCode"] = this.territoryCode;
        data["requestorFirstName"] = this.requestorFirstName;
        data["requestorLastName"] = this.requestorLastName;
        data["requestorSuffix"] = this.requestorSuffix;
        data["professionalDesignation"] = this.professionalDesignation;
        data["requestorAddressLine1"] = this.requestorAddressLine1;
        data["requestorAddressLine2"] = this.requestorAddressLine2;
        data["requestorCity"] = this.requestorCity;
        data["requestorState"] = this.requestorState;
        data["requestorZipCode"] = this.requestorZipCode;
        data["requestorPhoneNumber"] = this.requestorPhoneNumber;
        data["recipientFirstName"] = this.recipientFirstName;
        data["recipientLastName"] = this.recipientLastName;
        data["recipientSuffix"] = this.recipientSuffix;
        data["recipientAddressLine1"] = this.recipientAddressLine1;
        data["recipientAddressLine2"] = this.recipientAddressLine2;
        data["recipientCity"] = this.recipientCity;
        data["recipientState"] = this.recipientState;
        data["recipientZipCode"] = this.recipientZipCode;
        data["orderNumber"] = this.orderNumber;
        data["orderShipDate"] = this.orderShipDate;
        data["aocFollowUpLetter1"] = this.aocFollowUpLetter1 ? this.aocFollowUpLetter1.toISOString() : <any>undefined;
        data["aocFollowUpLetter2"] = this.aocFollowUpLetter2 ? this.aocFollowUpLetter2.toISOString() : <any>undefined;
        data["aocFollowUpLetter3"] = this.aocFollowUpLetter3 ? this.aocFollowUpLetter3.toISOString() : <any>undefined;
        return data; 
    }

    clone(): AocReportDto {
        const json = this.toJSON();
        let result = new AocReportDto();
        result.init(json);
        return result;
    }
}

export interface IAocReportDto {
    repId?: string | undefined;
    repFirstName?: string | undefined;
    repLastName?: string | undefined;
    territoryCode?: string | undefined;
    requestorFirstName?: string | undefined;
    requestorLastName?: string | undefined;
    requestorSuffix?: string | undefined;
    professionalDesignation?: string | undefined;
    requestorAddressLine1?: string | undefined;
    requestorAddressLine2?: string | undefined;
    requestorCity?: string | undefined;
    requestorState?: string | undefined;
    requestorZipCode?: string | undefined;
    requestorPhoneNumber?: string | undefined;
    recipientFirstName?: string | undefined;
    recipientLastName?: string | undefined;
    recipientSuffix?: string | undefined;
    recipientAddressLine1?: string | undefined;
    recipientAddressLine2?: string | undefined;
    recipientCity?: string | undefined;
    recipientState?: string | undefined;
    recipientZipCode?: string | undefined;
    orderNumber?: string | undefined;
    orderShipDate?: string | undefined;
    aocFollowUpLetter1?: Date | undefined;
    aocFollowUpLetter2?: Date | undefined;
    aocFollowUpLetter3?: Date | undefined;
}

export class State implements IState {
    id?: string | undefined;
    stateName?: string | undefined;
    countryId?: string | undefined;
    internalStateCode?: string | undefined;
    isDistrict?: boolean | undefined;
    exemptionLabel?: string | undefined;
    helpText?: string | undefined;
    isSANExists?: boolean | undefined;

    constructor(data?: IState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.stateName = _data["stateName"];
            this.countryId = _data["countryId"];
            this.internalStateCode = _data["internalStateCode"];
            this.isDistrict = _data["isDistrict"];
            this.exemptionLabel = _data["exemptionLabel"];
            this.helpText = _data["helpText"];
            this.isSANExists = _data["isSANExists"];
        }
    }

    static fromJS(data: any): State {
        data = typeof data === 'object' ? data : {};
        let result = new State();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stateName"] = this.stateName;
        data["countryId"] = this.countryId;
        data["internalStateCode"] = this.internalStateCode;
        data["isDistrict"] = this.isDistrict;
        data["exemptionLabel"] = this.exemptionLabel;
        data["helpText"] = this.helpText;
        data["isSANExists"] = this.isSANExists;
        return data; 
    }

    clone(): State {
        const json = this.toJSON();
        let result = new State();
        result.init(json);
        return result;
    }
}

export interface IState {
    id?: string | undefined;
    stateName?: string | undefined;
    countryId?: string | undefined;
    internalStateCode?: string | undefined;
    isDistrict?: boolean | undefined;
    exemptionLabel?: string | undefined;
    helpText?: string | undefined;
    isSANExists?: boolean | undefined;
}

export class TaskNote implements ITaskNote {
    id?: string | undefined;
    taskId?: string | undefined;
    description?: string | undefined;
    loggedDate?: Date;
    notesOwnerId?: string | undefined;
    notesOwner?: User;

    constructor(data?: ITaskNote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.taskId = _data["taskId"];
            this.description = _data["description"];
            this.loggedDate = _data["loggedDate"] ? new Date(_data["loggedDate"].toString()) : <any>undefined;
            this.notesOwnerId = _data["notesOwnerId"];
            this.notesOwner = _data["notesOwner"] ? User.fromJS(_data["notesOwner"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TaskNote {
        data = typeof data === 'object' ? data : {};
        let result = new TaskNote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["taskId"] = this.taskId;
        data["description"] = this.description;
        data["loggedDate"] = this.loggedDate ? this.loggedDate.toISOString() : <any>undefined;
        data["notesOwnerId"] = this.notesOwnerId;
        data["notesOwner"] = this.notesOwner ? this.notesOwner.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TaskNote {
        const json = this.toJSON();
        let result = new TaskNote();
        result.init(json);
        return result;
    }
}

export interface ITaskNote {
    id?: string | undefined;
    taskId?: string | undefined;
    description?: string | undefined;
    loggedDate?: Date;
    notesOwnerId?: string | undefined;
    notesOwner?: User;
}

export class Task implements ITask {
    id?: string | undefined;
    description?: string | undefined;
    priority?: string | undefined;
    status?: string | undefined;
    lineOfBusiness?: string | undefined;
    assignedToId?: string | undefined;
    requestorId?: string | undefined;
    creationTime?: Date;
    requestedCompletionDate?: Date | undefined;
    completionDate?: Date | undefined;
    notesCount?: number;
    assignedTo?: User;
    requestor?: User;
    taskNotes?: TaskNote[] | undefined;
    notesOwner?: User;

    constructor(data?: ITask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.priority = _data["priority"];
            this.status = _data["status"];
            this.lineOfBusiness = _data["lineOfBusiness"];
            this.assignedToId = _data["assignedToId"];
            this.requestorId = _data["requestorId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.requestedCompletionDate = _data["requestedCompletionDate"] ? new Date(_data["requestedCompletionDate"].toString()) : <any>undefined;
            this.completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            this.notesCount = _data["notesCount"];
            this.assignedTo = _data["assignedTo"] ? User.fromJS(_data["assignedTo"]) : <any>undefined;
            this.requestor = _data["requestor"] ? User.fromJS(_data["requestor"]) : <any>undefined;
            if (Array.isArray(_data["taskNotes"])) {
                this.taskNotes = [] as any;
                for (let item of _data["taskNotes"])
                    this.taskNotes!.push(TaskNote.fromJS(item));
            }
            this.notesOwner = _data["notesOwner"] ? User.fromJS(_data["notesOwner"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Task {
        data = typeof data === 'object' ? data : {};
        let result = new Task();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["priority"] = this.priority;
        data["status"] = this.status;
        data["lineOfBusiness"] = this.lineOfBusiness;
        data["assignedToId"] = this.assignedToId;
        data["requestorId"] = this.requestorId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["requestedCompletionDate"] = this.requestedCompletionDate ? this.requestedCompletionDate.toISOString() : <any>undefined;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["notesCount"] = this.notesCount;
        data["assignedTo"] = this.assignedTo ? this.assignedTo.toJSON() : <any>undefined;
        data["requestor"] = this.requestor ? this.requestor.toJSON() : <any>undefined;
        if (Array.isArray(this.taskNotes)) {
            data["taskNotes"] = [];
            for (let item of this.taskNotes)
                data["taskNotes"].push(item.toJSON());
        }
        data["notesOwner"] = this.notesOwner ? this.notesOwner.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Task {
        const json = this.toJSON();
        let result = new Task();
        result.init(json);
        return result;
    }
}

export interface ITask {
    id?: string | undefined;
    description?: string | undefined;
    priority?: string | undefined;
    status?: string | undefined;
    lineOfBusiness?: string | undefined;
    assignedToId?: string | undefined;
    requestorId?: string | undefined;
    creationTime?: Date;
    requestedCompletionDate?: Date | undefined;
    completionDate?: Date | undefined;
    notesCount?: number;
    assignedTo?: User;
    requestor?: User;
    taskNotes?: TaskNote[] | undefined;
    notesOwner?: User;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}