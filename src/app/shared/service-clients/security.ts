/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.2.0 (NJsonSchema v10.1.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const SECURITY_API_BASE_URL = new InjectionToken<string>('SECURITY_API_BASE_URL');

export class ServiceBaseConfig {
  public key: string;
}

export class ServiceBase {
  private readonly apiKey: string;
  private readonly apimHeaderName: string = 'Ocp-Apim-Subscription-Key';
  private readonly tenantIdHeaderName: string = 'TenantId';
  private readonly tenantIdLocalStorageKey: string = 'samplicity-dtp-current-client';
  private readonly idTokenKey: string = 'samplicity-id-token';

  constructor(config: ServiceBaseConfig) {
    this.apiKey = config.key;
  }

  protected transformOptions(options: any) {
    let headers: HttpHeaders = options.headers;

    if (this.apiKey) {
      headers = headers.append(this.apimHeaderName, this.apiKey);
    }

    const tenantId = sessionStorage.getItem(this.tenantIdLocalStorageKey);
    if (tenantId) {
      headers = headers.append(this.tenantIdHeaderName, tenantId);
    }

    const token = localStorage.getItem(this.idTokenKey);
    if (token) {
      headers = headers.append('Authorization', 'Bearer ' + token);
    }

    options.headers = headers;

    return Promise.resolve(options);
  }
}

@Injectable()
export class Security extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(ServiceBaseConfig) configuration: ServiceBaseConfig, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(SECURITY_API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param includeInternal (optional) 
     * @return Success
     */
    getPermissions(includeInternal: boolean | null | undefined): Observable<AjaxResponseOfIListOfPermissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetPermissions?";
        if (includeInternal !== undefined && includeInternal !== null)
            url_ += "includeInternal=" + encodeURIComponent("" + includeInternal) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfIListOfPermissionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfIListOfPermissionDto>><any>Observable.throw(response_);
        });
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<AjaxResponseOfIListOfPermissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfIListOfPermissionDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfIListOfPermissionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleById(id: string | null | undefined): Observable<AjaxResponseOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleById?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetRoleById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleById(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetRoleById(response: HttpResponseBase): Observable<AjaxResponseOfRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfRoleDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfRoleDto>(<any>null);
    }

    /**
     * @return Success
     */
    getNewRole(): Observable<AjaxResponseOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetNewRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetNewRole(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewRole(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetNewRole(response: HttpResponseBase): Observable<AjaxResponseOfRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfRoleDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfRoleDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    searchRoles(filter: RoleSearchFilterDto | null | undefined): Observable<AjaxResponseOfPagedResultOfRoleSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/SearchRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearchRoles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchRoles(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfPagedResultOfRoleSearchDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfPagedResultOfRoleSearchDto>><any>Observable.throw(response_);
        });
    }

    protected processSearchRoles(response: HttpResponseBase): Observable<AjaxResponseOfPagedResultOfRoleSearchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfPagedResultOfRoleSearchDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfPagedResultOfRoleSearchDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<AjaxResponseOfIReadOnlyListOfRoleSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetRoles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfIReadOnlyListOfRoleSearchDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfIReadOnlyListOfRoleSearchDto>><any>Observable.throw(response_);
        });
    }

    protected processGetRoles(response: HttpResponseBase): Observable<AjaxResponseOfIReadOnlyListOfRoleSearchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfIReadOnlyListOfRoleSearchDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfIReadOnlyListOfRoleSearchDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    searchActiveUserEmailsForRole(filter: RoleSearchFilterDto | null | undefined): Observable<AjaxResponseOfPagedResultOfActiveUserSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/SearchActiveUserEmailsForRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearchActiveUserEmailsForRole(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchActiveUserEmailsForRole(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfPagedResultOfActiveUserSearchDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfPagedResultOfActiveUserSearchDto>><any>Observable.throw(response_);
        });
    }

    protected processSearchActiveUserEmailsForRole(response: HttpResponseBase): Observable<AjaxResponseOfPagedResultOfActiveUserSearchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfPagedResultOfActiveUserSearchDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfPagedResultOfActiveUserSearchDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    searchPermissionsForRole(filter: RoleSearchFilterDto | null | undefined): Observable<AjaxResponseOfPagedResultOfPermissionSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/SearchPermissionsForRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearchPermissionsForRole(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchPermissionsForRole(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfPagedResultOfPermissionSearchDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfPagedResultOfPermissionSearchDto>><any>Observable.throw(response_);
        });
    }

    protected processSearchPermissionsForRole(response: HttpResponseBase): Observable<AjaxResponseOfPagedResultOfPermissionSearchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfPagedResultOfPermissionSearchDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfPagedResultOfPermissionSearchDto>(<any>null);
    }

    /**
     * @param roleDto (optional) 
     * @return Success
     */
    createRole(roleDto: RoleDto | null | undefined): Observable<AjaxResponseOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreateRole(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processCreateRole(response: HttpResponseBase): Observable<AjaxResponseOfRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfRoleDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfRoleDto>(<any>null);
    }

    /**
     * @param roleDto (optional) 
     * @return Success
     */
    updateRole(roleDto: RoleDto | null | undefined): Observable<AjaxResponseOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/UpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateRole(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<AjaxResponseOfRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfRoleDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfRoleDto>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @return Success
     */
    deleteRole(roleId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (roleId !== undefined && roleId !== null)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteRole(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    getUserAccess(username: string | null | undefined): Observable<AjaxResponseOfUserAccessDto> {
        let url_ = this.baseUrl + "/api/services/app/Security/GetUserAccess?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetUserAccess(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAccess(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfUserAccessDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfUserAccessDto>><any>Observable.throw(response_);
        });
    }

    protected processGetUserAccess(response: HttpResponseBase): Observable<AjaxResponseOfUserAccessDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfUserAccessDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfUserAccessDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    searchUsers(filter: UserSearchFilterDto | null | undefined): Observable<AjaxResponseOfPagedResultOfUserSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/User/SearchUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearchUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchUsers(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfPagedResultOfUserSearchDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfPagedResultOfUserSearchDto>><any>Observable.throw(response_);
        });
    }

    protected processSearchUsers(response: HttpResponseBase): Observable<AjaxResponseOfPagedResultOfUserSearchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfPagedResultOfUserSearchDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfPagedResultOfUserSearchDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    searchClientsForUser(filter: UserClientSearchFilterDto | null | undefined): Observable<AjaxResponseOfPagedResultOfUserClientSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/User/SearchClientsForUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearchClientsForUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchClientsForUser(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfPagedResultOfUserClientSearchDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfPagedResultOfUserClientSearchDto>><any>Observable.throw(response_);
        });
    }

    protected processSearchClientsForUser(response: HttpResponseBase): Observable<AjaxResponseOfPagedResultOfUserClientSearchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfPagedResultOfUserClientSearchDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfPagedResultOfUserClientSearchDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserById(id: string | null | undefined): Observable<AjaxResponseOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserById?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetUserById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfUserDto>><any>Observable.throw(response_);
        });
    }

    protected processGetUserById(response: HttpResponseBase): Observable<AjaxResponseOfUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfUserDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfUserDto>(<any>null);
    }

    /**
     * @param activeDirectoryUserId (optional) 
     * @return Success
     */
    getNewUser(activeDirectoryUserId: string | null | undefined): Observable<AjaxResponseOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetNewUser?";
        if (activeDirectoryUserId !== undefined && activeDirectoryUserId !== null)
            url_ += "activeDirectoryUserId=" + encodeURIComponent("" + activeDirectoryUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetNewUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewUser(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfUserDto>><any>Observable.throw(response_);
        });
    }

    protected processGetNewUser(response: HttpResponseBase): Observable<AjaxResponseOfUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfUserDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfUserDto>(<any>null);
    }

    /**
     * @param userDto (optional) 
     * @return Success
     */
    createUser(userDto: UserDto | null | undefined): Observable<AjaxResponseOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreateUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfUserDto>><any>Observable.throw(response_);
        });
    }

    protected processCreateUser(response: HttpResponseBase): Observable<AjaxResponseOfUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfUserDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfUserDto>(<any>null);
    }

    /**
     * @param userDto (optional) 
     * @return Success
     */
    updateUser(userDto: UserDto | null | undefined): Observable<AjaxResponseOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfUserDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<AjaxResponseOfUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfUserDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfUserDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    searchActiveDirectoryUsers(filter: ActiveDirectoryUserSearchFilterDto | null | undefined): Observable<AjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/User/SearchActiveDirectoryUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearchActiveDirectoryUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchActiveDirectoryUsers(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto>><any>Observable.throw(response_);
        });
    }

    protected processSearchActiveDirectoryUsers(response: HttpResponseBase): Observable<AjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUsers(): Observable<AjaxResponseOfListOfUserLoginDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfListOfUserLoginDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfListOfUserLoginDto>><any>Observable.throw(response_);
        });
    }

    protected processGetUsers(response: HttpResponseBase): Observable<AjaxResponseOfListOfUserLoginDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfListOfUserLoginDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfListOfUserLoginDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUserProfiles(): Observable<AjaxResponseOfListOfUserProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserProfiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetUserProfiles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfiles(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfListOfUserProfileDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfListOfUserProfileDto>><any>Observable.throw(response_);
        });
    }

    protected processGetUserProfiles(response: HttpResponseBase): Observable<AjaxResponseOfListOfUserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfListOfUserProfileDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfListOfUserProfileDto>(<any>null);
    }

    /**
     * @param userLogDto (optional) 
     * @return Success
     */
    logUserSession(userLogDto: UserLogDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/LogUserSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userLogDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processLogUserSession(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogUserSession(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processLogUserSession(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

export class AjaxResponseOfIListOfPermissionDto implements IAjaxResponseOfIListOfPermissionDto {
    result: PermissionDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfIListOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(PermissionDto.fromJS(item));
            }
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfIListOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfIListOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfIListOfPermissionDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfIListOfPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfIListOfPermissionDto {
    result: PermissionDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class PermissionDto implements IPermissionDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    internalSystemFlag: boolean | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.internalSystemFlag = _data["internalSystemFlag"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["internalSystemFlag"] = this.internalSystemFlag;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    internalSystemFlag: boolean | undefined;
}

export class ErrorInfo implements IErrorInfo {
    code: number | undefined;
    message: string | undefined;
    details: string | undefined;
    validationErrors: ValidationErrorInfo[] | undefined;

    constructor(data?: IErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.details = _data["details"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors.push(ValidationErrorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ErrorInfo {
        const json = this.toJSON();
        let result = new ErrorInfo();
        result.init(json);
        return result;
    }
}

export interface IErrorInfo {
    code: number | undefined;
    message: string | undefined;
    details: string | undefined;
    validationErrors: ValidationErrorInfo[] | undefined;
}

export class ValidationErrorInfo implements IValidationErrorInfo {
    message: string | undefined;
    members: string[] | undefined;

    constructor(data?: IValidationErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data; 
    }

    clone(): ValidationErrorInfo {
        const json = this.toJSON();
        let result = new ValidationErrorInfo();
        result.init(json);
        return result;
    }
}

export interface IValidationErrorInfo {
    message: string | undefined;
    members: string[] | undefined;
}

export class AjaxResponseOfRoleDto implements IAjaxResponseOfRoleDto {
    result: RoleDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RoleDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfRoleDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfRoleDto {
    result: RoleDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class RoleDto implements IRoleDto {
    id: string | undefined;
    tenantId: string | undefined;
    moduleId: string | undefined;
    displayName: string | undefined;
    isSystemAdmin: boolean | undefined;
    hasAllPermissions: boolean | undefined;
    hasNoActiveUsers: boolean | undefined;
    name: string | undefined;
    description: string | undefined;
    rolePermissions: RolePermissionDto[] | undefined;
    names: LocalizedValue[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.moduleId = _data["moduleId"];
            this.displayName = _data["displayName"];
            this.isSystemAdmin = _data["isSystemAdmin"];
            this.hasAllPermissions = _data["hasAllPermissions"];
            this.hasNoActiveUsers = _data["hasNoActiveUsers"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["rolePermissions"])) {
                this.rolePermissions = [] as any;
                for (let item of _data["rolePermissions"])
                    this.rolePermissions.push(RolePermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["names"])) {
                this.names = [] as any;
                for (let item of _data["names"])
                    this.names.push(LocalizedValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["moduleId"] = this.moduleId;
        data["displayName"] = this.displayName;
        data["isSystemAdmin"] = this.isSystemAdmin;
        data["hasAllPermissions"] = this.hasAllPermissions;
        data["hasNoActiveUsers"] = this.hasNoActiveUsers;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.rolePermissions)) {
            data["rolePermissions"] = [];
            for (let item of this.rolePermissions)
                data["rolePermissions"].push(item.toJSON());
        }
        if (Array.isArray(this.names)) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: string | undefined;
    tenantId: string | undefined;
    moduleId: string | undefined;
    displayName: string | undefined;
    isSystemAdmin: boolean | undefined;
    hasAllPermissions: boolean | undefined;
    hasNoActiveUsers: boolean | undefined;
    name: string | undefined;
    description: string | undefined;
    rolePermissions: RolePermissionDto[] | undefined;
    names: LocalizedValue[] | undefined;
}

export class RolePermissionDto implements IRolePermissionDto {
    id: string | undefined;
    roleId: string | undefined;
    permissionId: string | undefined;
    names: LocalizedValue[] | undefined;

    constructor(data?: IRolePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.permissionId = _data["permissionId"];
            if (Array.isArray(_data["names"])) {
                this.names = [] as any;
                for (let item of _data["names"])
                    this.names.push(LocalizedValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["permissionId"] = this.permissionId;
        if (Array.isArray(this.names)) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RolePermissionDto {
        const json = this.toJSON();
        let result = new RolePermissionDto();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDto {
    id: string | undefined;
    roleId: string | undefined;
    permissionId: string | undefined;
    names: LocalizedValue[] | undefined;
}

export class LocalizedValue implements ILocalizedValue {
    language: LocalizedValueLanguage | undefined;
    value: string | undefined;

    constructor(data?: ILocalizedValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LocalizedValue {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizedValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language;
        data["value"] = this.value;
        return data; 
    }

    clone(): LocalizedValue {
        const json = this.toJSON();
        let result = new LocalizedValue();
        result.init(json);
        return result;
    }
}

export interface ILocalizedValue {
    language: LocalizedValueLanguage | undefined;
    value: string | undefined;
}

export class RoleSearchFilterDto implements IRoleSearchFilterDto {
    displayName: string | undefined;
    roleId: string | undefined;
    pageSize: number | undefined;
    pageNumber: number | undefined;
    sortBy: string | undefined;
    filterString: string | undefined;

    constructor(data?: IRoleSearchFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.roleId = _data["roleId"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
            this.sortBy = _data["sortBy"];
            this.filterString = _data["filterString"];
        }
    }

    static fromJS(data: any): RoleSearchFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleSearchFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["roleId"] = this.roleId;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        data["sortBy"] = this.sortBy;
        data["filterString"] = this.filterString;
        return data; 
    }

    clone(): RoleSearchFilterDto {
        const json = this.toJSON();
        let result = new RoleSearchFilterDto();
        result.init(json);
        return result;
    }
}

export interface IRoleSearchFilterDto {
    displayName: string | undefined;
    roleId: string | undefined;
    pageSize: number | undefined;
    pageNumber: number | undefined;
    sortBy: string | undefined;
    filterString: string | undefined;
}

export class AjaxResponseOfPagedResultOfRoleSearchDto implements IAjaxResponseOfPagedResultOfRoleSearchDto {
    result: PagedResultOfRoleSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfPagedResultOfRoleSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PagedResultOfRoleSearchDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfPagedResultOfRoleSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfPagedResultOfRoleSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfPagedResultOfRoleSearchDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfPagedResultOfRoleSearchDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfPagedResultOfRoleSearchDto {
    result: PagedResultOfRoleSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class PagedResultOfRoleSearchDto implements IPagedResultOfRoleSearchDto {
    totalCount: number | undefined;
    items: RoleSearchDto[] | undefined;

    constructor(data?: IPagedResultOfRoleSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleSearchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfRoleSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfRoleSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultOfRoleSearchDto {
        const json = this.toJSON();
        let result = new PagedResultOfRoleSearchDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultOfRoleSearchDto {
    totalCount: number | undefined;
    items: RoleSearchDto[] | undefined;
}

export class RoleSearchDto implements IRoleSearchDto {
    id: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    activeUsersCount: number | undefined;

    constructor(data?: IRoleSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.activeUsersCount = _data["activeUsersCount"];
        }
    }

    static fromJS(data: any): RoleSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["activeUsersCount"] = this.activeUsersCount;
        return data; 
    }

    clone(): RoleSearchDto {
        const json = this.toJSON();
        let result = new RoleSearchDto();
        result.init(json);
        return result;
    }
}

export interface IRoleSearchDto {
    id: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    activeUsersCount: number | undefined;
}

export class AjaxResponseOfIReadOnlyListOfRoleSearchDto implements IAjaxResponseOfIReadOnlyListOfRoleSearchDto {
    result: RoleSearchDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfIReadOnlyListOfRoleSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(RoleSearchDto.fromJS(item));
            }
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfIReadOnlyListOfRoleSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfIReadOnlyListOfRoleSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfIReadOnlyListOfRoleSearchDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfIReadOnlyListOfRoleSearchDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfIReadOnlyListOfRoleSearchDto {
    result: RoleSearchDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class AjaxResponseOfPagedResultOfActiveUserSearchDto implements IAjaxResponseOfPagedResultOfActiveUserSearchDto {
    result: PagedResultOfActiveUserSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfPagedResultOfActiveUserSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PagedResultOfActiveUserSearchDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfPagedResultOfActiveUserSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfPagedResultOfActiveUserSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfPagedResultOfActiveUserSearchDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfPagedResultOfActiveUserSearchDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfPagedResultOfActiveUserSearchDto {
    result: PagedResultOfActiveUserSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class PagedResultOfActiveUserSearchDto implements IPagedResultOfActiveUserSearchDto {
    totalCount: number | undefined;
    items: ActiveUserSearchDto[] | undefined;

    constructor(data?: IPagedResultOfActiveUserSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ActiveUserSearchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfActiveUserSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfActiveUserSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultOfActiveUserSearchDto {
        const json = this.toJSON();
        let result = new PagedResultOfActiveUserSearchDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultOfActiveUserSearchDto {
    totalCount: number | undefined;
    items: ActiveUserSearchDto[] | undefined;
}

export class ActiveUserSearchDto implements IActiveUserSearchDto {
    id: string | undefined;
    emailAddress: string | undefined;

    constructor(data?: IActiveUserSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): ActiveUserSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveUserSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): ActiveUserSearchDto {
        const json = this.toJSON();
        let result = new ActiveUserSearchDto();
        result.init(json);
        return result;
    }
}

export interface IActiveUserSearchDto {
    id: string | undefined;
    emailAddress: string | undefined;
}

export class AjaxResponseOfPagedResultOfPermissionSearchDto implements IAjaxResponseOfPagedResultOfPermissionSearchDto {
    result: PagedResultOfPermissionSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfPagedResultOfPermissionSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PagedResultOfPermissionSearchDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfPagedResultOfPermissionSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfPagedResultOfPermissionSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfPagedResultOfPermissionSearchDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfPagedResultOfPermissionSearchDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfPagedResultOfPermissionSearchDto {
    result: PagedResultOfPermissionSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class PagedResultOfPermissionSearchDto implements IPagedResultOfPermissionSearchDto {
    totalCount: number | undefined;
    items: PermissionSearchDto[] | undefined;

    constructor(data?: IPagedResultOfPermissionSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionSearchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfPermissionSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfPermissionSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultOfPermissionSearchDto {
        const json = this.toJSON();
        let result = new PagedResultOfPermissionSearchDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultOfPermissionSearchDto {
    totalCount: number | undefined;
    items: PermissionSearchDto[] | undefined;
}

export class PermissionSearchDto implements IPermissionSearchDto {
    id: string | undefined;
    displayName: string | undefined;
    isGranted: boolean | undefined;

    constructor(data?: IPermissionSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.isGranted = _data["isGranted"];
        }
    }

    static fromJS(data: any): PermissionSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isGranted"] = this.isGranted;
        return data; 
    }

    clone(): PermissionSearchDto {
        const json = this.toJSON();
        let result = new PermissionSearchDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionSearchDto {
    id: string | undefined;
    displayName: string | undefined;
    isGranted: boolean | undefined;
}

export class AjaxResponseOfUserAccessDto implements IAjaxResponseOfUserAccessDto {
    result: UserAccessDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfUserAccessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? UserAccessDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfUserAccessDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfUserAccessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfUserAccessDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfUserAccessDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfUserAccessDto {
    result: UserAccessDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class UserAccessDto implements IUserAccessDto {
    userId: number | undefined;
    username: string | undefined;
    name: string | undefined;
    roleId: string | undefined;
    roleName: string | undefined;
    isActive: boolean | undefined;
    permissions: string[] | undefined;
    tenants: number[] | undefined;
    hasAllTenants: boolean | undefined;
    defaultTenantId: number | undefined;
    id: string | undefined;

    constructor(data?: IUserAccessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.username = _data["username"];
            this.name = _data["name"];
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(item);
            }
            if (Array.isArray(_data["tenants"])) {
                this.tenants = [] as any;
                for (let item of _data["tenants"])
                    this.tenants.push(item);
            }
            this.hasAllTenants = _data["hasAllTenants"];
            this.defaultTenantId = _data["defaultTenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserAccessDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAccessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["username"] = this.username;
        data["name"] = this.name;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.tenants)) {
            data["tenants"] = [];
            for (let item of this.tenants)
                data["tenants"].push(item);
        }
        data["hasAllTenants"] = this.hasAllTenants;
        data["defaultTenantId"] = this.defaultTenantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserAccessDto {
        const json = this.toJSON();
        let result = new UserAccessDto();
        result.init(json);
        return result;
    }
}

export interface IUserAccessDto {
    userId: number | undefined;
    username: string | undefined;
    name: string | undefined;
    roleId: string | undefined;
    roleName: string | undefined;
    isActive: boolean | undefined;
    permissions: string[] | undefined;
    tenants: number[] | undefined;
    hasAllTenants: boolean | undefined;
    defaultTenantId: number | undefined;
    id: string | undefined;
}

export class UserSearchFilterDto implements IUserSearchFilterDto {
    emailAddress: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    roleIds: string[] | undefined;
    clientId: string | undefined;
    userStatuses: boolean[] | undefined;
    pageSize: number | undefined;
    pageNumber: number | undefined;
    sortBy: string | undefined;
    filterString: string | undefined;

    constructor(data?: IUserSearchFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds.push(item);
            }
            this.clientId = _data["clientId"];
            if (Array.isArray(_data["userStatuses"])) {
                this.userStatuses = [] as any;
                for (let item of _data["userStatuses"])
                    this.userStatuses.push(item);
            }
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
            this.sortBy = _data["sortBy"];
            this.filterString = _data["filterString"];
        }
    }

    static fromJS(data: any): UserSearchFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["clientId"] = this.clientId;
        if (Array.isArray(this.userStatuses)) {
            data["userStatuses"] = [];
            for (let item of this.userStatuses)
                data["userStatuses"].push(item);
        }
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        data["sortBy"] = this.sortBy;
        data["filterString"] = this.filterString;
        return data; 
    }

    clone(): UserSearchFilterDto {
        const json = this.toJSON();
        let result = new UserSearchFilterDto();
        result.init(json);
        return result;
    }
}

export interface IUserSearchFilterDto {
    emailAddress: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    roleIds: string[] | undefined;
    clientId: string | undefined;
    userStatuses: boolean[] | undefined;
    pageSize: number | undefined;
    pageNumber: number | undefined;
    sortBy: string | undefined;
    filterString: string | undefined;
}

export class AjaxResponseOfPagedResultOfUserSearchDto implements IAjaxResponseOfPagedResultOfUserSearchDto {
    result: PagedResultOfUserSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfPagedResultOfUserSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PagedResultOfUserSearchDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfPagedResultOfUserSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfPagedResultOfUserSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfPagedResultOfUserSearchDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfPagedResultOfUserSearchDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfPagedResultOfUserSearchDto {
    result: PagedResultOfUserSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class PagedResultOfUserSearchDto implements IPagedResultOfUserSearchDto {
    totalCount: number | undefined;
    items: UserSearchDto[] | undefined;

    constructor(data?: IPagedResultOfUserSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserSearchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfUserSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfUserSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultOfUserSearchDto {
        const json = this.toJSON();
        let result = new PagedResultOfUserSearchDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultOfUserSearchDto {
    totalCount: number | undefined;
    items: UserSearchDto[] | undefined;
}

export class UserSearchDto implements IUserSearchDto {
    id: string | undefined;
    userProfileId: string | undefined;
    emailAddress: string | undefined;
    name: string | undefined;
    roleName: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberExtension: string | undefined;
    activeClientsCount: number | undefined;
    isActive: boolean | undefined;

    constructor(data?: IUserSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userProfileId = _data["userProfileId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.roleName = _data["roleName"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberExtension = _data["phoneNumberExtension"];
            this.activeClientsCount = _data["activeClientsCount"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UserSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userProfileId"] = this.userProfileId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["roleName"] = this.roleName;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberExtension"] = this.phoneNumberExtension;
        data["activeClientsCount"] = this.activeClientsCount;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): UserSearchDto {
        const json = this.toJSON();
        let result = new UserSearchDto();
        result.init(json);
        return result;
    }
}

export interface IUserSearchDto {
    id: string | undefined;
    userProfileId: string | undefined;
    emailAddress: string | undefined;
    name: string | undefined;
    roleName: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberExtension: string | undefined;
    activeClientsCount: number | undefined;
    isActive: boolean | undefined;
}

export class UserClientSearchFilterDto implements IUserClientSearchFilterDto {
    userId: string | undefined;
    includeActiveOnly: boolean | undefined;
    pageSize: number | undefined;
    pageNumber: number | undefined;
    sortBy: string | undefined;
    filterString: string | undefined;

    constructor(data?: IUserClientSearchFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.includeActiveOnly = _data["includeActiveOnly"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
            this.sortBy = _data["sortBy"];
            this.filterString = _data["filterString"];
        }
    }

    static fromJS(data: any): UserClientSearchFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserClientSearchFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["includeActiveOnly"] = this.includeActiveOnly;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        data["sortBy"] = this.sortBy;
        data["filterString"] = this.filterString;
        return data; 
    }

    clone(): UserClientSearchFilterDto {
        const json = this.toJSON();
        let result = new UserClientSearchFilterDto();
        result.init(json);
        return result;
    }
}

export interface IUserClientSearchFilterDto {
    userId: string | undefined;
    includeActiveOnly: boolean | undefined;
    pageSize: number | undefined;
    pageNumber: number | undefined;
    sortBy: string | undefined;
    filterString: string | undefined;
}

export class AjaxResponseOfPagedResultOfUserClientSearchDto implements IAjaxResponseOfPagedResultOfUserClientSearchDto {
    result: PagedResultOfUserClientSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfPagedResultOfUserClientSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PagedResultOfUserClientSearchDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfPagedResultOfUserClientSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfPagedResultOfUserClientSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfPagedResultOfUserClientSearchDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfPagedResultOfUserClientSearchDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfPagedResultOfUserClientSearchDto {
    result: PagedResultOfUserClientSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class PagedResultOfUserClientSearchDto implements IPagedResultOfUserClientSearchDto {
    totalCount: number | undefined;
    items: UserClientSearchDto[] | undefined;

    constructor(data?: IPagedResultOfUserClientSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserClientSearchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfUserClientSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfUserClientSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultOfUserClientSearchDto {
        const json = this.toJSON();
        let result = new PagedResultOfUserClientSearchDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultOfUserClientSearchDto {
    totalCount: number | undefined;
    items: UserClientSearchDto[] | undefined;
}

export class UserClientSearchDto implements IUserClientSearchDto {
    id: string | undefined;
    clientName: string | undefined;
    clientId: string | undefined;
    moduleStatus: string | undefined;
    isGranted: boolean | undefined;

    constructor(data?: IUserClientSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientName = _data["clientName"];
            this.clientId = _data["clientId"];
            this.moduleStatus = _data["moduleStatus"];
            this.isGranted = _data["isGranted"];
        }
    }

    static fromJS(data: any): UserClientSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserClientSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientName"] = this.clientName;
        data["clientId"] = this.clientId;
        data["moduleStatus"] = this.moduleStatus;
        data["isGranted"] = this.isGranted;
        return data; 
    }

    clone(): UserClientSearchDto {
        const json = this.toJSON();
        let result = new UserClientSearchDto();
        result.init(json);
        return result;
    }
}

export interface IUserClientSearchDto {
    id: string | undefined;
    clientName: string | undefined;
    clientId: string | undefined;
    moduleStatus: string | undefined;
    isGranted: boolean | undefined;
}

export class AjaxResponseOfUserDto implements IAjaxResponseOfUserDto {
    result: UserDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? UserDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfUserDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfUserDto {
    result: UserDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class UserDto implements IUserDto {
    id: string | undefined;
    roleId: string | undefined;
    userProfile: UserProfileDto | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    isActive: boolean | undefined;
    hasAllClients: boolean | undefined;
    userClients: UserClientDto[] | undefined;
    names: LocalizedValue[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.userProfile = _data["userProfile"] ? UserProfileDto.fromJS(_data["userProfile"]) : <any>undefined;
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.hasAllClients = _data["hasAllClients"];
            if (Array.isArray(_data["userClients"])) {
                this.userClients = [] as any;
                for (let item of _data["userClients"])
                    this.userClients.push(UserClientDto.fromJS(item));
            }
            if (Array.isArray(_data["names"])) {
                this.names = [] as any;
                for (let item of _data["names"])
                    this.names.push(LocalizedValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["userProfile"] = this.userProfile ? this.userProfile.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["hasAllClients"] = this.hasAllClients;
        if (Array.isArray(this.userClients)) {
            data["userClients"] = [];
            for (let item of this.userClients)
                data["userClients"].push(item.toJSON());
        }
        if (Array.isArray(this.names)) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: string | undefined;
    roleId: string | undefined;
    userProfile: UserProfileDto | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    isActive: boolean | undefined;
    hasAllClients: boolean | undefined;
    userClients: UserClientDto[] | undefined;
    names: LocalizedValue[] | undefined;
}

export class UserProfileDto implements IUserProfileDto {
    id: string | undefined;
    userId: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    emailAddressText: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberExtension: string | undefined;
    faxNumber: string | undefined;
    mobilePhoneNumber: string | undefined;
    internalFlag: boolean | undefined;
    names: LocalizedValue[] | undefined;

    constructor(data?: IUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.emailAddressText = _data["emailAddressText"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberExtension = _data["phoneNumberExtension"];
            this.faxNumber = _data["faxNumber"];
            this.mobilePhoneNumber = _data["mobilePhoneNumber"];
            this.internalFlag = _data["internalFlag"];
            if (Array.isArray(_data["names"])) {
                this.names = [] as any;
                for (let item of _data["names"])
                    this.names.push(LocalizedValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["emailAddressText"] = this.emailAddressText;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberExtension"] = this.phoneNumberExtension;
        data["faxNumber"] = this.faxNumber;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["internalFlag"] = this.internalFlag;
        if (Array.isArray(this.names)) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserProfileDto {
        const json = this.toJSON();
        let result = new UserProfileDto();
        result.init(json);
        return result;
    }
}

export interface IUserProfileDto {
    id: string | undefined;
    userId: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    emailAddressText: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberExtension: string | undefined;
    faxNumber: string | undefined;
    mobilePhoneNumber: string | undefined;
    internalFlag: boolean | undefined;
    names: LocalizedValue[] | undefined;
}

export class UserClientDto implements IUserClientDto {
    id: string | undefined;
    userId: string | undefined;
    clientId: string | undefined;
    names: LocalizedValue[] | undefined;

    constructor(data?: IUserClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.clientId = _data["clientId"];
            if (Array.isArray(_data["names"])) {
                this.names = [] as any;
                for (let item of _data["names"])
                    this.names.push(LocalizedValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["clientId"] = this.clientId;
        if (Array.isArray(this.names)) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserClientDto {
        const json = this.toJSON();
        let result = new UserClientDto();
        result.init(json);
        return result;
    }
}

export interface IUserClientDto {
    id: string | undefined;
    userId: string | undefined;
    clientId: string | undefined;
    names: LocalizedValue[] | undefined;
}

export class ActiveDirectoryUserSearchFilterDto implements IActiveDirectoryUserSearchFilterDto {
    emailAddress: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    pageSize: number | undefined;
    pageNumber: number | undefined;
    sortBy: string | undefined;
    filterString: string | undefined;

    constructor(data?: IActiveDirectoryUserSearchFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
            this.sortBy = _data["sortBy"];
            this.filterString = _data["filterString"];
        }
    }

    static fromJS(data: any): ActiveDirectoryUserSearchFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveDirectoryUserSearchFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        data["sortBy"] = this.sortBy;
        data["filterString"] = this.filterString;
        return data; 
    }

    clone(): ActiveDirectoryUserSearchFilterDto {
        const json = this.toJSON();
        let result = new ActiveDirectoryUserSearchFilterDto();
        result.init(json);
        return result;
    }
}

export interface IActiveDirectoryUserSearchFilterDto {
    emailAddress: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    pageSize: number | undefined;
    pageNumber: number | undefined;
    sortBy: string | undefined;
    filterString: string | undefined;
}

export class AjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto implements IAjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto {
    result: PagedResultOfActiveDirectoryUserSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PagedResultOfActiveDirectoryUserSearchDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfPagedResultOfActiveDirectoryUserSearchDto {
    result: PagedResultOfActiveDirectoryUserSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class PagedResultOfActiveDirectoryUserSearchDto implements IPagedResultOfActiveDirectoryUserSearchDto {
    totalCount: number | undefined;
    items: ActiveDirectoryUserSearchDto[] | undefined;

    constructor(data?: IPagedResultOfActiveDirectoryUserSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ActiveDirectoryUserSearchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfActiveDirectoryUserSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfActiveDirectoryUserSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultOfActiveDirectoryUserSearchDto {
        const json = this.toJSON();
        let result = new PagedResultOfActiveDirectoryUserSearchDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultOfActiveDirectoryUserSearchDto {
    totalCount: number | undefined;
    items: ActiveDirectoryUserSearchDto[] | undefined;
}

export class ActiveDirectoryUserSearchDto implements IActiveDirectoryUserSearchDto {
    activeDirectoryUserId: string | undefined;
    emailAddress: string | undefined;
    name: string | undefined;

    constructor(data?: IActiveDirectoryUserSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activeDirectoryUserId = _data["activeDirectoryUserId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ActiveDirectoryUserSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveDirectoryUserSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activeDirectoryUserId"] = this.activeDirectoryUserId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        return data; 
    }

    clone(): ActiveDirectoryUserSearchDto {
        const json = this.toJSON();
        let result = new ActiveDirectoryUserSearchDto();
        result.init(json);
        return result;
    }
}

export interface IActiveDirectoryUserSearchDto {
    activeDirectoryUserId: string | undefined;
    emailAddress: string | undefined;
    name: string | undefined;
}

export class AjaxResponseOfListOfUserLoginDto implements IAjaxResponseOfListOfUserLoginDto {
    result: UserLoginDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfListOfUserLoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(UserLoginDto.fromJS(item));
            }
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfListOfUserLoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfListOfUserLoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfListOfUserLoginDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfListOfUserLoginDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfListOfUserLoginDto {
    result: UserLoginDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class UserLoginDto implements IUserLoginDto {
    userId: number | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    username: string | undefined;
    permissions: string[] | undefined;
    tenants: number[] | undefined;

    constructor(data?: IUserLoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.username = _data["username"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(item);
            }
            if (Array.isArray(_data["tenants"])) {
                this.tenants = [] as any;
                for (let item of _data["tenants"])
                    this.tenants.push(item);
            }
        }
    }

    static fromJS(data: any): UserLoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["username"] = this.username;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.tenants)) {
            data["tenants"] = [];
            for (let item of this.tenants)
                data["tenants"].push(item);
        }
        return data; 
    }

    clone(): UserLoginDto {
        const json = this.toJSON();
        let result = new UserLoginDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginDto {
    userId: number | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    username: string | undefined;
    permissions: string[] | undefined;
    tenants: number[] | undefined;
}

export class AjaxResponseOfListOfUserProfileDto implements IAjaxResponseOfListOfUserProfileDto {
    result: UserProfileDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfListOfUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(UserProfileDto.fromJS(item));
            }
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfListOfUserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfListOfUserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfListOfUserProfileDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfListOfUserProfileDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfListOfUserProfileDto {
    result: UserProfileDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class UserLogDto implements IUserLogDto {
    userId: number | undefined;
    userAgent: string | undefined;
    terminalId: string | undefined;
    logTime: Date | undefined;
    logTypeId: string | undefined;

    constructor(data?: IUserLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userAgent = _data["userAgent"];
            this.terminalId = _data["terminalId"];
            this.logTime = _data["logTime"] ? new Date(_data["logTime"].toString()) : <any>undefined;
            this.logTypeId = _data["logTypeId"];
        }
    }

    static fromJS(data: any): UserLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userAgent"] = this.userAgent;
        data["terminalId"] = this.terminalId;
        data["logTime"] = this.logTime ? this.logTime.toISOString() : <any>undefined;
        data["logTypeId"] = this.logTypeId;
        return data; 
    }

    clone(): UserLogDto {
        const json = this.toJSON();
        let result = new UserLogDto();
        result.init(json);
        return result;
    }
}

export interface IUserLogDto {
    userId: number | undefined;
    userAgent: string | undefined;
    terminalId: string | undefined;
    logTime: Date | undefined;
    logTypeId: string | undefined;
}

export enum LocalizedValueLanguage {
    _0 = 0,
    _1 = 1,
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}