/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const Communication_API_BASE_URL = new InjectionToken<string>('Communication_API_BASE_URL');

export class ServiceBaseConfig {
  public key: string;
}

export class ServiceBase {
  private readonly apiKey: string;
  private readonly apimHeaderName: string = 'Ocp-Apim-Subscription-Key';
  private readonly tenantIdHeaderName: string = 'TenantId';
  private readonly tenantIdLocalStorageKey: string = 'samplicity-dtp-current-client';
  private readonly idTokenKey: string = 'samplicity-id-token';

  constructor(config: ServiceBaseConfig) {
    this.apiKey = config.key;
  }

  protected transformOptions(options: any) {
    let headers: HttpHeaders = options.headers;

    if (this.apiKey) {
      headers = headers.append(this.apimHeaderName, this.apiKey);
    }

    const tenantId = sessionStorage.getItem(this.tenantIdLocalStorageKey);
    if (tenantId) {
      headers = headers.append(this.tenantIdHeaderName, tenantId);
    }

    const token = localStorage.getItem(this.idTokenKey);
    if (token) {
      headers = headers.append('Authorization', 'Bearer ' + token);
    }

    options.headers = headers;

    return Promise.resolve(options);
  }
}

@Injectable()
export class Communication extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(ServiceBaseConfig) configuration: ServiceBaseConfig, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(Communication_API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    searchCommunications(filter?: CommunicationSearchFilterDto | null | undefined): Observable<AjaxResponseOfPagedResultOfCommunicationSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/SearchCommunications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearchCommunications(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchCommunications(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfPagedResultOfCommunicationSearchDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfPagedResultOfCommunicationSearchDto>><any>Observable.throw(response_);
        });
    }

    protected processSearchCommunications(response: HttpResponseBase): Observable<AjaxResponseOfPagedResultOfCommunicationSearchDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfPagedResultOfCommunicationSearchDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfPagedResultOfCommunicationSearchDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    searchCommunicationsByOrderId(orderId?: string | null | undefined): Observable<AjaxResponseOfIListOfCommunicationSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/SearchCommunicationsByOrderId?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearchCommunicationsByOrderId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchCommunicationsByOrderId(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfIListOfCommunicationSearchDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfIListOfCommunicationSearchDto>><any>Observable.throw(response_);
        });
    }

    protected processSearchCommunicationsByOrderId(response: HttpResponseBase): Observable<AjaxResponseOfIListOfCommunicationSearchDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfIListOfCommunicationSearchDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfIListOfCommunicationSearchDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCommunicationById(id?: string | null | undefined): Observable<AjaxResponseOfCommunicationDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/GetCommunicationById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetCommunicationById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommunicationById(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfCommunicationDetailDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfCommunicationDetailDto>><any>Observable.throw(response_);
        });
    }

    protected processGetCommunicationById(response: HttpResponseBase): Observable<AjaxResponseOfCommunicationDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfCommunicationDetailDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfCommunicationDetailDto>(<any>null);
    }

    /**
     * @param dto (optional) 
     * @return Success
     */
    updateCommunicationStatus(dto?: CommunicationHistoryDto | null | undefined): Observable<AjaxResponseOfCommunicationDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/UpdateCommunicationStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateCommunicationStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCommunicationStatus(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfCommunicationDetailDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfCommunicationDetailDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdateCommunicationStatus(response: HttpResponseBase): Observable<AjaxResponseOfCommunicationDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfCommunicationDetailDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfCommunicationDetailDto>(<any>null);
    }

    /**
     * @param communicationRequest (optional) 
     * @return Success
     */
    addCommunicationRecord(communicationRequest?: CreateCommunicationRequestDto | null | undefined): Observable<AjaxResponseOfCreateCommunicationResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/AddCommunicationRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(communicationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processAddCommunicationRecord(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCommunicationRecord(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfCreateCommunicationResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfCreateCommunicationResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processAddCommunicationRecord(response: HttpResponseBase): Observable<AjaxResponseOfCreateCommunicationResponseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfCreateCommunicationResponseDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfCreateCommunicationResponseDto>(<any>null);
    }

    /**
     * @param dto (optional) 
     * @return Success
     */
    resendCommunication(dto?: CommunicationResendDto | null | undefined): Observable<AjaxResponseOfCommunicationDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/ResendCommunication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processResendCommunication(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendCommunication(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfCommunicationDetailDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfCommunicationDetailDto>><any>Observable.throw(response_);
        });
    }

    protected processResendCommunication(response: HttpResponseBase): Observable<AjaxResponseOfCommunicationDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfCommunicationDetailDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfCommunicationDetailDto>(<any>null);
    }

    /**
     * @param programId (optional) 
     * @return Success
     */
    getDocumentTemplatesByProgramId(programId?: string | null | undefined): Observable<AjaxResponseOfListOfDocumentTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/GetDocumentTemplatesByProgramId?";
        if (programId !== undefined)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetDocumentTemplatesByProgramId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTemplatesByProgramId(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfListOfDocumentTemplateDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfListOfDocumentTemplateDto>><any>Observable.throw(response_);
        });
    }

    protected processGetDocumentTemplatesByProgramId(response: HttpResponseBase): Observable<AjaxResponseOfListOfDocumentTemplateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfListOfDocumentTemplateDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfListOfDocumentTemplateDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @param formId (optional) 
     * @param tenantId (optional) 
     * @param commDirection (optional) 
     * @param documentStatus (optional) 
     * @return Success
     */
    getAocByFormId(orderId?: string | null | undefined, formId?: string | null | undefined, tenantId?: number | null | undefined, commDirection?: string | null | undefined, documentStatus?: string | null | undefined): Observable<AjaxResponseOfEntityDto> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/GetAocByFormId?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (formId !== undefined)
            url_ += "formId=" + encodeURIComponent("" + formId) + "&"; 
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (commDirection !== undefined)
            url_ += "commDirection=" + encodeURIComponent("" + commDirection) + "&"; 
        if (documentStatus !== undefined)
            url_ += "documentStatus=" + encodeURIComponent("" + documentStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAocByFormId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAocByFormId(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfEntityDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfEntityDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAocByFormId(response: HttpResponseBase): Observable<AjaxResponseOfEntityDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfEntityDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfEntityDto>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getIfBlankSrfExists(formId?: string | null | undefined, tenantId?: number | null | undefined): Observable<AjaxResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/GetIfBlankSrfExists?";
        if (formId !== undefined)
            url_ += "formId=" + encodeURIComponent("" + formId) + "&"; 
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetIfBlankSrfExists(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIfBlankSrfExists(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfBoolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfBoolean>><any>Observable.throw(response_);
        });
    }

    protected processGetIfBlankSrfExists(response: HttpResponseBase): Observable<AjaxResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfBoolean.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfBoolean>(<any>null);
    }

    /**
     * @param programId (optional) 
     * @param communicationType (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getCommunicationsByProgramId(programId?: string | null | undefined, communicationType?: string | null | undefined, tenantId?: number | null | undefined): Observable<AjaxResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/GetCommunicationsByProgramId?";
        if (programId !== undefined)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&"; 
        if (communicationType !== undefined)
            url_ += "communicationType=" + encodeURIComponent("" + communicationType) + "&"; 
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetCommunicationsByProgramId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommunicationsByProgramId(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfBoolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfBoolean>><any>Observable.throw(response_);
        });
    }

    protected processGetCommunicationsByProgramId(response: HttpResponseBase): Observable<AjaxResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfBoolean.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfBoolean>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getDocumentByFormId(formId?: string | null | undefined, tenantId?: number | null | undefined): Observable<AjaxResponseOfString> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/GetDocumentByFormId?";
        if (formId !== undefined)
            url_ += "formId=" + encodeURIComponent("" + formId) + "&"; 
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetDocumentByFormId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentByFormId(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfString>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfString>><any>Observable.throw(response_);
        });
    }

    protected processGetDocumentByFormId(response: HttpResponseBase): Observable<AjaxResponseOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfString.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfString>(<any>null);
    }

    /**
     * @param entityId (optional) 
     * @param entityTypeId (optional) 
     * @param documentTypeId (optional) 
     * @return Success
     */
    getDocumentsByEntityIds(entityId?: string | null | undefined, entityTypeId?: string | null | undefined, documentTypeId?: string | null | undefined): Observable<AjaxResponseOfListOfDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/GetDocumentsByEntityIds?";
        if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&"; 
        if (entityTypeId !== undefined)
            url_ += "entityTypeId=" + encodeURIComponent("" + entityTypeId) + "&"; 
        if (documentTypeId !== undefined)
            url_ += "documentTypeId=" + encodeURIComponent("" + documentTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetDocumentsByEntityIds(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentsByEntityIds(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfListOfDocumentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfListOfDocumentDto>><any>Observable.throw(response_);
        });
    }

    protected processGetDocumentsByEntityIds(response: HttpResponseBase): Observable<AjaxResponseOfListOfDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfListOfDocumentDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfListOfDocumentDto>(<any>null);
    }

    /**
     * @param entityTypeId (optional) 
     * @param entityId (optional) 
     * @param tenantId (optional) 
     * @param commDirection (optional) 
     * @param commType (optional) 
     * @return Success
     */
    getCommReceivedDateByEntityId(entityTypeId?: string | null | undefined, entityId?: string | null | undefined, tenantId?: number | null | undefined, commDirection?: string | null | undefined, commType?: string | null | undefined): Observable<AjaxResponseOfNullableOfDateTime> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/GetCommReceivedDateByEntityId?";
        if (entityTypeId !== undefined)
            url_ += "entityTypeId=" + encodeURIComponent("" + entityTypeId) + "&"; 
        if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&"; 
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (commDirection !== undefined)
            url_ += "commDirection=" + encodeURIComponent("" + commDirection) + "&"; 
        if (commType !== undefined)
            url_ += "commType=" + encodeURIComponent("" + commType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetCommReceivedDateByEntityId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommReceivedDateByEntityId(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfNullableOfDateTime>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfNullableOfDateTime>><any>Observable.throw(response_);
        });
    }

    protected processGetCommReceivedDateByEntityId(response: HttpResponseBase): Observable<AjaxResponseOfNullableOfDateTime> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfNullableOfDateTime.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfNullableOfDateTime>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @param newOrderId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    copyCommunicationHistory(orderId?: string | null | undefined, newOrderId?: string | null | undefined, tenantId?: number | null | undefined): Observable<AjaxResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/CopyCommunicationHistory?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (newOrderId !== undefined)
            url_ += "newOrderId=" + encodeURIComponent("" + newOrderId) + "&"; 
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCopyCommunicationHistory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyCommunicationHistory(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfBoolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfBoolean>><any>Observable.throw(response_);
        });
    }

    protected processCopyCommunicationHistory(response: HttpResponseBase): Observable<AjaxResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfBoolean.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfBoolean>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @param communicationTypes (optional) 
     * @return Success
     */
    getLatestCommunicationWithTypesByOrderId(orderId?: string | null | undefined, communicationTypes?: string[] | null | undefined): Observable<AjaxResponseOfSimpleCommunicationDto> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/GetLatestCommunicationWithTypesByOrderId?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (communicationTypes !== undefined)
            communicationTypes && communicationTypes.forEach(item => { url_ += "communicationTypes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetLatestCommunicationWithTypesByOrderId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestCommunicationWithTypesByOrderId(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfSimpleCommunicationDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfSimpleCommunicationDto>><any>Observable.throw(response_);
        });
    }

    protected processGetLatestCommunicationWithTypesByOrderId(response: HttpResponseBase): Observable<AjaxResponseOfSimpleCommunicationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfSimpleCommunicationDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfSimpleCommunicationDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @param communicationTypes (optional) 
     * @return Success
     */
    getLatestAocCommunicationByOrderId(orderId?: string | null | undefined, communicationTypes?: string[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CommunicationService/GetLatestAocCommunicationByOrderId?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (communicationTypes !== undefined)
            communicationTypes && communicationTypes.forEach(item => { url_ += "communicationTypes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetLatestAocCommunicationByOrderId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestAocCommunicationByOrderId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>Observable.throw(e);
                }
            } else
                return <Observable<string>><any>Observable.throw(response_);
        });
    }

    protected processGetLatestAocCommunicationByOrderId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<string>(<any>null);
    }

    /**
     * @param documentGenerationRequest (optional) 
     * @return Success
     */
    generateDocument(documentGenerationRequest?: DocumentGenerationRequest | null | undefined): Observable<AjaxResponseOfDocumentGenerationResponse> {
        let url_ = this.baseUrl + "/api/services/app/DocumentGenerationService/GenerateDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentGenerationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGenerateDocument(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDocument(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfDocumentGenerationResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfDocumentGenerationResponse>><any>Observable.throw(response_);
        });
    }

    protected processGenerateDocument(response: HttpResponseBase): Observable<AjaxResponseOfDocumentGenerationResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfDocumentGenerationResponse.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfDocumentGenerationResponse>(<any>null);
    }

    /**
     * @param batchGenerationRequest (optional) 
     * @return Success
     */
    generateDocumentBatch(batchGenerationRequest?: DocumentBatchGenerationRequest | null | undefined): Observable<AjaxResponseOfDocumentBatchGenerationResponse> {
        let url_ = this.baseUrl + "/api/services/app/DocumentGenerationService/GenerateDocumentBatch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(batchGenerationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGenerateDocumentBatch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDocumentBatch(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfDocumentBatchGenerationResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfDocumentBatchGenerationResponse>><any>Observable.throw(response_);
        });
    }

    protected processGenerateDocumentBatch(response: HttpResponseBase): Observable<AjaxResponseOfDocumentBatchGenerationResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfDocumentBatchGenerationResponse.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfDocumentBatchGenerationResponse>(<any>null);
    }

    /**
     * @param emailRequestDto (optional) 
     * @return Success
     */
    sendEmail(emailRequestDto?: EmailRequest | null | undefined): Observable<AjaxResponseOfEmailResponse> {
        let url_ = this.baseUrl + "/api/services/app/EmailService/SendEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(emailRequestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSendEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmail(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfEmailResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfEmailResponse>><any>Observable.throw(response_);
        });
    }

    protected processSendEmail(response: HttpResponseBase): Observable<AjaxResponseOfEmailResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfEmailResponse.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfEmailResponse>(<any>null);
    }

    /**
     * @param faxRequest (optional) 
     * @return Success
     */
    sendFax(faxRequest?: FaxRequest | null | undefined): Observable<AjaxResponseOfFaxResponse> {
        let url_ = this.baseUrl + "/api/services/app/FaxService/SendFax";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(faxRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSendFax(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendFax(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfFaxResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfFaxResponse>><any>Observable.throw(response_);
        });
    }

    protected processSendFax(response: HttpResponseBase): Observable<AjaxResponseOfFaxResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfFaxResponse.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfFaxResponse>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    buildEmailTemplateDto(tenantId?: number | null | undefined): Observable<EmailTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/OutboundCommunicationTestService/BuildEmailTemplateDto?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processBuildEmailTemplateDto(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuildEmailTemplateDto(<any>response_);
                } catch (e) {
                    return <Observable<EmailTemplateDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<EmailTemplateDto>><any>Observable.throw(response_);
        });
    }

    protected processBuildEmailTemplateDto(response: HttpResponseBase): Observable<EmailTemplateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailTemplateDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EmailTemplateDto>(<any>null);
    }

    /**
     * @param requestDto (optional) 
     * @return Success
     */
    convertToPdf(requestDto?: PdfConversionRequestDto | null | undefined): Observable<AjaxResponseOfPdfConversionResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/PdfConversionService/ConvertToPdf";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processConvertToPdf(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConvertToPdf(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResponseOfPdfConversionResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AjaxResponseOfPdfConversionResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processConvertToPdf(response: HttpResponseBase): Observable<AjaxResponseOfPdfConversionResponseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjaxResponseOfPdfConversionResponseDto.fromJS(resultData200);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AjaxResponseOfPdfConversionResponseDto>(<any>null);
    }
}

export class CommunicationSearchFilterDto implements ICommunicationSearchFilterDto {
    programName: string | undefined;
    jobNumber: string | undefined;
    orderNumber: string | undefined;
    orderDateStart: Date | undefined;
    orderDateEnd: Date | undefined;
    formId: string | undefined;
    hcpLastName: string | undefined;
    hcpFirstName: string | undefined;
    hcpKidNumber: string | undefined;
    hcpsln: string | undefined;
    communicationId: string | undefined;
    communicationTypeIds: string[] | undefined;
    communicationMethodIds: string[] | undefined;
    communicationDirectionIds: string[] | undefined;
    communicationStatusIds: string[] | undefined;
    inboundDocumentStatusIds: string[] | undefined;
    outboundDocumentStatusIds: string[] | undefined;
    communicationDateStart: Date | undefined;
    communicationDateEnd: Date | undefined;
    pageSize: number | undefined;
    pageNumber: number | undefined;
    sortBy: string | undefined;
    filterString: string | undefined;

    constructor(data?: ICommunicationSearchFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programName = _data["programName"];
            this.jobNumber = _data["jobNumber"];
            this.orderNumber = _data["orderNumber"];
            this.orderDateStart = _data["orderDateStart"] ? new Date(_data["orderDateStart"].toString()) : <any>undefined;
            this.orderDateEnd = _data["orderDateEnd"] ? new Date(_data["orderDateEnd"].toString()) : <any>undefined;
            this.formId = _data["formId"];
            this.hcpLastName = _data["hcpLastName"];
            this.hcpFirstName = _data["hcpFirstName"];
            this.hcpKidNumber = _data["hcpKidNumber"];
            this.hcpsln = _data["hcpsln"];
            this.communicationId = _data["communicationId"];
            if (Array.isArray(_data["communicationTypeIds"])) {
                this.communicationTypeIds = [] as any;
                for (let item of _data["communicationTypeIds"])
                    this.communicationTypeIds.push(item);
            }
            if (Array.isArray(_data["communicationMethodIds"])) {
                this.communicationMethodIds = [] as any;
                for (let item of _data["communicationMethodIds"])
                    this.communicationMethodIds.push(item);
            }
            if (Array.isArray(_data["communicationDirectionIds"])) {
                this.communicationDirectionIds = [] as any;
                for (let item of _data["communicationDirectionIds"])
                    this.communicationDirectionIds.push(item);
            }
            if (Array.isArray(_data["communicationStatusIds"])) {
                this.communicationStatusIds = [] as any;
                for (let item of _data["communicationStatusIds"])
                    this.communicationStatusIds.push(item);
            }
            if (Array.isArray(_data["inboundDocumentStatusIds"])) {
                this.inboundDocumentStatusIds = [] as any;
                for (let item of _data["inboundDocumentStatusIds"])
                    this.inboundDocumentStatusIds.push(item);
            }
            if (Array.isArray(_data["outboundDocumentStatusIds"])) {
                this.outboundDocumentStatusIds = [] as any;
                for (let item of _data["outboundDocumentStatusIds"])
                    this.outboundDocumentStatusIds.push(item);
            }
            this.communicationDateStart = _data["communicationDateStart"] ? new Date(_data["communicationDateStart"].toString()) : <any>undefined;
            this.communicationDateEnd = _data["communicationDateEnd"] ? new Date(_data["communicationDateEnd"].toString()) : <any>undefined;
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
            this.sortBy = _data["sortBy"];
            this.filterString = _data["filterString"];
        }
    }

    static fromJS(data: any): CommunicationSearchFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommunicationSearchFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programName"] = this.programName;
        data["jobNumber"] = this.jobNumber;
        data["orderNumber"] = this.orderNumber;
        data["orderDateStart"] = this.orderDateStart ? this.orderDateStart.toISOString() : <any>undefined;
        data["orderDateEnd"] = this.orderDateEnd ? this.orderDateEnd.toISOString() : <any>undefined;
        data["formId"] = this.formId;
        data["hcpLastName"] = this.hcpLastName;
        data["hcpFirstName"] = this.hcpFirstName;
        data["hcpKidNumber"] = this.hcpKidNumber;
        data["hcpsln"] = this.hcpsln;
        data["communicationId"] = this.communicationId;
        if (Array.isArray(this.communicationTypeIds)) {
            data["communicationTypeIds"] = [];
            for (let item of this.communicationTypeIds)
                data["communicationTypeIds"].push(item);
        }
        if (Array.isArray(this.communicationMethodIds)) {
            data["communicationMethodIds"] = [];
            for (let item of this.communicationMethodIds)
                data["communicationMethodIds"].push(item);
        }
        if (Array.isArray(this.communicationDirectionIds)) {
            data["communicationDirectionIds"] = [];
            for (let item of this.communicationDirectionIds)
                data["communicationDirectionIds"].push(item);
        }
        if (Array.isArray(this.communicationStatusIds)) {
            data["communicationStatusIds"] = [];
            for (let item of this.communicationStatusIds)
                data["communicationStatusIds"].push(item);
        }
        if (Array.isArray(this.inboundDocumentStatusIds)) {
            data["inboundDocumentStatusIds"] = [];
            for (let item of this.inboundDocumentStatusIds)
                data["inboundDocumentStatusIds"].push(item);
        }
        if (Array.isArray(this.outboundDocumentStatusIds)) {
            data["outboundDocumentStatusIds"] = [];
            for (let item of this.outboundDocumentStatusIds)
                data["outboundDocumentStatusIds"].push(item);
        }
        data["communicationDateStart"] = this.communicationDateStart ? this.communicationDateStart.toISOString() : <any>undefined;
        data["communicationDateEnd"] = this.communicationDateEnd ? this.communicationDateEnd.toISOString() : <any>undefined;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        data["sortBy"] = this.sortBy;
        data["filterString"] = this.filterString;
        return data; 
    }

    clone(): CommunicationSearchFilterDto {
        const json = this.toJSON();
        let result = new CommunicationSearchFilterDto();
        result.init(json);
        return result;
    }
}

export interface ICommunicationSearchFilterDto {
    programName: string | undefined;
    jobNumber: string | undefined;
    orderNumber: string | undefined;
    orderDateStart: Date | undefined;
    orderDateEnd: Date | undefined;
    formId: string | undefined;
    hcpLastName: string | undefined;
    hcpFirstName: string | undefined;
    hcpKidNumber: string | undefined;
    hcpsln: string | undefined;
    communicationId: string | undefined;
    communicationTypeIds: string[] | undefined;
    communicationMethodIds: string[] | undefined;
    communicationDirectionIds: string[] | undefined;
    communicationStatusIds: string[] | undefined;
    inboundDocumentStatusIds: string[] | undefined;
    outboundDocumentStatusIds: string[] | undefined;
    communicationDateStart: Date | undefined;
    communicationDateEnd: Date | undefined;
    pageSize: number | undefined;
    pageNumber: number | undefined;
    sortBy: string | undefined;
    filterString: string | undefined;
}

export class AjaxResponseOfPagedResultOfCommunicationSearchDto implements IAjaxResponseOfPagedResultOfCommunicationSearchDto {
    result: PagedResultOfCommunicationSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfPagedResultOfCommunicationSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PagedResultOfCommunicationSearchDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfPagedResultOfCommunicationSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfPagedResultOfCommunicationSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfPagedResultOfCommunicationSearchDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfPagedResultOfCommunicationSearchDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfPagedResultOfCommunicationSearchDto {
    result: PagedResultOfCommunicationSearchDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class PagedResultOfCommunicationSearchDto implements IPagedResultOfCommunicationSearchDto {
    totalCount: number | undefined;
    items: CommunicationSearchDto[] | undefined;

    constructor(data?: IPagedResultOfCommunicationSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CommunicationSearchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfCommunicationSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfCommunicationSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultOfCommunicationSearchDto {
        const json = this.toJSON();
        let result = new PagedResultOfCommunicationSearchDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultOfCommunicationSearchDto {
    totalCount: number | undefined;
    items: CommunicationSearchDto[] | undefined;
}

export class ErrorInfo implements IErrorInfo {
    code: number | undefined;
    message: string | undefined;
    details: string | undefined;
    validationErrors: ValidationErrorInfo[] | undefined;

    constructor(data?: IErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.details = _data["details"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors.push(ValidationErrorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ErrorInfo {
        const json = this.toJSON();
        let result = new ErrorInfo();
        result.init(json);
        return result;
    }
}

export interface IErrorInfo {
    code: number | undefined;
    message: string | undefined;
    details: string | undefined;
    validationErrors: ValidationErrorInfo[] | undefined;
}

export class CommunicationSearchDto implements ICommunicationSearchDto {
    readonly hcpFullName: string | undefined;
    hcpFirstName: string | undefined;
    hcpLastName: string | undefined;
    hcpKidNumber: string | undefined;
    hcpSln: string | undefined;
    orderNumber: string | undefined;
    orderDate: Date | undefined;
    programName: string | undefined;
    jobNumber: string | undefined;
    communicationId: string | undefined;
    communicationTypeId: string | undefined;
    communicationStatusId: string | undefined;
    communicationDate: Date | undefined;
    formId: string | undefined;
    communicationDirectionId: string | undefined;
    communicationMethodId: string | undefined;
    documentStatusId: string | undefined;
    id: string | undefined;

    constructor(data?: ICommunicationSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).hcpFullName = _data["hcpFullName"];
            this.hcpFirstName = _data["hcpFirstName"];
            this.hcpLastName = _data["hcpLastName"];
            this.hcpKidNumber = _data["hcpKidNumber"];
            this.hcpSln = _data["hcpSln"];
            this.orderNumber = _data["orderNumber"];
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.programName = _data["programName"];
            this.jobNumber = _data["jobNumber"];
            this.communicationId = _data["communicationId"];
            this.communicationTypeId = _data["communicationTypeId"];
            this.communicationStatusId = _data["communicationStatusId"];
            this.communicationDate = _data["communicationDate"] ? new Date(_data["communicationDate"].toString()) : <any>undefined;
            this.formId = _data["formId"];
            this.communicationDirectionId = _data["communicationDirectionId"];
            this.communicationMethodId = _data["communicationMethodId"];
            this.documentStatusId = _data["documentStatusId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommunicationSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommunicationSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hcpFullName"] = this.hcpFullName;
        data["hcpFirstName"] = this.hcpFirstName;
        data["hcpLastName"] = this.hcpLastName;
        data["hcpKidNumber"] = this.hcpKidNumber;
        data["hcpSln"] = this.hcpSln;
        data["orderNumber"] = this.orderNumber;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["programName"] = this.programName;
        data["jobNumber"] = this.jobNumber;
        data["communicationId"] = this.communicationId;
        data["communicationTypeId"] = this.communicationTypeId;
        data["communicationStatusId"] = this.communicationStatusId;
        data["communicationDate"] = this.communicationDate ? this.communicationDate.toISOString() : <any>undefined;
        data["formId"] = this.formId;
        data["communicationDirectionId"] = this.communicationDirectionId;
        data["communicationMethodId"] = this.communicationMethodId;
        data["documentStatusId"] = this.documentStatusId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CommunicationSearchDto {
        const json = this.toJSON();
        let result = new CommunicationSearchDto();
        result.init(json);
        return result;
    }
}

export interface ICommunicationSearchDto {
    hcpFullName: string | undefined;
    hcpFirstName: string | undefined;
    hcpLastName: string | undefined;
    hcpKidNumber: string | undefined;
    hcpSln: string | undefined;
    orderNumber: string | undefined;
    orderDate: Date | undefined;
    programName: string | undefined;
    jobNumber: string | undefined;
    communicationId: string | undefined;
    communicationTypeId: string | undefined;
    communicationStatusId: string | undefined;
    communicationDate: Date | undefined;
    formId: string | undefined;
    communicationDirectionId: string | undefined;
    communicationMethodId: string | undefined;
    documentStatusId: string | undefined;
    id: string | undefined;
}

export class ValidationErrorInfo implements IValidationErrorInfo {
    message: string | undefined;
    members: string[] | undefined;

    constructor(data?: IValidationErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data; 
    }

    clone(): ValidationErrorInfo {
        const json = this.toJSON();
        let result = new ValidationErrorInfo();
        result.init(json);
        return result;
    }
}

export interface IValidationErrorInfo {
    message: string | undefined;
    members: string[] | undefined;
}

export class AjaxResponseOfIListOfCommunicationSearchDto implements IAjaxResponseOfIListOfCommunicationSearchDto {
    result: CommunicationSearchDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfIListOfCommunicationSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(CommunicationSearchDto.fromJS(item));
            }
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfIListOfCommunicationSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfIListOfCommunicationSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfIListOfCommunicationSearchDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfIListOfCommunicationSearchDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfIListOfCommunicationSearchDto {
    result: CommunicationSearchDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class AjaxResponseOfCommunicationDetailDto implements IAjaxResponseOfCommunicationDetailDto {
    result: CommunicationDetailDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfCommunicationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CommunicationDetailDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfCommunicationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfCommunicationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfCommunicationDetailDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfCommunicationDetailDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfCommunicationDetailDto {
    result: CommunicationDetailDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class CommunicationDetailDto implements ICommunicationDetailDto {
    id: string | undefined;
    readonly requestorName: string | undefined;
    hcpFirstName: string | undefined;
    hcpLastName: string | undefined;
    hcpKid: string | undefined;
    communicationId: string | undefined;
    formId: string | undefined;
    communicationTypeId: string | undefined;
    communicationDirectionId: string | undefined;
    communicationStatusId: string | undefined;
    communicationDate: Date | undefined;
    documentAttachment: string | undefined;
    documentFileName: string | undefined;
    documentStatusId: string | undefined;
    isDocumentGenerated: boolean | undefined;
    client: string | undefined;
    programName: string | undefined;
    jobId: string | undefined;
    orderNumber: string | undefined;
    orderId: string | undefined;
    orderReceivedDate: string | undefined;
    createdBy: number | undefined;
    createdTime: Date | undefined;
    modifiedBy: number | undefined;
    modifiedTime: Date | undefined;
    aocId: string | undefined;
    svlId: string | undefined;
    isResendableFlag: boolean | undefined;
    recipientSenderType: string | undefined;
    communicationHistory: CommunicationHistoryDto[] | undefined;
    names: LocalizedValue[] | undefined;

    constructor(data?: ICommunicationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).requestorName = _data["requestorName"];
            this.hcpFirstName = _data["hcpFirstName"];
            this.hcpLastName = _data["hcpLastName"];
            this.hcpKid = _data["hcpKid"];
            this.communicationId = _data["communicationId"];
            this.formId = _data["formId"];
            this.communicationTypeId = _data["communicationTypeId"];
            this.communicationDirectionId = _data["communicationDirectionId"];
            this.communicationStatusId = _data["communicationStatusId"];
            this.communicationDate = _data["communicationDate"] ? new Date(_data["communicationDate"].toString()) : <any>undefined;
            this.documentAttachment = _data["documentAttachment"];
            this.documentFileName = _data["documentFileName"];
            this.documentStatusId = _data["documentStatusId"];
            this.isDocumentGenerated = _data["isDocumentGenerated"];
            this.client = _data["client"];
            this.programName = _data["programName"];
            this.jobId = _data["jobId"];
            this.orderNumber = _data["orderNumber"];
            this.orderId = _data["orderId"];
            this.orderReceivedDate = _data["orderReceivedDate"];
            this.createdBy = _data["createdBy"];
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>undefined;
            this.aocId = _data["aocId"];
            this.svlId = _data["svlId"];
            this.isResendableFlag = _data["isResendableFlag"];
            this.recipientSenderType = _data["recipientSenderType"];
            if (Array.isArray(_data["communicationHistory"])) {
                this.communicationHistory = [] as any;
                for (let item of _data["communicationHistory"])
                    this.communicationHistory.push(CommunicationHistoryDto.fromJS(item));
            }
            if (Array.isArray(_data["names"])) {
                this.names = [] as any;
                for (let item of _data["names"])
                    this.names.push(LocalizedValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommunicationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommunicationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requestorName"] = this.requestorName;
        data["hcpFirstName"] = this.hcpFirstName;
        data["hcpLastName"] = this.hcpLastName;
        data["hcpKid"] = this.hcpKid;
        data["communicationId"] = this.communicationId;
        data["formId"] = this.formId;
        data["communicationTypeId"] = this.communicationTypeId;
        data["communicationDirectionId"] = this.communicationDirectionId;
        data["communicationStatusId"] = this.communicationStatusId;
        data["communicationDate"] = this.communicationDate ? this.communicationDate.toISOString() : <any>undefined;
        data["documentAttachment"] = this.documentAttachment;
        data["documentFileName"] = this.documentFileName;
        data["documentStatusId"] = this.documentStatusId;
        data["isDocumentGenerated"] = this.isDocumentGenerated;
        data["client"] = this.client;
        data["programName"] = this.programName;
        data["jobId"] = this.jobId;
        data["orderNumber"] = this.orderNumber;
        data["orderId"] = this.orderId;
        data["orderReceivedDate"] = this.orderReceivedDate;
        data["createdBy"] = this.createdBy;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>undefined;
        data["aocId"] = this.aocId;
        data["svlId"] = this.svlId;
        data["isResendableFlag"] = this.isResendableFlag;
        data["recipientSenderType"] = this.recipientSenderType;
        if (Array.isArray(this.communicationHistory)) {
            data["communicationHistory"] = [];
            for (let item of this.communicationHistory)
                data["communicationHistory"].push(item.toJSON());
        }
        if (Array.isArray(this.names)) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CommunicationDetailDto {
        const json = this.toJSON();
        let result = new CommunicationDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICommunicationDetailDto {
    id: string | undefined;
    requestorName: string | undefined;
    hcpFirstName: string | undefined;
    hcpLastName: string | undefined;
    hcpKid: string | undefined;
    communicationId: string | undefined;
    formId: string | undefined;
    communicationTypeId: string | undefined;
    communicationDirectionId: string | undefined;
    communicationStatusId: string | undefined;
    communicationDate: Date | undefined;
    documentAttachment: string | undefined;
    documentFileName: string | undefined;
    documentStatusId: string | undefined;
    isDocumentGenerated: boolean | undefined;
    client: string | undefined;
    programName: string | undefined;
    jobId: string | undefined;
    orderNumber: string | undefined;
    orderId: string | undefined;
    orderReceivedDate: string | undefined;
    createdBy: number | undefined;
    createdTime: Date | undefined;
    modifiedBy: number | undefined;
    modifiedTime: Date | undefined;
    aocId: string | undefined;
    svlId: string | undefined;
    isResendableFlag: boolean | undefined;
    recipientSenderType: string | undefined;
    communicationHistory: CommunicationHistoryDto[] | undefined;
    names: LocalizedValue[] | undefined;
}

export class CommunicationHistoryDto implements ICommunicationHistoryDto {
    id: string | undefined;
    activityType: string | undefined;
    communicationStatusId: string | undefined;
    documentStatusId: string | undefined;
    modifiedBy: number | undefined;
    modifiedDateTime: Date | undefined;
    communicationMethodId: string | undefined;
    communicationActivityText: string | undefined;
    comment: string | undefined;
    methodDescription: string | undefined;

    constructor(data?: ICommunicationHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.activityType = _data["activityType"];
            this.communicationStatusId = _data["communicationStatusId"];
            this.documentStatusId = _data["documentStatusId"];
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>undefined;
            this.communicationMethodId = _data["communicationMethodId"];
            this.communicationActivityText = _data["communicationActivityText"];
            this.comment = _data["comment"];
            this.methodDescription = _data["methodDescription"];
        }
    }

    static fromJS(data: any): CommunicationHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommunicationHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityType"] = this.activityType;
        data["communicationStatusId"] = this.communicationStatusId;
        data["documentStatusId"] = this.documentStatusId;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>undefined;
        data["communicationMethodId"] = this.communicationMethodId;
        data["communicationActivityText"] = this.communicationActivityText;
        data["comment"] = this.comment;
        data["methodDescription"] = this.methodDescription;
        return data; 
    }

    clone(): CommunicationHistoryDto {
        const json = this.toJSON();
        let result = new CommunicationHistoryDto();
        result.init(json);
        return result;
    }
}

export interface ICommunicationHistoryDto {
    id: string | undefined;
    activityType: string | undefined;
    communicationStatusId: string | undefined;
    documentStatusId: string | undefined;
    modifiedBy: number | undefined;
    modifiedDateTime: Date | undefined;
    communicationMethodId: string | undefined;
    communicationActivityText: string | undefined;
    comment: string | undefined;
    methodDescription: string | undefined;
}

export class LocalizedValue implements ILocalizedValue {
    language: LocalizedValueLanguage | undefined;
    value: string | undefined;

    constructor(data?: ILocalizedValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LocalizedValue {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizedValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language;
        data["value"] = this.value;
        return data; 
    }

    clone(): LocalizedValue {
        const json = this.toJSON();
        let result = new LocalizedValue();
        result.init(json);
        return result;
    }
}

export interface ILocalizedValue {
    language: LocalizedValueLanguage | undefined;
    value: string | undefined;
}

export class CreateCommunicationRequestDto implements ICreateCommunicationRequestDto {
    communicationTypeId: string | undefined;
    communicationMethodId: string | undefined;
    communicationDateTime: Date | undefined;
    orderId: string | undefined;
    orderNumber: string | undefined;
    moduleId: string | undefined;
    formId: string | undefined;
    requestCode: string | undefined;
    documentLocation: DocumentLocation | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    referencedEntities: SamplicityReferencedEntity[] | undefined;
    context: { [key: string]: string; } | undefined;
    readonly creationTime: Date | undefined;

    constructor(data?: ICreateCommunicationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communicationTypeId = _data["communicationTypeId"];
            this.communicationMethodId = _data["communicationMethodId"];
            this.communicationDateTime = _data["communicationDateTime"] ? new Date(_data["communicationDateTime"].toString()) : <any>undefined;
            this.orderId = _data["orderId"];
            this.orderNumber = _data["orderNumber"];
            this.moduleId = _data["moduleId"];
            this.formId = _data["formId"];
            this.requestCode = _data["requestCode"];
            this.documentLocation = _data["documentLocation"] ? DocumentLocation.fromJS(_data["documentLocation"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["referencedEntities"])) {
                this.referencedEntities = [] as any;
                for (let item of _data["referencedEntities"])
                    this.referencedEntities.push(SamplicityReferencedEntity.fromJS(item));
            }
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        this.context[key] = _data["context"][key];
                }
            }
            (<any>this).creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateCommunicationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommunicationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communicationTypeId"] = this.communicationTypeId;
        data["communicationMethodId"] = this.communicationMethodId;
        data["communicationDateTime"] = this.communicationDateTime ? this.communicationDateTime.toISOString() : <any>undefined;
        data["orderId"] = this.orderId;
        data["orderNumber"] = this.orderNumber;
        data["moduleId"] = this.moduleId;
        data["formId"] = this.formId;
        data["requestCode"] = this.requestCode;
        data["documentLocation"] = this.documentLocation ? this.documentLocation.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        if (Array.isArray(this.referencedEntities)) {
            data["referencedEntities"] = [];
            for (let item of this.referencedEntities)
                data["referencedEntities"].push(item.toJSON());
        }
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    data["context"][key] = this.context[key];
            }
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CreateCommunicationRequestDto {
        const json = this.toJSON();
        let result = new CreateCommunicationRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCommunicationRequestDto {
    communicationTypeId: string | undefined;
    communicationMethodId: string | undefined;
    communicationDateTime: Date | undefined;
    orderId: string | undefined;
    orderNumber: string | undefined;
    moduleId: string | undefined;
    formId: string | undefined;
    requestCode: string | undefined;
    documentLocation: DocumentLocation | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    referencedEntities: SamplicityReferencedEntity[] | undefined;
    context: { [key: string]: string; } | undefined;
    creationTime: Date | undefined;
}

export class DocumentLocation implements IDocumentLocation {
    documentName: string | undefined;
    documentDescription: string | undefined;
    contentType: string | undefined;
    documentTemplateId: string | undefined;
    storageLocation: DocumentLocationStorageLocation | undefined;
    blobLocation: AzureBlobLocation | undefined;
    databaseLocation: DatabaseLocation | undefined;
    sftpLocation: SftpLocation | undefined;
    inMemoryLocation: InMemoryDocumentLocation | undefined;
    fileShareLocation: AzureFileShareLocation | undefined;

    constructor(data?: IDocumentLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentName = _data["documentName"];
            this.documentDescription = _data["documentDescription"];
            this.contentType = _data["contentType"];
            this.documentTemplateId = _data["documentTemplateId"];
            this.storageLocation = _data["storageLocation"];
            this.blobLocation = _data["blobLocation"] ? AzureBlobLocation.fromJS(_data["blobLocation"]) : <any>undefined;
            this.databaseLocation = _data["databaseLocation"] ? DatabaseLocation.fromJS(_data["databaseLocation"]) : <any>undefined;
            this.sftpLocation = _data["sftpLocation"] ? SftpLocation.fromJS(_data["sftpLocation"]) : <any>undefined;
            this.inMemoryLocation = _data["inMemoryLocation"] ? InMemoryDocumentLocation.fromJS(_data["inMemoryLocation"]) : <any>undefined;
            this.fileShareLocation = _data["fileShareLocation"] ? AzureFileShareLocation.fromJS(_data["fileShareLocation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentLocation {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentName"] = this.documentName;
        data["documentDescription"] = this.documentDescription;
        data["contentType"] = this.contentType;
        data["documentTemplateId"] = this.documentTemplateId;
        data["storageLocation"] = this.storageLocation;
        data["blobLocation"] = this.blobLocation ? this.blobLocation.toJSON() : <any>undefined;
        data["databaseLocation"] = this.databaseLocation ? this.databaseLocation.toJSON() : <any>undefined;
        data["sftpLocation"] = this.sftpLocation ? this.sftpLocation.toJSON() : <any>undefined;
        data["inMemoryLocation"] = this.inMemoryLocation ? this.inMemoryLocation.toJSON() : <any>undefined;
        data["fileShareLocation"] = this.fileShareLocation ? this.fileShareLocation.toJSON() : <any>undefined;
        return data; 
    }

    clone(): DocumentLocation {
        const json = this.toJSON();
        let result = new DocumentLocation();
        result.init(json);
        return result;
    }
}

export interface IDocumentLocation {
    documentName: string | undefined;
    documentDescription: string | undefined;
    contentType: string | undefined;
    documentTemplateId: string | undefined;
    storageLocation: DocumentLocationStorageLocation | undefined;
    blobLocation: AzureBlobLocation | undefined;
    databaseLocation: DatabaseLocation | undefined;
    sftpLocation: SftpLocation | undefined;
    inMemoryLocation: InMemoryDocumentLocation | undefined;
    fileShareLocation: AzureFileShareLocation | undefined;
}

export class SamplicityReferencedEntity implements ISamplicityReferencedEntity {
    entityId: string | undefined;
    referencedEntityTypeClassificationId: string | undefined;
    attributes: SamplicityReferencedEntityAttribute[] | undefined;

    constructor(data?: ISamplicityReferencedEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.referencedEntityTypeClassificationId = _data["referencedEntityTypeClassificationId"];
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes.push(SamplicityReferencedEntityAttribute.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SamplicityReferencedEntity {
        data = typeof data === 'object' ? data : {};
        let result = new SamplicityReferencedEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["referencedEntityTypeClassificationId"] = this.referencedEntityTypeClassificationId;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SamplicityReferencedEntity {
        const json = this.toJSON();
        let result = new SamplicityReferencedEntity();
        result.init(json);
        return result;
    }
}

export interface ISamplicityReferencedEntity {
    entityId: string | undefined;
    referencedEntityTypeClassificationId: string | undefined;
    attributes: SamplicityReferencedEntityAttribute[] | undefined;
}

export class AzureBlobLocation implements IAzureBlobLocation {
    directory: string | undefined;
    filePathAndExtension: string | undefined;
    readonly contentType: string | undefined;

    constructor(data?: IAzureBlobLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.directory = _data["directory"];
            this.filePathAndExtension = _data["filePathAndExtension"];
            (<any>this).contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): AzureBlobLocation {
        data = typeof data === 'object' ? data : {};
        let result = new AzureBlobLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["directory"] = this.directory;
        data["filePathAndExtension"] = this.filePathAndExtension;
        data["contentType"] = this.contentType;
        return data; 
    }

    clone(): AzureBlobLocation {
        const json = this.toJSON();
        let result = new AzureBlobLocation();
        result.init(json);
        return result;
    }
}

export interface IAzureBlobLocation {
    directory: string | undefined;
    filePathAndExtension: string | undefined;
    contentType: string | undefined;
}

export class DatabaseLocation implements IDatabaseLocation {
    recordId: string | undefined;
    recordType: string | undefined;
    fieldName: string | undefined;

    constructor(data?: IDatabaseLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recordId = _data["recordId"];
            this.recordType = _data["recordType"];
            this.fieldName = _data["fieldName"];
        }
    }

    static fromJS(data: any): DatabaseLocation {
        data = typeof data === 'object' ? data : {};
        let result = new DatabaseLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recordId"] = this.recordId;
        data["recordType"] = this.recordType;
        data["fieldName"] = this.fieldName;
        return data; 
    }

    clone(): DatabaseLocation {
        const json = this.toJSON();
        let result = new DatabaseLocation();
        result.init(json);
        return result;
    }
}

export interface IDatabaseLocation {
    recordId: string | undefined;
    recordType: string | undefined;
    fieldName: string | undefined;
}

export class SftpLocation implements ISftpLocation {
    connection: SftpConnection | undefined;
    directory: string | undefined;
    filePathAndExtension: string | undefined;
    readonly contentType: string | undefined;

    constructor(data?: ISftpLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connection = _data["connection"] ? SftpConnection.fromJS(_data["connection"]) : <any>undefined;
            this.directory = _data["directory"];
            this.filePathAndExtension = _data["filePathAndExtension"];
            (<any>this).contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): SftpLocation {
        data = typeof data === 'object' ? data : {};
        let result = new SftpLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connection"] = this.connection ? this.connection.toJSON() : <any>undefined;
        data["directory"] = this.directory;
        data["filePathAndExtension"] = this.filePathAndExtension;
        data["contentType"] = this.contentType;
        return data; 
    }

    clone(): SftpLocation {
        const json = this.toJSON();
        let result = new SftpLocation();
        result.init(json);
        return result;
    }
}

export interface ISftpLocation {
    connection: SftpConnection | undefined;
    directory: string | undefined;
    filePathAndExtension: string | undefined;
    contentType: string | undefined;
}

export class InMemoryDocumentLocation implements IInMemoryDocumentLocation {
    documentContents: string | undefined;

    constructor(data?: IInMemoryDocumentLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentContents = _data["documentContents"];
        }
    }

    static fromJS(data: any): InMemoryDocumentLocation {
        data = typeof data === 'object' ? data : {};
        let result = new InMemoryDocumentLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentContents"] = this.documentContents;
        return data; 
    }

    clone(): InMemoryDocumentLocation {
        const json = this.toJSON();
        let result = new InMemoryDocumentLocation();
        result.init(json);
        return result;
    }
}

export interface IInMemoryDocumentLocation {
    documentContents: string | undefined;
}

export class AzureFileShareLocation implements IAzureFileShareLocation {
    fileShareName: string | undefined;
    directory: string | undefined;
    filePathAndExtension: string | undefined;
    readonly contentType: string | undefined;

    constructor(data?: IAzureFileShareLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileShareName = _data["fileShareName"];
            this.directory = _data["directory"];
            this.filePathAndExtension = _data["filePathAndExtension"];
            (<any>this).contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): AzureFileShareLocation {
        data = typeof data === 'object' ? data : {};
        let result = new AzureFileShareLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileShareName"] = this.fileShareName;
        data["directory"] = this.directory;
        data["filePathAndExtension"] = this.filePathAndExtension;
        data["contentType"] = this.contentType;
        return data; 
    }

    clone(): AzureFileShareLocation {
        const json = this.toJSON();
        let result = new AzureFileShareLocation();
        result.init(json);
        return result;
    }
}

export interface IAzureFileShareLocation {
    fileShareName: string | undefined;
    directory: string | undefined;
    filePathAndExtension: string | undefined;
    contentType: string | undefined;
}

export class SamplicityReferencedEntityAttribute implements ISamplicityReferencedEntityAttribute {
    attributeTypeClassificationId: string | undefined;
    attributeValueText: string | undefined;

    constructor(data?: ISamplicityReferencedEntityAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeTypeClassificationId = _data["attributeTypeClassificationId"];
            this.attributeValueText = _data["attributeValueText"];
        }
    }

    static fromJS(data: any): SamplicityReferencedEntityAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new SamplicityReferencedEntityAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeTypeClassificationId"] = this.attributeTypeClassificationId;
        data["attributeValueText"] = this.attributeValueText;
        return data; 
    }

    clone(): SamplicityReferencedEntityAttribute {
        const json = this.toJSON();
        let result = new SamplicityReferencedEntityAttribute();
        result.init(json);
        return result;
    }
}

export interface ISamplicityReferencedEntityAttribute {
    attributeTypeClassificationId: string | undefined;
    attributeValueText: string | undefined;
}

export class SftpConnection implements ISftpConnection {
    host: string | undefined;
    username: string | undefined;
    password: string | undefined;

    constructor(data?: ISftpConnection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SftpConnection {
        data = typeof data === 'object' ? data : {};
        let result = new SftpConnection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }

    clone(): SftpConnection {
        const json = this.toJSON();
        let result = new SftpConnection();
        result.init(json);
        return result;
    }
}

export interface ISftpConnection {
    host: string | undefined;
    username: string | undefined;
    password: string | undefined;
}

export class AjaxResponseOfCreateCommunicationResponseDto implements IAjaxResponseOfCreateCommunicationResponseDto {
    result: CreateCommunicationResponseDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfCreateCommunicationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CreateCommunicationResponseDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfCreateCommunicationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfCreateCommunicationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfCreateCommunicationResponseDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfCreateCommunicationResponseDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfCreateCommunicationResponseDto {
    result: CreateCommunicationResponseDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class CreateCommunicationResponseDto implements ICreateCommunicationResponseDto {
    referencedEntities: SamplicityReferencedEntity[] | undefined;
    context: { [key: string]: string; } | undefined;
    readonly creationTime: Date | undefined;
    success: boolean | undefined;
    errorMessage: string | undefined;

    constructor(data?: ICreateCommunicationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["referencedEntities"])) {
                this.referencedEntities = [] as any;
                for (let item of _data["referencedEntities"])
                    this.referencedEntities.push(SamplicityReferencedEntity.fromJS(item));
            }
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        this.context[key] = _data["context"][key];
                }
            }
            (<any>this).creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): CreateCommunicationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommunicationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.referencedEntities)) {
            data["referencedEntities"] = [];
            for (let item of this.referencedEntities)
                data["referencedEntities"].push(item.toJSON());
        }
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    data["context"][key] = this.context[key];
            }
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        return data; 
    }

    clone(): CreateCommunicationResponseDto {
        const json = this.toJSON();
        let result = new CreateCommunicationResponseDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCommunicationResponseDto {
    referencedEntities: SamplicityReferencedEntity[] | undefined;
    context: { [key: string]: string; } | undefined;
    creationTime: Date | undefined;
    success: boolean | undefined;
    errorMessage: string | undefined;
}

export class CommunicationResendDto implements ICommunicationResendDto {
    id: string | undefined;
    parentId: string | undefined;
    activityType: string | undefined;
    communicationMethodId: string | undefined;
    toEmails: string[] | undefined;
    faxNumber: string | undefined;
    comment: string | undefined;
    subject: string | undefined;
    childCommunicationInternalNbr: string | undefined;
    names: LocalizedValue[] | undefined;

    constructor(data?: ICommunicationResendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.activityType = _data["activityType"];
            this.communicationMethodId = _data["communicationMethodId"];
            if (Array.isArray(_data["toEmails"])) {
                this.toEmails = [] as any;
                for (let item of _data["toEmails"])
                    this.toEmails.push(item);
            }
            this.faxNumber = _data["faxNumber"];
            this.comment = _data["comment"];
            this.subject = _data["subject"];
            this.childCommunicationInternalNbr = _data["childCommunicationInternalNbr"];
            if (Array.isArray(_data["names"])) {
                this.names = [] as any;
                for (let item of _data["names"])
                    this.names.push(LocalizedValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommunicationResendDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommunicationResendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["activityType"] = this.activityType;
        data["communicationMethodId"] = this.communicationMethodId;
        if (Array.isArray(this.toEmails)) {
            data["toEmails"] = [];
            for (let item of this.toEmails)
                data["toEmails"].push(item);
        }
        data["faxNumber"] = this.faxNumber;
        data["comment"] = this.comment;
        data["subject"] = this.subject;
        data["childCommunicationInternalNbr"] = this.childCommunicationInternalNbr;
        if (Array.isArray(this.names)) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CommunicationResendDto {
        const json = this.toJSON();
        let result = new CommunicationResendDto();
        result.init(json);
        return result;
    }
}

export interface ICommunicationResendDto {
    id: string | undefined;
    parentId: string | undefined;
    activityType: string | undefined;
    communicationMethodId: string | undefined;
    toEmails: string[] | undefined;
    faxNumber: string | undefined;
    comment: string | undefined;
    subject: string | undefined;
    childCommunicationInternalNbr: string | undefined;
    names: LocalizedValue[] | undefined;
}

export class AjaxResponseOfListOfDocumentTemplateDto implements IAjaxResponseOfListOfDocumentTemplateDto {
    result: DocumentTemplateDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfListOfDocumentTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(DocumentTemplateDto.fromJS(item));
            }
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfListOfDocumentTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfListOfDocumentTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfListOfDocumentTemplateDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfListOfDocumentTemplateDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfListOfDocumentTemplateDto {
    result: DocumentTemplateDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class DocumentTemplateDto implements IDocumentTemplateDto {
    documentTemplateId: string | undefined;
    templateTypeClassificationValueId: string | undefined;
    currentStatusClassificationValueId: string | undefined;
    standardFlag: boolean | undefined;
    templateName: string | undefined;
    templateDescription: string | undefined;

    constructor(data?: IDocumentTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentTemplateId = _data["documentTemplateId"];
            this.templateTypeClassificationValueId = _data["templateTypeClassificationValueId"];
            this.currentStatusClassificationValueId = _data["currentStatusClassificationValueId"];
            this.standardFlag = _data["standardFlag"];
            this.templateName = _data["templateName"];
            this.templateDescription = _data["templateDescription"];
        }
    }

    static fromJS(data: any): DocumentTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentTemplateId"] = this.documentTemplateId;
        data["templateTypeClassificationValueId"] = this.templateTypeClassificationValueId;
        data["currentStatusClassificationValueId"] = this.currentStatusClassificationValueId;
        data["standardFlag"] = this.standardFlag;
        data["templateName"] = this.templateName;
        data["templateDescription"] = this.templateDescription;
        return data; 
    }

    clone(): DocumentTemplateDto {
        const json = this.toJSON();
        let result = new DocumentTemplateDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentTemplateDto {
    documentTemplateId: string | undefined;
    templateTypeClassificationValueId: string | undefined;
    currentStatusClassificationValueId: string | undefined;
    standardFlag: boolean | undefined;
    templateName: string | undefined;
    templateDescription: string | undefined;
}

export class AjaxResponseOfEntityDto implements IAjaxResponseOfEntityDto {
    result: EntityDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? EntityDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfEntityDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfEntityDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfEntityDto {
    result: EntityDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class EntityDto implements IEntityDto {
    entityId: string | undefined;
    entityTypeClassificationValueId: string | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.entityTypeClassificationValueId = _data["entityTypeClassificationValueId"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["entityTypeClassificationValueId"] = this.entityTypeClassificationValueId;
        return data; 
    }

    clone(): EntityDto {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    entityId: string | undefined;
    entityTypeClassificationValueId: string | undefined;
}

export class AjaxResponseOfBoolean implements IAjaxResponseOfBoolean {
    result: boolean | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfBoolean {
        const json = this.toJSON();
        let result = new AjaxResponseOfBoolean();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfBoolean {
    result: boolean | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class AjaxResponseOfString implements IAjaxResponseOfString {
    result: string | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfString {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfString {
        const json = this.toJSON();
        let result = new AjaxResponseOfString();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfString {
    result: string | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class AjaxResponseOfListOfDocumentDto implements IAjaxResponseOfListOfDocumentDto {
    result: DocumentDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfListOfDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(DocumentDto.fromJS(item));
            }
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfListOfDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfListOfDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfListOfDocumentDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfListOfDocumentDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfListOfDocumentDto {
    result: DocumentDto[] | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class DocumentDto implements IDocumentDto {
    currentStatusClassificationValueId: string | undefined;
    documentTypeClassificationValueId: string | undefined;
    documentTemplateId: string | undefined;
    formId: string | undefined;
    documentName: string | undefined;
    documentPathText: string | undefined;
    documentFileName: string | undefined;
    commentsText: string | undefined;
    documentDesc: string | undefined;
    documentCreationTime: Date | undefined;

    constructor(data?: IDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentStatusClassificationValueId = _data["currentStatusClassificationValueId"];
            this.documentTypeClassificationValueId = _data["documentTypeClassificationValueId"];
            this.documentTemplateId = _data["documentTemplateId"];
            this.formId = _data["formId"];
            this.documentName = _data["documentName"];
            this.documentPathText = _data["documentPathText"];
            this.documentFileName = _data["documentFileName"];
            this.commentsText = _data["commentsText"];
            this.documentDesc = _data["documentDesc"];
            this.documentCreationTime = _data["documentCreationTime"] ? new Date(_data["documentCreationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentStatusClassificationValueId"] = this.currentStatusClassificationValueId;
        data["documentTypeClassificationValueId"] = this.documentTypeClassificationValueId;
        data["documentTemplateId"] = this.documentTemplateId;
        data["formId"] = this.formId;
        data["documentName"] = this.documentName;
        data["documentPathText"] = this.documentPathText;
        data["documentFileName"] = this.documentFileName;
        data["commentsText"] = this.commentsText;
        data["documentDesc"] = this.documentDesc;
        data["documentCreationTime"] = this.documentCreationTime ? this.documentCreationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): DocumentDto {
        const json = this.toJSON();
        let result = new DocumentDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentDto {
    currentStatusClassificationValueId: string | undefined;
    documentTypeClassificationValueId: string | undefined;
    documentTemplateId: string | undefined;
    formId: string | undefined;
    documentName: string | undefined;
    documentPathText: string | undefined;
    documentFileName: string | undefined;
    commentsText: string | undefined;
    documentDesc: string | undefined;
    documentCreationTime: Date | undefined;
}

export class AjaxResponseOfNullableOfDateTime implements IAjaxResponseOfNullableOfDateTime {
    result: Date | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfNullableOfDateTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? new Date(_data["result"].toString()) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfNullableOfDateTime {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfNullableOfDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toISOString() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfNullableOfDateTime {
        const json = this.toJSON();
        let result = new AjaxResponseOfNullableOfDateTime();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfNullableOfDateTime {
    result: Date | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class AjaxResponseOfSimpleCommunicationDto implements IAjaxResponseOfSimpleCommunicationDto {
    result: SimpleCommunicationDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfSimpleCommunicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? SimpleCommunicationDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfSimpleCommunicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfSimpleCommunicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfSimpleCommunicationDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfSimpleCommunicationDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfSimpleCommunicationDto {
    result: SimpleCommunicationDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class SimpleCommunicationDto implements ISimpleCommunicationDto {
    orderId: string | undefined;
    communicationId: string | undefined;
    communicationTypeId: string | undefined;
    communicationStatusId: string | undefined;
    communicationDate: Date | undefined;
    documentId: string | undefined;
    id: string | undefined;

    constructor(data?: ISimpleCommunicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.communicationId = _data["communicationId"];
            this.communicationTypeId = _data["communicationTypeId"];
            this.communicationStatusId = _data["communicationStatusId"];
            this.communicationDate = _data["communicationDate"] ? new Date(_data["communicationDate"].toString()) : <any>undefined;
            this.documentId = _data["documentId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimpleCommunicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleCommunicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["communicationId"] = this.communicationId;
        data["communicationTypeId"] = this.communicationTypeId;
        data["communicationStatusId"] = this.communicationStatusId;
        data["communicationDate"] = this.communicationDate ? this.communicationDate.toISOString() : <any>undefined;
        data["documentId"] = this.documentId;
        data["id"] = this.id;
        return data; 
    }

    clone(): SimpleCommunicationDto {
        const json = this.toJSON();
        let result = new SimpleCommunicationDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleCommunicationDto {
    orderId: string | undefined;
    communicationId: string | undefined;
    communicationTypeId: string | undefined;
    communicationStatusId: string | undefined;
    communicationDate: Date | undefined;
    documentId: string | undefined;
    id: string | undefined;
}

export class DocumentGenerationRequest implements IDocumentGenerationRequest {
    options: DocumentGenerationOptions | undefined;
    documentBody: DocumentFragment | undefined;
    documentHeader: DocumentFragment | undefined;
    documentFooter: DocumentFragment | undefined;
    context: { [key: string]: string; } | undefined;
    referencedEntities: SamplicityReferencedEntity[] | undefined;

    constructor(data?: IDocumentGenerationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.options = _data["options"] ? DocumentGenerationOptions.fromJS(_data["options"]) : <any>undefined;
            this.documentBody = _data["documentBody"] ? DocumentFragment.fromJS(_data["documentBody"]) : <any>undefined;
            this.documentHeader = _data["documentHeader"] ? DocumentFragment.fromJS(_data["documentHeader"]) : <any>undefined;
            this.documentFooter = _data["documentFooter"] ? DocumentFragment.fromJS(_data["documentFooter"]) : <any>undefined;
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        this.context[key] = _data["context"][key];
                }
            }
            if (Array.isArray(_data["referencedEntities"])) {
                this.referencedEntities = [] as any;
                for (let item of _data["referencedEntities"])
                    this.referencedEntities.push(SamplicityReferencedEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentGenerationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentGenerationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        data["documentBody"] = this.documentBody ? this.documentBody.toJSON() : <any>undefined;
        data["documentHeader"] = this.documentHeader ? this.documentHeader.toJSON() : <any>undefined;
        data["documentFooter"] = this.documentFooter ? this.documentFooter.toJSON() : <any>undefined;
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    data["context"][key] = this.context[key];
            }
        }
        if (Array.isArray(this.referencedEntities)) {
            data["referencedEntities"] = [];
            for (let item of this.referencedEntities)
                data["referencedEntities"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DocumentGenerationRequest {
        const json = this.toJSON();
        let result = new DocumentGenerationRequest();
        result.init(json);
        return result;
    }
}

export interface IDocumentGenerationRequest {
    options: DocumentGenerationOptions | undefined;
    documentBody: DocumentFragment | undefined;
    documentHeader: DocumentFragment | undefined;
    documentFooter: DocumentFragment | undefined;
    context: { [key: string]: string; } | undefined;
    referencedEntities: SamplicityReferencedEntity[] | undefined;
}

export class DocumentGenerationOptions implements IDocumentGenerationOptions {
    format: DocumentGenerationOptionsFormat | undefined;
    fileName: string | undefined;
    filePath: string | undefined;
    fileNameHasTimestampFlag: boolean | undefined;
    persistence: DocumentGenerationOptionsPersistence | undefined;
    documentRecordOptions: DocumentGenerationOptionsDocumentRecordOptions | undefined;
    documentRecordTypeId: string | undefined;
    singlePage: boolean | undefined;
    appendPage: boolean | undefined;
    appendPageLocation: string | undefined;
    communicationRecordOptions: DocumentGenerationOptionsCommunicationRecordOptions | undefined;
    communicationRecordTypeId: string | undefined;
    throwGenerationError: boolean | undefined;
    throwGenerationErrorReason: string | undefined;

    constructor(data?: IDocumentGenerationOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.format = _data["format"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.fileNameHasTimestampFlag = _data["fileNameHasTimestampFlag"];
            this.persistence = _data["persistence"];
            this.documentRecordOptions = _data["documentRecordOptions"];
            this.documentRecordTypeId = _data["documentRecordTypeId"];
            this.singlePage = _data["singlePage"];
            this.appendPage = _data["appendPage"];
            this.appendPageLocation = _data["appendPageLocation"];
            this.communicationRecordOptions = _data["communicationRecordOptions"];
            this.communicationRecordTypeId = _data["communicationRecordTypeId"];
            this.throwGenerationError = _data["throwGenerationError"];
            this.throwGenerationErrorReason = _data["throwGenerationErrorReason"];
        }
    }

    static fromJS(data: any): DocumentGenerationOptions {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentGenerationOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["fileNameHasTimestampFlag"] = this.fileNameHasTimestampFlag;
        data["persistence"] = this.persistence;
        data["documentRecordOptions"] = this.documentRecordOptions;
        data["documentRecordTypeId"] = this.documentRecordTypeId;
        data["singlePage"] = this.singlePage;
        data["appendPage"] = this.appendPage;
        data["appendPageLocation"] = this.appendPageLocation;
        data["communicationRecordOptions"] = this.communicationRecordOptions;
        data["communicationRecordTypeId"] = this.communicationRecordTypeId;
        data["throwGenerationError"] = this.throwGenerationError;
        data["throwGenerationErrorReason"] = this.throwGenerationErrorReason;
        return data; 
    }

    clone(): DocumentGenerationOptions {
        const json = this.toJSON();
        let result = new DocumentGenerationOptions();
        result.init(json);
        return result;
    }
}

export interface IDocumentGenerationOptions {
    format: DocumentGenerationOptionsFormat | undefined;
    fileName: string | undefined;
    filePath: string | undefined;
    fileNameHasTimestampFlag: boolean | undefined;
    persistence: DocumentGenerationOptionsPersistence | undefined;
    documentRecordOptions: DocumentGenerationOptionsDocumentRecordOptions | undefined;
    documentRecordTypeId: string | undefined;
    singlePage: boolean | undefined;
    appendPage: boolean | undefined;
    appendPageLocation: string | undefined;
    communicationRecordOptions: DocumentGenerationOptionsCommunicationRecordOptions | undefined;
    communicationRecordTypeId: string | undefined;
    throwGenerationError: boolean | undefined;
    throwGenerationErrorReason: string | undefined;
}

export class DocumentFragment implements IDocumentFragment {
    outputFormat: DocumentFragmentOutputFormat | undefined;
    templateEngine: DocumentFragmentTemplateEngine | undefined;
    templateLocation: DocumentLocation | undefined;
    model: any | undefined;

    constructor(data?: IDocumentFragment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outputFormat = _data["outputFormat"];
            this.templateEngine = _data["templateEngine"];
            this.templateLocation = _data["templateLocation"] ? DocumentLocation.fromJS(_data["templateLocation"]) : <any>undefined;
            this.model = _data["model"];
        }
    }

    static fromJS(data: any): DocumentFragment {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentFragment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outputFormat"] = this.outputFormat;
        data["templateEngine"] = this.templateEngine;
        data["templateLocation"] = this.templateLocation ? this.templateLocation.toJSON() : <any>undefined;
        data["model"] = this.model;
        return data; 
    }

    clone(): DocumentFragment {
        const json = this.toJSON();
        let result = new DocumentFragment();
        result.init(json);
        return result;
    }
}

export interface IDocumentFragment {
    outputFormat: DocumentFragmentOutputFormat | undefined;
    templateEngine: DocumentFragmentTemplateEngine | undefined;
    templateLocation: DocumentLocation | undefined;
    model: any | undefined;
}

export class AjaxResponseOfDocumentGenerationResponse implements IAjaxResponseOfDocumentGenerationResponse {
    result: DocumentGenerationResponse | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfDocumentGenerationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? DocumentGenerationResponse.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfDocumentGenerationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfDocumentGenerationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfDocumentGenerationResponse {
        const json = this.toJSON();
        let result = new AjaxResponseOfDocumentGenerationResponse();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfDocumentGenerationResponse {
    result: DocumentGenerationResponse | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class DocumentGenerationResponse implements IDocumentGenerationResponse {
    generatedDocumentLocation: DocumentLocation | undefined;
    documentId: string | undefined;
    documentTemplateId: string | undefined;
    sequenceNumber: number | undefined;
    formId: string | undefined;
    communicationId: string | undefined;
    success: boolean | undefined;
    errorMessage: string | undefined;
    context: { [key: string]: string; } | undefined;

    constructor(data?: IDocumentGenerationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.generatedDocumentLocation = _data["generatedDocumentLocation"] ? DocumentLocation.fromJS(_data["generatedDocumentLocation"]) : <any>undefined;
            this.documentId = _data["documentId"];
            this.documentTemplateId = _data["documentTemplateId"];
            this.sequenceNumber = _data["sequenceNumber"];
            this.formId = _data["formId"];
            this.communicationId = _data["communicationId"];
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        this.context[key] = _data["context"][key];
                }
            }
        }
    }

    static fromJS(data: any): DocumentGenerationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentGenerationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generatedDocumentLocation"] = this.generatedDocumentLocation ? this.generatedDocumentLocation.toJSON() : <any>undefined;
        data["documentId"] = this.documentId;
        data["documentTemplateId"] = this.documentTemplateId;
        data["sequenceNumber"] = this.sequenceNumber;
        data["formId"] = this.formId;
        data["communicationId"] = this.communicationId;
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    data["context"][key] = this.context[key];
            }
        }
        return data; 
    }

    clone(): DocumentGenerationResponse {
        const json = this.toJSON();
        let result = new DocumentGenerationResponse();
        result.init(json);
        return result;
    }
}

export interface IDocumentGenerationResponse {
    generatedDocumentLocation: DocumentLocation | undefined;
    documentId: string | undefined;
    documentTemplateId: string | undefined;
    sequenceNumber: number | undefined;
    formId: string | undefined;
    communicationId: string | undefined;
    success: boolean | undefined;
    errorMessage: string | undefined;
    context: { [key: string]: string; } | undefined;
}

export class DocumentBatchGenerationRequest implements IDocumentBatchGenerationRequest {
    requests: DocumentGenerationRequest[] | undefined;
    context: { [key: string]: string; } | undefined;

    constructor(data?: IDocumentBatchGenerationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["requests"])) {
                this.requests = [] as any;
                for (let item of _data["requests"])
                    this.requests.push(DocumentGenerationRequest.fromJS(item));
            }
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        this.context[key] = _data["context"][key];
                }
            }
        }
    }

    static fromJS(data: any): DocumentBatchGenerationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentBatchGenerationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requests)) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    data["context"][key] = this.context[key];
            }
        }
        return data; 
    }

    clone(): DocumentBatchGenerationRequest {
        const json = this.toJSON();
        let result = new DocumentBatchGenerationRequest();
        result.init(json);
        return result;
    }
}

export interface IDocumentBatchGenerationRequest {
    requests: DocumentGenerationRequest[] | undefined;
    context: { [key: string]: string; } | undefined;
}

export class AjaxResponseOfDocumentBatchGenerationResponse implements IAjaxResponseOfDocumentBatchGenerationResponse {
    result: DocumentBatchGenerationResponse | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfDocumentBatchGenerationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? DocumentBatchGenerationResponse.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfDocumentBatchGenerationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfDocumentBatchGenerationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfDocumentBatchGenerationResponse {
        const json = this.toJSON();
        let result = new AjaxResponseOfDocumentBatchGenerationResponse();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfDocumentBatchGenerationResponse {
    result: DocumentBatchGenerationResponse | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class DocumentBatchGenerationResponse implements IDocumentBatchGenerationResponse {
    responses: DocumentGenerationResponse[] | undefined;
    success: boolean | undefined;
    errorMessage: string | undefined;
    context: { [key: string]: string; } | undefined;

    constructor(data?: IDocumentBatchGenerationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["responses"])) {
                this.responses = [] as any;
                for (let item of _data["responses"])
                    this.responses.push(DocumentGenerationResponse.fromJS(item));
            }
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        this.context[key] = _data["context"][key];
                }
            }
        }
    }

    static fromJS(data: any): DocumentBatchGenerationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentBatchGenerationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.responses)) {
            data["responses"] = [];
            for (let item of this.responses)
                data["responses"].push(item.toJSON());
        }
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    data["context"][key] = this.context[key];
            }
        }
        return data; 
    }

    clone(): DocumentBatchGenerationResponse {
        const json = this.toJSON();
        let result = new DocumentBatchGenerationResponse();
        result.init(json);
        return result;
    }
}

export interface IDocumentBatchGenerationResponse {
    responses: DocumentGenerationResponse[] | undefined;
    success: boolean | undefined;
    errorMessage: string | undefined;
    context: { [key: string]: string; } | undefined;
}

export class EmailRequest implements IEmailRequest {
    options: OutboundCommunicationOptions | undefined;
    emailToAddresses: string[] | undefined;
    emailCcAddresses: string[] | undefined;
    emailBccAddresses: string[] | undefined;
    subject: string | undefined;
    emailContent: DocumentLocation | undefined;
    attachments: DocumentLocation[] | undefined;
    context: { [key: string]: string; } | undefined;

    constructor(data?: IEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.options = _data["options"] ? OutboundCommunicationOptions.fromJS(_data["options"]) : <any>undefined;
            if (Array.isArray(_data["emailToAddresses"])) {
                this.emailToAddresses = [] as any;
                for (let item of _data["emailToAddresses"])
                    this.emailToAddresses.push(item);
            }
            if (Array.isArray(_data["emailCcAddresses"])) {
                this.emailCcAddresses = [] as any;
                for (let item of _data["emailCcAddresses"])
                    this.emailCcAddresses.push(item);
            }
            if (Array.isArray(_data["emailBccAddresses"])) {
                this.emailBccAddresses = [] as any;
                for (let item of _data["emailBccAddresses"])
                    this.emailBccAddresses.push(item);
            }
            this.subject = _data["subject"];
            this.emailContent = _data["emailContent"] ? DocumentLocation.fromJS(_data["emailContent"]) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(DocumentLocation.fromJS(item));
            }
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        this.context[key] = _data["context"][key];
                }
            }
        }
    }

    static fromJS(data: any): EmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        if (Array.isArray(this.emailToAddresses)) {
            data["emailToAddresses"] = [];
            for (let item of this.emailToAddresses)
                data["emailToAddresses"].push(item);
        }
        if (Array.isArray(this.emailCcAddresses)) {
            data["emailCcAddresses"] = [];
            for (let item of this.emailCcAddresses)
                data["emailCcAddresses"].push(item);
        }
        if (Array.isArray(this.emailBccAddresses)) {
            data["emailBccAddresses"] = [];
            for (let item of this.emailBccAddresses)
                data["emailBccAddresses"].push(item);
        }
        data["subject"] = this.subject;
        data["emailContent"] = this.emailContent ? this.emailContent.toJSON() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    data["context"][key] = this.context[key];
            }
        }
        return data; 
    }

    clone(): EmailRequest {
        const json = this.toJSON();
        let result = new EmailRequest();
        result.init(json);
        return result;
    }
}

export interface IEmailRequest {
    options: OutboundCommunicationOptions | undefined;
    emailToAddresses: string[] | undefined;
    emailCcAddresses: string[] | undefined;
    emailBccAddresses: string[] | undefined;
    subject: string | undefined;
    emailContent: DocumentLocation | undefined;
    attachments: DocumentLocation[] | undefined;
    context: { [key: string]: string; } | undefined;
}

export class OutboundCommunicationOptions implements IOutboundCommunicationOptions {
    communicationRecordOptions: OutboundCommunicationOptionsCommunicationRecordOptions | undefined;
    communicationIds: string[] | undefined;

    constructor(data?: IOutboundCommunicationOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communicationRecordOptions = _data["communicationRecordOptions"];
            if (Array.isArray(_data["communicationIds"])) {
                this.communicationIds = [] as any;
                for (let item of _data["communicationIds"])
                    this.communicationIds.push(item);
            }
        }
    }

    static fromJS(data: any): OutboundCommunicationOptions {
        data = typeof data === 'object' ? data : {};
        let result = new OutboundCommunicationOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communicationRecordOptions"] = this.communicationRecordOptions;
        if (Array.isArray(this.communicationIds)) {
            data["communicationIds"] = [];
            for (let item of this.communicationIds)
                data["communicationIds"].push(item);
        }
        return data; 
    }

    clone(): OutboundCommunicationOptions {
        const json = this.toJSON();
        let result = new OutboundCommunicationOptions();
        result.init(json);
        return result;
    }
}

export interface IOutboundCommunicationOptions {
    communicationRecordOptions: OutboundCommunicationOptionsCommunicationRecordOptions | undefined;
    communicationIds: string[] | undefined;
}

export class AjaxResponseOfEmailResponse implements IAjaxResponseOfEmailResponse {
    result: EmailResponse | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfEmailResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? EmailResponse.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfEmailResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfEmailResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfEmailResponse {
        const json = this.toJSON();
        let result = new AjaxResponseOfEmailResponse();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfEmailResponse {
    result: EmailResponse | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class EmailResponse implements IEmailResponse {
    emailTrackingId: string | undefined;
    emailToAddresses: string[] | undefined;
    emailBccAddresses: string[] | undefined;
    emailCcAddresses: string[] | undefined;
    success: boolean | undefined;
    errorMessage: string | undefined;
    context: { [key: string]: string; } | undefined;
    communicationIds: string[] | undefined;

    constructor(data?: IEmailResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailTrackingId = _data["emailTrackingId"];
            if (Array.isArray(_data["emailToAddresses"])) {
                this.emailToAddresses = [] as any;
                for (let item of _data["emailToAddresses"])
                    this.emailToAddresses.push(item);
            }
            if (Array.isArray(_data["emailBccAddresses"])) {
                this.emailBccAddresses = [] as any;
                for (let item of _data["emailBccAddresses"])
                    this.emailBccAddresses.push(item);
            }
            if (Array.isArray(_data["emailCcAddresses"])) {
                this.emailCcAddresses = [] as any;
                for (let item of _data["emailCcAddresses"])
                    this.emailCcAddresses.push(item);
            }
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        this.context[key] = _data["context"][key];
                }
            }
            if (Array.isArray(_data["communicationIds"])) {
                this.communicationIds = [] as any;
                for (let item of _data["communicationIds"])
                    this.communicationIds.push(item);
            }
        }
    }

    static fromJS(data: any): EmailResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EmailResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailTrackingId"] = this.emailTrackingId;
        if (Array.isArray(this.emailToAddresses)) {
            data["emailToAddresses"] = [];
            for (let item of this.emailToAddresses)
                data["emailToAddresses"].push(item);
        }
        if (Array.isArray(this.emailBccAddresses)) {
            data["emailBccAddresses"] = [];
            for (let item of this.emailBccAddresses)
                data["emailBccAddresses"].push(item);
        }
        if (Array.isArray(this.emailCcAddresses)) {
            data["emailCcAddresses"] = [];
            for (let item of this.emailCcAddresses)
                data["emailCcAddresses"].push(item);
        }
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    data["context"][key] = this.context[key];
            }
        }
        if (Array.isArray(this.communicationIds)) {
            data["communicationIds"] = [];
            for (let item of this.communicationIds)
                data["communicationIds"].push(item);
        }
        return data; 
    }

    clone(): EmailResponse {
        const json = this.toJSON();
        let result = new EmailResponse();
        result.init(json);
        return result;
    }
}

export interface IEmailResponse {
    emailTrackingId: string | undefined;
    emailToAddresses: string[] | undefined;
    emailBccAddresses: string[] | undefined;
    emailCcAddresses: string[] | undefined;
    success: boolean | undefined;
    errorMessage: string | undefined;
    context: { [key: string]: string; } | undefined;
    communicationIds: string[] | undefined;
}

export class FaxRequest implements IFaxRequest {
    options: OutboundCommunicationOptions | undefined;
    phoneNumber: string | undefined;
    attachment: DocumentLocation | undefined;
    context: { [key: string]: string; } | undefined;

    constructor(data?: IFaxRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.options = _data["options"] ? OutboundCommunicationOptions.fromJS(_data["options"]) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"];
            this.attachment = _data["attachment"] ? DocumentLocation.fromJS(_data["attachment"]) : <any>undefined;
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        this.context[key] = _data["context"][key];
                }
            }
        }
    }

    static fromJS(data: any): FaxRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FaxRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["attachment"] = this.attachment ? this.attachment.toJSON() : <any>undefined;
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    data["context"][key] = this.context[key];
            }
        }
        return data; 
    }

    clone(): FaxRequest {
        const json = this.toJSON();
        let result = new FaxRequest();
        result.init(json);
        return result;
    }
}

export interface IFaxRequest {
    options: OutboundCommunicationOptions | undefined;
    phoneNumber: string | undefined;
    attachment: DocumentLocation | undefined;
    context: { [key: string]: string; } | undefined;
}

export class AjaxResponseOfFaxResponse implements IAjaxResponseOfFaxResponse {
    result: FaxResponse | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfFaxResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? FaxResponse.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfFaxResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfFaxResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfFaxResponse {
        const json = this.toJSON();
        let result = new AjaxResponseOfFaxResponse();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfFaxResponse {
    result: FaxResponse | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class FaxResponse implements IFaxResponse {
    success: boolean | undefined;
    errorMessage: string | undefined;
    context: { [key: string]: string; } | undefined;
    communicationIds: string[] | undefined;

    constructor(data?: IFaxResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        this.context[key] = _data["context"][key];
                }
            }
            if (Array.isArray(_data["communicationIds"])) {
                this.communicationIds = [] as any;
                for (let item of _data["communicationIds"])
                    this.communicationIds.push(item);
            }
        }
    }

    static fromJS(data: any): FaxResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FaxResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    data["context"][key] = this.context[key];
            }
        }
        if (Array.isArray(this.communicationIds)) {
            data["communicationIds"] = [];
            for (let item of this.communicationIds)
                data["communicationIds"].push(item);
        }
        return data; 
    }

    clone(): FaxResponse {
        const json = this.toJSON();
        let result = new FaxResponse();
        result.init(json);
        return result;
    }
}

export interface IFaxResponse {
    success: boolean | undefined;
    errorMessage: string | undefined;
    context: { [key: string]: string; } | undefined;
    communicationIds: string[] | undefined;
}

export class EmailTemplateDto implements IEmailTemplateDto {
    emailTemplateTypeId: string | undefined;
    subject: string | undefined;
    body: DocumentLocation | undefined;
    fromEmail: string | undefined;
    toEmail: string[] | undefined;
    ccEmail: string[] | undefined;
    bccEmail: string[] | undefined;
    replyToEmail: string[] | undefined;
    importanceCode: string | undefined;
    sensitivityCode: string | undefined;

    constructor(data?: IEmailTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailTemplateTypeId = _data["emailTemplateTypeId"];
            this.subject = _data["subject"];
            this.body = _data["body"] ? DocumentLocation.fromJS(_data["body"]) : <any>undefined;
            this.fromEmail = _data["fromEmail"];
            if (Array.isArray(_data["toEmail"])) {
                this.toEmail = [] as any;
                for (let item of _data["toEmail"])
                    this.toEmail.push(item);
            }
            if (Array.isArray(_data["ccEmail"])) {
                this.ccEmail = [] as any;
                for (let item of _data["ccEmail"])
                    this.ccEmail.push(item);
            }
            if (Array.isArray(_data["bccEmail"])) {
                this.bccEmail = [] as any;
                for (let item of _data["bccEmail"])
                    this.bccEmail.push(item);
            }
            if (Array.isArray(_data["replyToEmail"])) {
                this.replyToEmail = [] as any;
                for (let item of _data["replyToEmail"])
                    this.replyToEmail.push(item);
            }
            this.importanceCode = _data["importanceCode"];
            this.sensitivityCode = _data["sensitivityCode"];
        }
    }

    static fromJS(data: any): EmailTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailTemplateTypeId"] = this.emailTemplateTypeId;
        data["subject"] = this.subject;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["fromEmail"] = this.fromEmail;
        if (Array.isArray(this.toEmail)) {
            data["toEmail"] = [];
            for (let item of this.toEmail)
                data["toEmail"].push(item);
        }
        if (Array.isArray(this.ccEmail)) {
            data["ccEmail"] = [];
            for (let item of this.ccEmail)
                data["ccEmail"].push(item);
        }
        if (Array.isArray(this.bccEmail)) {
            data["bccEmail"] = [];
            for (let item of this.bccEmail)
                data["bccEmail"].push(item);
        }
        if (Array.isArray(this.replyToEmail)) {
            data["replyToEmail"] = [];
            for (let item of this.replyToEmail)
                data["replyToEmail"].push(item);
        }
        data["importanceCode"] = this.importanceCode;
        data["sensitivityCode"] = this.sensitivityCode;
        return data; 
    }

    clone(): EmailTemplateDto {
        const json = this.toJSON();
        let result = new EmailTemplateDto();
        result.init(json);
        return result;
    }
}

export interface IEmailTemplateDto {
    emailTemplateTypeId: string | undefined;
    subject: string | undefined;
    body: DocumentLocation | undefined;
    fromEmail: string | undefined;
    toEmail: string[] | undefined;
    ccEmail: string[] | undefined;
    bccEmail: string[] | undefined;
    replyToEmail: string[] | undefined;
    importanceCode: string | undefined;
    sensitivityCode: string | undefined;
}

export class PdfConversionRequestDto implements IPdfConversionRequestDto {
    saveLocation: PdfConversionRequestDtoSaveLocation | undefined;
    headerDocument: DocumentLocation | undefined;
    bodyDocument: DocumentLocation | undefined;
    footerDocument: DocumentLocation | undefined;
    singlePageFlag: boolean | undefined;
    appendPageFlag: boolean | undefined;
    appendPageLocation: string | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    referencedEntities: SamplicityReferencedEntity[] | undefined;
    context: { [key: string]: string; } | undefined;
    readonly creationTime: Date | undefined;

    constructor(data?: IPdfConversionRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.saveLocation = _data["saveLocation"];
            this.headerDocument = _data["headerDocument"] ? DocumentLocation.fromJS(_data["headerDocument"]) : <any>undefined;
            this.bodyDocument = _data["bodyDocument"] ? DocumentLocation.fromJS(_data["bodyDocument"]) : <any>undefined;
            this.footerDocument = _data["footerDocument"] ? DocumentLocation.fromJS(_data["footerDocument"]) : <any>undefined;
            this.singlePageFlag = _data["singlePageFlag"];
            this.appendPageFlag = _data["appendPageFlag"];
            this.appendPageLocation = _data["appendPageLocation"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["referencedEntities"])) {
                this.referencedEntities = [] as any;
                for (let item of _data["referencedEntities"])
                    this.referencedEntities.push(SamplicityReferencedEntity.fromJS(item));
            }
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        this.context[key] = _data["context"][key];
                }
            }
            (<any>this).creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PdfConversionRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfConversionRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saveLocation"] = this.saveLocation;
        data["headerDocument"] = this.headerDocument ? this.headerDocument.toJSON() : <any>undefined;
        data["bodyDocument"] = this.bodyDocument ? this.bodyDocument.toJSON() : <any>undefined;
        data["footerDocument"] = this.footerDocument ? this.footerDocument.toJSON() : <any>undefined;
        data["singlePageFlag"] = this.singlePageFlag;
        data["appendPageFlag"] = this.appendPageFlag;
        data["appendPageLocation"] = this.appendPageLocation;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        if (Array.isArray(this.referencedEntities)) {
            data["referencedEntities"] = [];
            for (let item of this.referencedEntities)
                data["referencedEntities"].push(item.toJSON());
        }
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    data["context"][key] = this.context[key];
            }
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): PdfConversionRequestDto {
        const json = this.toJSON();
        let result = new PdfConversionRequestDto();
        result.init(json);
        return result;
    }
}

export interface IPdfConversionRequestDto {
    saveLocation: PdfConversionRequestDtoSaveLocation | undefined;
    headerDocument: DocumentLocation | undefined;
    bodyDocument: DocumentLocation | undefined;
    footerDocument: DocumentLocation | undefined;
    singlePageFlag: boolean | undefined;
    appendPageFlag: boolean | undefined;
    appendPageLocation: string | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    referencedEntities: SamplicityReferencedEntity[] | undefined;
    context: { [key: string]: string; } | undefined;
    creationTime: Date | undefined;
}

export class AjaxResponseOfPdfConversionResponseDto implements IAjaxResponseOfPdfConversionResponseDto {
    result: PdfConversionResponseDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    readonly __abp: boolean | undefined;

    constructor(data?: IAjaxResponseOfPdfConversionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PdfConversionResponseDto.fromJS(_data["result"]) : <any>undefined;
            this.targetUrl = _data["targetUrl"];
            this.success = _data["success"];
            this.error = _data["error"] ? ErrorInfo.fromJS(_data["error"]) : <any>undefined;
            this.unAuthorizedRequest = _data["unAuthorizedRequest"];
            (<any>this).__abp = _data["__abp"];
        }
    }

    static fromJS(data: any): AjaxResponseOfPdfConversionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResponseOfPdfConversionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["targetUrl"] = this.targetUrl;
        data["success"] = this.success;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["unAuthorizedRequest"] = this.unAuthorizedRequest;
        data["__abp"] = this.__abp;
        return data; 
    }

    clone(): AjaxResponseOfPdfConversionResponseDto {
        const json = this.toJSON();
        let result = new AjaxResponseOfPdfConversionResponseDto();
        result.init(json);
        return result;
    }
}

export interface IAjaxResponseOfPdfConversionResponseDto {
    result: PdfConversionResponseDto | undefined;
    targetUrl: string | undefined;
    success: boolean | undefined;
    error: ErrorInfo | undefined;
    unAuthorizedRequest: boolean | undefined;
    __abp: boolean | undefined;
}

export class PdfConversionResponseDto implements IPdfConversionResponseDto {
    pdfDocumentLocation: DocumentLocation | undefined;
    pageNumber: number | undefined;
    referencedEntities: SamplicityReferencedEntity[] | undefined;
    context: { [key: string]: string; } | undefined;
    readonly creationTime: Date | undefined;
    success: boolean | undefined;
    errorMessage: string | undefined;

    constructor(data?: IPdfConversionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pdfDocumentLocation = _data["pdfDocumentLocation"] ? DocumentLocation.fromJS(_data["pdfDocumentLocation"]) : <any>undefined;
            this.pageNumber = _data["pageNumber"];
            if (Array.isArray(_data["referencedEntities"])) {
                this.referencedEntities = [] as any;
                for (let item of _data["referencedEntities"])
                    this.referencedEntities.push(SamplicityReferencedEntity.fromJS(item));
            }
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        this.context[key] = _data["context"][key];
                }
            }
            (<any>this).creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): PdfConversionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfConversionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdfDocumentLocation"] = this.pdfDocumentLocation ? this.pdfDocumentLocation.toJSON() : <any>undefined;
        data["pageNumber"] = this.pageNumber;
        if (Array.isArray(this.referencedEntities)) {
            data["referencedEntities"] = [];
            for (let item of this.referencedEntities)
                data["referencedEntities"].push(item.toJSON());
        }
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    data["context"][key] = this.context[key];
            }
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        return data; 
    }

    clone(): PdfConversionResponseDto {
        const json = this.toJSON();
        let result = new PdfConversionResponseDto();
        result.init(json);
        return result;
    }
}

export interface IPdfConversionResponseDto {
    pdfDocumentLocation: DocumentLocation | undefined;
    pageNumber: number | undefined;
    referencedEntities: SamplicityReferencedEntity[] | undefined;
    context: { [key: string]: string; } | undefined;
    creationTime: Date | undefined;
    success: boolean | undefined;
    errorMessage: string | undefined;
}

export enum LocalizedValueLanguage {
    _0 = 0,
    _1 = 1,
}

export enum DocumentLocationStorageLocation {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum DocumentGenerationOptionsFormat {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum DocumentGenerationOptionsPersistence {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum DocumentGenerationOptionsDocumentRecordOptions {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum DocumentGenerationOptionsCommunicationRecordOptions {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum DocumentFragmentOutputFormat {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum DocumentFragmentTemplateEngine {
    _0 = 0,
    _1 = 1,
}

export enum OutboundCommunicationOptionsCommunicationRecordOptions {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum PdfConversionRequestDtoSaveLocation {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}